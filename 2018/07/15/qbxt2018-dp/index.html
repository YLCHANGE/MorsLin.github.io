<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="清北学堂2018DP&amp;图论精讲班 DP部分学习笔记"><meta name="keywords" content="DP"><meta name="author" content="MorsLin,undefined"><meta name="copyright" content="MorsLin"><title>清北学堂2018DP&amp;图论精讲班 DP部分学习笔记 | 默思·朸安</title><link rel="shortcut icon" href="https://s1.ax2x.com/2019/01/12/5d1Yf2.png"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-1"><span class="toc-number">1.</span> <span class="toc-text">Day 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午"><span class="toc-number">1.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1"><span class="toc-number">1.1.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2"><span class="toc-number">1.1.2.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例7"><span class="toc-number">1.1.3.</span> <span class="toc-text">例7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3"><span class="toc-number">1.1.4.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4"><span class="toc-number">1.1.5.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5"><span class="toc-number">1.1.6.</span> <span class="toc-text">例5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例6"><span class="toc-number">1.1.7.</span> <span class="toc-text">例6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午"><span class="toc-number">1.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#考试题目"><span class="toc-number">1.2.1.</span> <span class="toc-text">考试题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#官方题解"><span class="toc-number">1.2.2.</span> <span class="toc-text">官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#吐槽"><span class="toc-number">1.2.3.</span> <span class="toc-text">吐槽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-2"><span class="toc-number">2.</span> <span class="toc-text">Day 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-1"><span class="toc-number">2.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例8"><span class="toc-number">2.1.1.</span> <span class="toc-text">例8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例9"><span class="toc-number">2.1.2.</span> <span class="toc-text">例9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例10"><span class="toc-number">2.1.3.</span> <span class="toc-text">例10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-1"><span class="toc-number">2.1.4.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-1"><span class="toc-number">2.1.5.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3-1"><span class="toc-number">2.1.6.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-1"><span class="toc-number">2.1.7.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5-1"><span class="toc-number">2.1.8.</span> <span class="toc-text">例5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-1"><span class="toc-number">2.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-2"><span class="toc-number">2.2.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-2"><span class="toc-number">2.2.2.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3-2"><span class="toc-number">2.2.3.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-2"><span class="toc-number">2.2.4.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5-2"><span class="toc-number">2.2.5.</span> <span class="toc-text">例5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-3"><span class="toc-number">2.2.6.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-3"><span class="toc-number">2.2.7.</span> <span class="toc-text">例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-3"><span class="toc-number">3.</span> <span class="toc-text">Day 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-2"><span class="toc-number">3.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-4"><span class="toc-number">3.1.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-4"><span class="toc-number">3.1.2.</span> <span class="toc-text">例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-2"><span class="toc-number">3.2.</span> <span class="toc-text">下午</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例1-5"><span class="toc-number">3.3.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例2-5"><span class="toc-number">3.4.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例3-3"><span class="toc-number">3.5.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例4-3"><span class="toc-number">3.6.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例5-3"><span class="toc-number">3.7.</span> <span class="toc-text">例5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-4"><span class="toc-number">4.</span> <span class="toc-text">Day 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-3"><span class="toc-number">4.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-6"><span class="toc-number">4.1.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-6"><span class="toc-number">4.1.2.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3-4"><span class="toc-number">4.1.3.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-4"><span class="toc-number">4.1.4.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-5"><span class="toc-number">4.1.5.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5-4"><span class="toc-number">4.1.6.</span> <span class="toc-text">例5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-3"><span class="toc-number">4.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-7"><span class="toc-number">4.2.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-7"><span class="toc-number">4.2.2.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3-5"><span class="toc-number">4.2.3.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-6"><span class="toc-number">4.2.4.</span> <span class="toc-text">例4</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax2x.com/2018/07/13/qMrQ6.png"></div><div class="author-info__name text-center">MorsLin</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">28</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://rqy.moe/" target="_blank">_rqy</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/MisakaAzusa" target="_blank">zzc</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/Lance1ot" target="_blank">Lance1ot</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/pks-t/" target="_blank">Flower_pks</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/Yeasio-Nein" target="_blank">Sue</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/liuwenyao/" target="_blank">lwy</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.ax2x.com/2018/08/12/55kuri.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">默思·朸安</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">画廊</a><a class="site-page" href="/about">MorsLin</a></span></div><div id="post-info"><div id="post-title">清北学堂2018DP&amp;图论精讲班 DP部分学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/培训/">培训</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/培训/清北学堂/">清北学堂</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>讲的挺基础的……不过还是有些地方不太明白</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p> 给定一个数n，求将n划分成若干个正整数的方案数。</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p> 数字三角形</p>
<h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p>最长不下降子序列</p>
<p><strong>以上太过于基础，不做深入讨论</strong></p>
<hr>
<h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>给定一个数n，求将n划分成若干个正整数的方案数。</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示用不超过$j$的数来组成$i$</p>
</li>
<li><p>状态转移<br>$i &lt; j \;\;\; dp[i][j]=dp[i][i]$<br>$i = j \;\;\; dp[i][j]=dp[i][j-1]+1$<br>$i &gt; j \;\;\; dp[i][j]=dp[i-j][j-1]+dp[i][j-1]$</p>
</li>
</ul>
<h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>一个人站在楼梯的第一级上，每次他可以向上走1~m级。有某些级楼梯是坏的，不能走上去。而且连续走了$k$次$m$级之后你接下来的一步只能走1级。问走到第N级的方案数。</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$在第$i$级台阶上，连续走了$j$次$m$级</p>
</li>
<li><p>状态转移<br>$ \sum_{j=1}^{m-1}dp[i+j][0]+= \sum_{l=0}^{k-1}dp[i][l]$(我自己按老师的意思写的方程我自己都看不懂……)<br>$dp[i+1][0]+=dp[i][k]$<br>$dp[i+m][l+1]+=f[i][l]\;(l\neq k)$</p>
</li>
</ul>
<h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><a href="http://codeforces.com/problemset/problem/467/C" target="_blank" rel="noopener">Codeforces 467C George and Job</a></p>
<p>给定一个长度为n的序列，从序列中选出k个不重叠且连续的m个数，要求和最大。<br>$1&lt;=m\times k&lt;=n&lt;=5000$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$sum[]$为前缀和，$dp[i][j]$选了$j$段，以$i$为结尾</p>
</li>
<li><p>状态转移<br>$dp[i][j]=max(dp[i-m][j-1]+sum[i]-sum[i-m],dp[i-1][j])$</p>
</li>
</ul>
<h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1354" target="_blank" rel="noopener">51nod 1354 选数字</a></p>
<p>当给定一个序列$a[0],a[1],a[2],…,a[n-1]$和一个整数$K$时，我们想找出有多少子序列里面的所有元素乘起来恰好等于$K$。<br>方案数对$10^9+7$取模。<br>$n &lt;= 1000,k &lt;= 10^8$</p>
<p><strong>不会，全程懵逼</strong></p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>考试，估计要爆零……</p>
<p>嗯，60分，还不错——至少比想象中的高</p>
<h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/problemset.pdf" target="_blank" rel="noopener">考试题目</a></h3><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/sol.pdf" target="_blank" rel="noopener">官方题解</a></h3><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul>
<li><p>T1<br>只能说我太菜了，根本不会DP，爆搜+数据特判，40分滚粗</p>
</li>
<li><p>T2<br>我会最短路，怎么才20分？好吧，那30%$k=1$的测试点我承认我删边删错了。题目是双向边，我也是按双向边存的，结果删的时候只删了一条边……</p>
</li>
<li><p>T3<br>不会，讲了也不会 (｀＾´)ノ</p>
</li>
</ul>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>上午先讲了昨天没讲完的几道题，好吧，我太菜了，一道也不会 QAQ</p>
<hr>
<p>接Day1 例7</p>
<h3 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1294" target="_blank" rel="noopener">51nod 1294 修改数组</a></p>
<p>给出一个整数数组A，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？<br>$ n &lt; = 100000$</p>
<p>题解：</p>
<p>这道题思路很妙。</p>
<ul>
<li>$a[\;]$表示原序列<br>首先，我们将每个数$a[i]$减去它们对应的下标$i$，然后将$&lt; 0$的$a[i]$删去。因为每一个数都要是正整数，所以如果$a[i] &lt; i$，那它肯定不符合要求。<br>然后我们再在更改后的序列上找最长不下降子序列。最后用n-最长不下降子序列的长度就OK了</li>
</ul>
<h3 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h3><p>OpenJudge 6047 (找不到这道题 $\rm{Orz}$)</p>
<p>有一块矩形大蛋糕，长和宽分别是整数$w ,h$。现要将其切成$m$块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的$m$块小蛋糕中，最大的那块蛋糕的面积下限。<br>$w,h,m &lt;= 20$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k]$表示长宽为$i,j$的蛋糕切$k$刀的答案</p>
</li>
<li><p>边界条件<br>$dp[i][j][0]=i\times j$</p>
</li>
<li><p>状态转移<br>$dp[i][j][k]=min(max(dp[i][o][p],dp[i][j-o][k-1-p],dp[o][j][p],dp[i-o][j][k-p-1]))$</p>
</li>
</ul>
<h3 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h3><p><a href="http://codeforces.com/problemset/problem/407/B" target="_blank" rel="noopener">Codeforces 407B Long Path</a></p>
<p>有$n+1$个房间，一个人在1号房间。如果这是他第奇数次到当前房间（$i$号），那么他会去$pi\; (pi { &lt;= }i)$号房间，否则他会去$i+1$号房间。不管他去了那个房间，他的移动次数+1。<br>到达n+1号房间停止移动。问这时他的移动次数。答案对$1000000007$取模。<br>$n &lt;= 1000$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][0]$表示奇数次到达$i$号房间，$dp[i][1]$表示偶数次到达$i$号房间</p>
</li>
<li><p>状态转移<br>方程不如代码好表达(不想再写一个自己都看不懂的$\Sigma$了)，所以我就把代码给搬上来了 qwq</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[i]是原序列,dp数组如上所说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;i;j++)</span><br><span class="line">        dp[i][<span class="number">1</span>]+=(dp[j][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n][<span class="number">1</span>]+dp[n][<span class="number">0</span>])%mod;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，基础(?)的DP就讲完了</p>
<hr>
<p>进入——<strong>区间DP</strong></p>
<h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1541" target="_blank" rel="noopener">NOIp2010 乌龟棋</a></p>
<p>在一行$n$个格子上进行游戏，每个格子有一个分数$a[i]$。你在$1$号格子，每次可以向前走$1/2/3/4$个格子，每种走法限制最多走$b_1/b_2/b_3/b_4$次。一次走法的分数是走过的格子的分数和。问走到n号格子的最大分数。<br>保证$b_1+2\times b_2+3\times b_3+4\times b_4=n-1$（恰好走完所有的次数）<br>$n&lt;=350,a[i]&lt;=100,b_i&lt;=40$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k][l]$表示各种类别的卡片分别还剩多少</p>
</li>
<li><p>状态转移<br>算了，本来想打方程的，懒了，丢代码吧，感受一下四维DP的魅力吧！ 233</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cards[<span class="number">1</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cards[<span class="number">2</span>];j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cards[<span class="number">3</span>];k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cards[<span class="number">4</span>];l++)&#123;</span><br><span class="line">          pos=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span>(i) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(j) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(k) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(l) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+mark[pos]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[cards[<span class="number">1</span>]][cards[<span class="number">2</span>]][cards[<span class="number">3</span>]][cards[<span class="number">4</span>]]+mark[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P2679" target="_blank" rel="noopener">NOIp2015 子串</a></p>
<p>有两个仅包含小写英文字母的字符串$A$和$B$。现在要从字符串$A$中取出$k$个互不重叠的非空子串,然后把这$k$个子串按照其在字符串$A$中出现的顺序依次连接起来得到一个新的字符串,请问有多少种方案可以使得这个新串与字符串$B$相等？注意：子串取出的位置不同也认为是不同的方案。输出方案数%1000000007<br>$length(A) &lt;= 1000,1 &lt;= k &lt;= length(B) &lt;= 200$</p>
<p>题解：</p>
<p>这道挺毒的，卡空间，必须用滚动数组优化</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k][0/1]$表示字符串$A$到$i$，字符串$B$到$j$，取出了$k$个字符串，第$i$个字符选不选</p>
</li>
<li><p>边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态转移<br>以后有代码就直接丢代码了，懒了懒了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++,pos^=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=k;o++)&#123;</span><br><span class="line">          dp[pos][j][o][<span class="number">0</span>]=dp[pos^<span class="number">1</span>][j][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j][o][<span class="number">0</span>]%mod;</span><br><span class="line">          <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            dp[pos][j][o][<span class="number">1</span>]=dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">0</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">1</span>]%mod;</span><br><span class="line">          <span class="keyword">else</span> dp[pos][j][o][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n&amp;<span class="number">1</span>][m][k][<span class="number">0</span>]+dp[n&amp;<span class="number">1</span>][m][k][<span class="number">1</span>])%mod;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">NOI1995 石子合并</a></p>
<p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。<br>$n { &lt;= } 100$</p>
<p>题解：</p>
<p>这个题目要求最小代价，除了最小代价，Luogu还要求求出最大代价，不过实现的方法一模一样</p>
<p>很经典的一道题目，区间DP入门必刷题</p>
<p>首先要破环为链+前缀和处理</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示合并区间$[i,j]$的最小代价</p>
</li>
<li><p>状态转移</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+n;j++)&#123;</span><br><span class="line">	  dp2[i][j]=<span class="number">214748364</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">	  	dp2[i][j]=min(dp2[i][j],dp2[i][k]+dp2[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1040" target="_blank" rel="noopener">NOIp2003 加分二叉树</a></p>
<p>设一个$n$个节点的二叉树$tree$的中序遍历为$(1,2,3,…,n)$，其中数字$1,2,3,…,n$为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为$di$,$tree$及它的每个子树都有一个加分，任一棵子树$subtree$（也包含$tree$）的加分计算方法如下：<br>$subtree$的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。<br>若某个子树为空，规定其加分为$1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>试求一棵符合中序遍历为$(1,2,3,…,n)$且加分最高的二叉树$tree$。要求输出$tree$的最高加分<br>$n {&lt;=} 30$</p>
<p>题解：</p>
<p>emmmm，第三次碰到这题了，到现在还记得当时爆零的屈辱</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示区间$[i,j]$的最大得分</p>
</li>
<li><p>边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	dp[i][i]=num[i]; <span class="comment">//num[ ]为原序列</span></span><br><span class="line">	dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态转移</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">	  <span class="keyword">if</span>(dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k]&gt;dp[i][j])&#123;</span><br><span class="line">			  dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k];</span><br><span class="line">			  tree[i][j]=k; <span class="comment">//用于输出</span></span><br><span class="line">	  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出<br>这道题输出也是个坑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;tree[l][r]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	print(l,tree[l][r]<span class="number">-1</span>);</span><br><span class="line">	print(tree[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例5-1"><a href="#例5-1" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">SCOI2003 字符串折叠</a></p>
<p>折叠的定义如下：</p>
<p>一个字符串可以看成它自身的折叠。记作$S = S$<br>$X(S)$是$X(X&gt;1)$个$S$连接在一起的串的折叠。记作$X(S) = SSSS…S(X$个$S)$。</p>
<p>如果$A = A’,B = B’$，则$AB = A’B’$例如，因为$3(A) = AAA, 2(B) = BB$，所以$3(A)C2(B) = AAACBB$，而$2(3(A)C)2(B) = AAACAAACBB$</p>
<p>给一个字符串，求它的最短折叠。例如$AAAAAAAAAABABABCCD$的最短折叠为：$9(A)3(AB)CCD$。</p>
<p><strong>日常懵逼，不会</strong></p>
<p>区间DP就这么结束了</p>
<hr>
<p>接下来是<strong>背包</strong>和<strong>数位DP</strong></p>
<p><strong>背包</strong></p>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>因篇幅原因$+$过于基础，在这里我们<strong>跳过所有背包模板</strong></p>
<h3 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h3><p>有$n$个人参加拔河比赛，要把他们分为两组，每人的实力为$a_i$，一组的实力为这组人的实力之和。求两队实力差的最小值。（两队的人数没有限制）</p>
<p>题解：</p>
<p>以$\frac{\sum_{i=1}^{n}a[i]}{2}$为背包容量，跑一遍阉割版的01背包即可</p>
<h3 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1782" target="_blank" rel="noopener">Luogu P1782 旅行商的背包</a></p>
<p>你有一个背包容积为$V$，有$n$种不可分割的物品（每种$p_i$个），每件的体积为$v_i$和价值$c_i$，你还有$m$种神奇的物品，它们的价值$c_i=a<em>v^2+b</em>v+c$，$v$是你决定的这件物体体积（大于等于0）。求最优价值。<br>$V&lt;=1000,n&lt;=1000,p_i&lt;=1000,m&lt;=5$</p>
<p>题解：</p>
<p>两种背包分开跑，先跑神奇的物品，再用跑完的dp数组去跑多重背包</p>
<h3 id="例3-2"><a href="#例3-2" class="headerlink" title="例3"></a>例3</h3><p><a href="https://vijos.org/p/1240" target="_blank" rel="noopener">Vijos P1240 朴素的网络游戏</a></p>
<p>有一家旅馆，有$n$间房间，每间可以住$a_i$人，需要$b_i$元。<br>有$i$个男人，$j$个女人来住宿，其中有$k$对夫妻，要求每间房间住的全是同性或者是一对夫妻(单人间无法住夫妻)。<br>问最少的总租金。<br>$n,i,j&lt;=300$</p>
<p>题解：</p>
<p><del>一看到这道题，机房里就充满了快♂活的气息</del></p>
<p> 首先，你需要想到：存在一种最优方案使得之多有一对夫妻在一件房间内。因为如果有两对，使两个男性住一间，两个女性住一间。</p>
<p>所以这道题里，我们只要考虑有一对夫妻就可以了</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k][0/1]$表示前$i$个房间里住了$j$个男性、$k$个女性、有没有夫妻</p>
</li>
<li><p>状态转移<br>$dp[i][j][k][0]=min(dp[i-1][j][k][0],dp[i-1][j-a[i]][k][0]+b[i],dp[i-1][j][k-a[i]][0]+b[i])$<br>$dp[i][j][k][1]=min(dp[i-1][j][k][1],dp[i-1][j-1][k-1][0]+b[i],$ $dp[i-1][j-a[i]][k][1]+b[i],dp[i-1][j][k-a[i]][1]+b[i])$</p>
</li>
</ul>
<h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1877" target="_blank" rel="noopener">HAOI2012 音量调节</a></p>
<p>开始有一个数$begin$，给一个长为$n$的序列$c_i$，每次操作可以选择把开始的数加或减$c_i$，变为新的数，之后在上一次的数的基础上加或减。要求每次操作之后的数要大于等于0，小于等于$max$，求最后一次操作之后这个数的最大值。如果没有满足要求的解输出-1.<br>$0 {&lt;=} begin {&lt;=} max {&lt;=} 1000,1{&lt;=}n{&lt;=}50$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示$i$次操作后，数为$j$是否可行</p>
</li>
<li><p>状态转移<br>$if\;\;dp[i][j]{==}1$<br>$dp[i+1][j+c[i]]=1(j+c[i]&lt;=max)$<br>$dp[i+1][j-c[i]]=1(j-c[i]&gt;=0)$</p>
</li>
</ul>
<h3 id="例5-2"><a href="#例5-2" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2287" target="_blank" rel="noopener">Bzoj 2287 消失之物</a></p>
<p>有$n$件物品，每件物品有体积$v_i$，问装满体积$V$的方案数。答案对10取模。<br>但是你要输出：如果第i件物品消失了，装了体积为j的方案数。$i=1…n,j=1…V$<br>$n,V&lt;=1000$</p>
<p><strong>嗯，不会</strong></p>
<hr>
<p><strong>数位</strong></p>
<p>感觉数位DP有些迷，真心没怎么听懂</p>
<h3 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h3><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009" target="_blank" rel="noopener">51nod 1009 数字1的数量</a></p>
<p>给定一个十进制正整数N，写下从1开始，到N的所有正数，计算出其中出现所有1的个数。<br>例如：n = 12，包含了5个1。1,10,12共包含3个1，11包含2个1，总共5个1。</p>
<p>题解：</p>
<ul>
<li><p>首先可以预处理出来如果后$i$位数字随便选，那么一共有多少个$1$，记为$f[i]$。$f[i]=i\times 10^{i-1}$<br>分别计算如果前$i$位和$n$的前$i$位恰好相同，那么有多少个$1$.</p>
</li>
<li><p>如：<br>$n=124056$ 第一位为0~1<br>考虑第一位为0时，那么之后的位可以随便选，对答案贡献$f[5]$，而这一位的0不贡献答案<br>第一位为1时，那么之后的为不能随便选，只有$24057$种选法。这一位对答案的贡献是$24057$，之后继续计算后五位对答案的贡献<br>此时第一位固定为$1$。第二位可以是$0/1/2$。<br>是0时，第2位不贡献答案，但是后面4位随便选。贡献$f[4]$<br>是1时，第2位贡献答案为$10^4$。后面4位随便选，贡献$f[4]$<br>是2时，第2位不贡献答案，后面4位不能随便选，答案不能直接计算，继续固定第二位，看第3位的数值<br>……<br>直到最后一位。</p>
</li>
</ul>
<h3 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3652" target="_blank" rel="noopener">Hdu 3652 B-number</a></p>
<p>找出1~n范围内含有13并且能被13整除的数字的个数<br>$n&lt;=10^{17}$</p>
<p><strong>我太菜了，van♂全不会</strong></p>
<p>背包和数位就到此结束了</p>
<hr>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>接下来让我们进入<strong>状压DP</strong></p>
<h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-4"><a href="#例1-4" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P2622" target="_blank" rel="noopener">Luogu P2622 关灯问题II</a></p>
<p>现有$n$盏灯，以及$m$个按钮。每个按钮可以同时控制这$n$盏灯——按下了第$i$个按钮，对于所有的灯都有一个效果。按下$i$按钮对于第$j$盏灯，是下面3中效果之一：如果$a[i][j]$为$1$，那么当这盏灯开了的时候，把它关上；如果为$-1$的话，如果这盏灯是关的，那么把它打开；如果是$0$，则无效果。<br>现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。</p>
<p>题解：</p>
<ul>
<li><p>emmmmm，这题只状压，不DP</p>
</li>
<li><p>存状态的时候状压</p>
</li>
<li><p>然后将能互相到达的状态之间连边，然后广搜最短路就好了</p>
</li>
</ul>
<h3 id="例2-4"><a href="#例2-4" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1896" target="_blank" rel="noopener">SCOI2005 互不侵犯</a></p>
<p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上、下、左、右，以及左上、左下、右上、右下八个方向上附近的各一个格子，共8个格子。<br>$n&lt;=9,k&lt;=n^2$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>肯定要状压<br>$dp[i][k][j]$表示前$i$行放了$k$个国王，j表示第$i$行的摆放方式</p>
</li>
<li><p>状态转移<br>我们要快速的判断摆放方式是否合法<br>用$i$表示某一行的状态</p>
<ul>
<li>同一行<br>$i\And (i { &gt; &gt; }1)$</li>
<li>相邻行的状态$k$<br>$i\And k$<br>$i\And (k{ &gt; &gt; }1)$<br>$i\And (k{ &lt; &lt; }1)$</li>
</ul>
<p>以上的式子中如果有一个结果为1，说明无法转移<br>$get[i]$表示数字$i$的二进制位中$1$的数量，也就是第$i$行的国王数量，$l$表示$i-1$行国王的状态<br>$dp[i][k][j]+=dp[i-1][k-get[i]][l]$</p>
</li>
</ul>
<p>状压完结散花</p>
<hr>
<p>欢迎来到<strong>DP优化</strong>！</p>
<h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><p>除了例1，别的啥都不会，只会暴力DP……什么矩阵加速、数据结构维护，不存在的。</p>
<h2 id="例1-5"><a href="#例1-5" class="headerlink" title="例1"></a>例1</h2><p>斐波那契数列<br>$f[1]=f[2]=1$<br>$f[n]=f[n-1]+f[n-2] (n {&gt;=} 3)$<br>求$f[n]\mod(10^9+7)$<br>$n&lt;=10^{18}$</p>
<p>题解：</p>
<p>矩阵快速幂加速，不解释</p>
<h2 id="例2-5"><a href="#例2-5" class="headerlink" title="例2"></a>例2</h2><p><a href="http://codeforces.com/problemset/problem/821/E" target="_blank" rel="noopener">Codeforces 821E Okabe and El Psy Kongroo</a></p>
<p>你在$(0,0)$。在$(x,y)$时，每次移动可以到达$(x+1,y+1),(x+1,y),(x+1,y-1)$，平面上有$n$条线段，平行于$x$轴，参数为$a_i,b_i,c_i$，表示在$(a_i,c_i)$到$(b_i,c_i)$的一条线段，保证$b[i]=a[i+1]$，要求你一直在线段的下方且在$x$轴上方，即$a_i {&lt;= } x { &lt;=} b_i$时，$0 { &lt;= }y{ &lt;= }c_i$。问到达$(k,0)$的方案数，对$10^9+7$取模。<br>$n&lt;=100,k&lt;=10^{18},ci&lt;=15$</p>
<p>题解：</p>
<p>实现不是很会，但明白了做法，思路确实很神奇</p>
<p>直接DP就是：$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+dp[i+1][j-1]$</p>
<p>但是肯定会T，所以我们可以用矩阵来加速</p>
<p>$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}$ $\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}$</p>
<p>这样应该就可以了吧？(超级不自信)</p>
<h2 id="例3-3"><a href="#例3-3" class="headerlink" title="例3"></a>例3</h2><p><a href="http://noi.openjudge.cn/ch0206/9277/" target="_blank" rel="noopener">Openjudge  Noi 9277 Logs Stacking</a></p>
<p>给出在最底层的木头的个数，问有多少种堆放木头的方式，当然你的堆放方式不能让木头掉下来.<br>在堆放的时候木头必须互相挨着在一起.<br>$n &lt;= 200000$</p>
<p>题解：</p>
<ul>
<li><p>正常解法<br>$dp[i]=dp[i]+s[i]$<br>其中s是dp的前缀和。</p>
</li>
<li><p>非正常解法<br>找规律 2333</p>
</li>
</ul>
<h2 id="例4-3"><a href="#例4-3" class="headerlink" title="例4"></a>例4</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 4362 Dragon Ball</a></p>
<p>在连续的$n$秒中，在$x$轴上每秒会出现$m$个龙珠，出现之后会立即消失，知道了第一秒所在的位置，每从一个位置移动到另一个位置的时候，消耗的价值为$abs(i-j)$, 拿到龙珠也要消耗一个价值（不同龙珠的价值不同），问$n$秒之后最少消耗多少价值。<br>$m &lt;= 500,n&lt;=1000$</p>
<p>题解：</p>
<p>虽然老师在上面讲+$\mathfrak{Lancelot}$ dalao给我私下讲，但我还是有些迷，我太蒟了怎么破QAQ</p>
<ul>
<li><p>暴力DP<br>$dp[i][j]$表示在$i$秒后，在第$j$个龙珠的位置上的最小代价。<br>$dp[i][j]=min(dp[i-1][k]+abs(pos[i-1][k]-pos[i][j]))(k=1..m)+cost[i][j]$<br>时间复杂度$O(m^2n)$</p>
</li>
<li><p>优化DP<br>把绝对值拆开，变成向左走和向右走两种。<br>把当前时间的龙珠按位置排序，从左到右扫描，维护一个最小的$s=dp[i-1][k]-pos[i-1][k]$，这样$dp[i][j]=s+pos[i][j]+cost[i][j]$<br>从右到左类似。<br>$O(mnlogm)$</p>
</li>
</ul>
<h2 id="例5-3"><a href="#例5-3" class="headerlink" title="例5"></a>例5</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 5009 Paint Pearls</a></p>
<p>给你一个数组，每个值代表一种颜色，每次选一个区间删去，代价是区间内颜色种类数的平方，删完所有数组，问你最小代价是多少。<br>$n&lt;=50000$</p>
<p>题解：</p>
<p>没怎么听<del>因为听了也听不懂</del></p>
<p>但是应该是双向链表+DP。DP转移时直接从上一个最后一次出现的颜色那转移过来就可以。另外，区间的长度最多为$\sqrt n$个，也可以剪枝<br>时间复杂度$O(n\sqrt{n})$</p>
<p>DP优化也就这样了</p>
<hr>
<p>嗯，树上DP了解一下</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-6"><a href="#例1-6" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1352" target="_blank" rel="noopener">Luogu P1352 没有上司的舞会</a></p>
<p>某大学有$N$个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。<br>$n&lt;=6000$</p>
<p>题解：</p>
<p>树上DP经典题目</p>
<ul>
<li><p>定义状态<br>$dp[i][0/1]$表示节点i不被选/被选所获得的最大快乐指数</p>
</li>
<li><p>边界条件<br>$dp[leaf][1]=a[i]$<br>$leaf$表示叶子结点，$a[i]$是原序列</p>
</li>
<li><p>状态转移<br>$dp[from][0]+=max(dp[to][1],dp[to][0])$<br>$dp[from][1]+=dp[to][0]+a[from]$</p>
</li>
</ul>
<h3 id="例2-6"><a href="#例2-6" class="headerlink" title="例2"></a>例2</h3><p>树的直径</p>
<p>给一棵树，求树上最长路径的长度。<br>$n&lt;=500000$</p>
<p>题解：</p>
<ul>
<li><p>解法一：</p>
<ul>
<li>DP<br>考虑树上dp，确定一个根，一条路径一定存在一个深度最浅的节点。枚举每个点成为lca，看向子树伸出去的两条路径的长度和最长是多少。<br>$dp[i][0/1]$表示从i号点向下的最长/次长路径长度。<br>$dp[i][0]=max(dp[son][0])+1$注意只能用每个子树的最长路径更新i的最长和次长路径。即使一个子树次长路径很大，也不能更新，否则lca不是i。<br>$O(n)$</li>
</ul>
</li>
<li><p>解法二：</p>
<ul>
<li>随便找一个点，用$\mathcal{dfs}$找到离这个点最远的点$i$，再用$\mathcal{dfs}$找离$i$最远的点$j$。$i$到$j$的路径是一条直径。<br>证明正确性吗？不存在的，我懒得打了（逃。<br>P.S. 法二不能用于负边权</li>
</ul>
</li>
</ul>
<h3 id="例3-4"><a href="#例3-4" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P2014" target="_blank" rel="noopener">Luogu P2014 选课</a></p>
<p>有$n$节课可以选，每节课有至多一个前置课程，和这节课的学分，问如果只能选$m$节课，最多有多少学分。<br>$n&lt;=300$</p>
<p>题解：</p>
<ul>
<li><p>我说这题是树上跑背包你信么？</p>
</li>
<li><p>算法主体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">310</span>][<span class="number">310</span>],a[<span class="number">310</span>],n,m; <span class="comment">//dp[i][j]表示a[ ]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    dp[f][<span class="number">1</span>]=a[f];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i!=<span class="number">-1</span>;i=tree[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=tree[i].t; dfs(to);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o=j<span class="number">-1</span>;o&gt;=<span class="number">1</span>;o--)</span><br><span class="line">              dp[f][j]=max(dp[f][j],dp[f][j-o]+dp[to][o]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例4-4"><a href="#例4-4" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4679" target="_blank" rel="noopener">Hdu 4079 Terrorist’s destroy</a></p>
<p>给定一颗树，每条边有一个权值w,问切掉哪条边之后，分成的两颗树的较大的直径*切掉边的权值最小？如果存在多条边使得结果相同，输出边id最小的。<br>$n&lt;=100000$</p>
<p>题解：</p>
<p>我们要分类讨论一下：</p>
<ul>
<li><p>要切的边在不在直径上<br>我们直接用那条边的权值去乘直径就可以了</p>
</li>
<li><p>要切的边在直径上<br>这时就需要我们能够快速的算出切开后两部分的的直径<br>要解决这个问题，我们要先算出图的一条直径，记下起点$s$和终点$t$，然后分别以$s$和$t$为根，去找直径，处理出来的$dp[u]$就是$fa[u]-&gt;u$被切开后的直径</p>
</li>
</ul>
<h3 id="例4-5"><a href="#例4-5" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/CF219D" target="_blank" rel="noopener">Codeforces 219D Choosing Capital for Treeland</a></p>
<p>给一棵树，每条边有方向，改变一条边方向的代价是1.<br>对于一个点，如果选它为根，那么需要把方向不对的边改变方向（都变成深度小的点指向深度大的点）。<br>问选一个点为根的最小代价。和选哪些点的代价是这个数字。<br>$n&lt;=200000$</p>
<p>题解：</p>
<p>$dp[u]$表示以$u$为根要调整的次数，再记录下方向<br>一遍DFS，同向加，反向减</p>
<h3 id="例5-4"><a href="#例5-4" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P2607" target="_blank" rel="noopener">ZJOI2008 骑士</a></p>
<p>给一个环套树森林，求最大权独立集。（就是相邻的点不能同时选）<br>$n&lt;=1000000$</p>
<p>题解：</p>
<blockquote>
<p>先找到那个环。随便找两个点，暴力枚举这两个点选不选。之后变成森林。</p>
</blockquote>
<p>这是老师PPT上的题解，就一句话，十分简练。</p>
<p>嗯，然后我就懵逼了……</p>
<p>树型DP就这么在懵逼中结束了，接下来有更懵逼的……</p>
<hr>
<p>期望DP是什么？能吃吗？斜率优化又是什么？</p>
<p>讲真，下午彻底懵逼</p>
<h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><h3 id="例1-7"><a href="#例1-7" class="headerlink" title="例1"></a>例1</h3><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3551" target="_blank" rel="noopener">Zoj 3551 Bloodsucker</a></p>
<p>开始有一个吸血鬼，n-1个平民百姓。每天等概率选出两个人，如果是一个吸血鬼一个平民，平民以p的概率被转化为吸血鬼，否则什么也不发生。问每个人都变成吸血鬼的天数期望。<br>$n&lt;=100000$</p>
<p>题解：</p>
<p>设$dp[i]$为有$i$个吸血鬼的话还期望需要多少天完成。<br>设$p[i]$为此时转换了一个平民的概率。<br>$p[i]=\frac{2\times (n-i)\times i}{n\times(n-1)}\times p$<br>$dp[i]=p[i]\times dp[i+1]+(1-p[i])\times(dp[i])+1$</p>
<h3 id="例2-7"><a href="#例2-7" class="headerlink" title="例2"></a>例2</h3><p><a href="http://poj.org/problem?id=3744" target="_blank" rel="noopener">Poj 3744 Scout YYF I</a></p>
<p>在$x$轴上，你现在的起点在$1$处。在$N$个点处布有地雷，$1&lt;=N&lt;=10$。地雷点的坐标范围：$[1,100000000]$.<br>每次前进$p$的概率前进$1$步，$1-p$的概率前进$2$步。问顺利通过这条路的概率。就是不要走到有地雷的地方。</p>
<p>题解：</p>
<ul>
<li><p>设$dp[i]$表示一条路径经过i的概率。<br>$dp[1]=1,dp[i]=p\times dp[i-1]+(1-p)\times dp[i-2]$<br>快速幂算出$1-dp[x_1]$就是安全通过第一个地雷的概率，此时在$x_1+1$，你又要通过$x_2,…x_n$，就是把$(x_1+1)\text{~}x_2$再做一次，全都安全通过的概率乘起来。</p>
</li>
<li><p><em>嗯，以上全都是抄的老师的PPT</em></p>
</li>
</ul>
<h3 id="例3-5"><a href="#例3-5" class="headerlink" title="例3"></a>例3</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2262" target="_blank" rel="noopener">hdu 2262 Where is the canteen</a></p>
<p>现在在一个$n\times m$规模的区域上从$’@’$处出发,每次都随机向前后左右四个方向中选择可以走的方向进入（’#’不可走, 不能越过边界）。现在问到达终点 $ 的期望步数, 终点可能有多个, 输入保证一定有起点$n,m&lt;=15$, 如果无法到达任何一个终点输出$-1$</p>
<p>题解：</p>
<p>高斯消元，爱信不信。</p>
<h3 id="例4-6"><a href="#例4-6" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">hdu 3507 Print Article</a></p>
<p>给一个数列ai，要求划分成若干段，一段的代价是$\sum a_i^2+M$，总的代价是每段代价和。<br>求最小总代价。<br>$n&lt;=500000$</p>
<p>题解：</p>
<ul>
<li>嗯，真·斜率优化</li>
<li>嗯，真·不会</li>
<li>嗯，还是把老师的代码放上来吧</li>
</ul>
<p>膜拜一下老师 orz<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , sum[<span class="number">500010</span>] , q[<span class="number">500010</span>] , dp[<span class="number">500010</span>] , head , tail;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getup</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x] + sum[x]*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdown</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) <span class="built_in">scanf</span> ( <span class="string">"%d"</span> , &amp;sum[i] );</span><br><span class="line">    sum[<span class="number">0</span>] = dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">    q[<span class="number">1</span>] = <span class="number">0</span>; head = tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">        <span class="comment">//斜率优化</span></span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; getup(q[head+<span class="number">1</span>]) - getup(q[head]) &lt;= sum[i]*(getdown(q[head+<span class="number">1</span>])-getdown(q[head])) ) head++;</span><br><span class="line">        dp[i] = dp[q[head]] + ( sum[i] - sum[q[head]] ) * ( sum[i] - sum[q[head]] ) + m;</span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; ( getup(q[tail]) - getup(q[tail<span class="number">-1</span>])) * ( getdown(i) - getdown(q[tail]) ) &gt;=</span><br><span class="line">                                            ( getup(i) - getup(q[tail]) ) * ( getdown(q[tail]) - getdown(q[tail<span class="number">-1</span>]) ) ) tail--;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%d\n"</span> , dp[n] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span> ( <span class="string">"%d%d"</span> , &amp;n , &amp;m ) != EOF ) work ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，DP应该就告一段落了。</p>
<p>我DP掌握的还是不够好，以后也要多加锻炼。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MorsLin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://morslin.github.io/2018/07/15/qbxt2018-dp/">https://morslin.github.io/2018/07/15/qbxt2018-dp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://morslin.github.io" target="_blank">默思·朸安</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DP/">DP</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/22/qbxt2018-tl/"><i class="fa fa-chevron-left">  </i><span>清北学堂2018DP-图论精讲班-图论学习笔记</span></a></div></nav><div class="post-adv"></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By MorsLin</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><p id="hitokoto">:D 获取中...</p><script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>