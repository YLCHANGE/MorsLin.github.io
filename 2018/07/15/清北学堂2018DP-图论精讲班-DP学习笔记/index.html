<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="清北学堂2018DP&amp;图论精讲班 DP部分学习笔记"><meta name="keywords" content="学习笔记"><meta name="author" content="MorsLin,undefined"><meta name="copyright" content="MorsLin"><title>清北学堂2018DP&amp;图论精讲班 DP部分学习笔记 | 默思·朸安</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-1"><span class="toc-number">1.</span> <span class="toc-text">Day 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午"><span class="toc-number">1.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1"><span class="toc-number">1.1.1.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2"><span class="toc-number">1.1.2.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例7"><span class="toc-number">1.1.3.</span> <span class="toc-text">例7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3"><span class="toc-number">1.1.4.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4"><span class="toc-number">1.1.5.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5"><span class="toc-number">1.1.6.</span> <span class="toc-text">例5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例6"><span class="toc-number">1.1.7.</span> <span class="toc-text">例6</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午"><span class="toc-number">1.2.</span> <span class="toc-text">下午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#考试题目"><span class="toc-number">1.2.1.</span> <span class="toc-text">考试题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#官方题解"><span class="toc-number">1.2.2.</span> <span class="toc-text">官方题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#吐槽"><span class="toc-number">1.2.3.</span> <span class="toc-text">吐槽</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Day-2"><span class="toc-number">2.</span> <span class="toc-text">Day 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#上午-1"><span class="toc-number">2.1.</span> <span class="toc-text">上午</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例8"><span class="toc-number">2.1.1.</span> <span class="toc-text">例8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例9"><span class="toc-number">2.1.2.</span> <span class="toc-text">例9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例10"><span class="toc-number">2.1.3.</span> <span class="toc-text">例10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例1-1"><span class="toc-number">2.1.4.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2-1"><span class="toc-number">2.1.5.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3-1"><span class="toc-number">2.1.6.</span> <span class="toc-text">例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4-1"><span class="toc-number">2.1.7.</span> <span class="toc-text">例4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5-1"><span class="toc-number">2.1.8.</span> <span class="toc-text">例5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#下午-1"><span class="toc-number">2.2.</span> <span class="toc-text">下午</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax2x.com/2018/07/13/qMrQ6.png"></div><div class="author-info__name text-center">MorsLin</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">2</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://rqy.moe/" target="_blank">_rqy</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/MisakaAzusa" target="_blank">zzc</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/Lance1ot" target="_blank">Lance1ot</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/pks-t/" target="_blank">Flower_pks</a><a class="author-info-links__name text-center" href="http://www.cnblogs.com/zzh666" target="_blank">ZZH</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s1.ax2x.com/2018/07/16/q1eLJ.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">默思·朸安</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">清北学堂2018DP&amp;图论精讲班 DP部分学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/培训/">培训</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/培训/清北学堂/">清北学堂</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>讲的挺基础的……不过还是有些地方不太明白</p>
<h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p> 给定一个数n，求将n划分成若干个正整数的方案数。</p>
<h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p> 数字三角形</p>
<h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p>最长不下降子序列</p>
<p><strong>以上太过于基础，不做深入讨论</strong></p>
<hr>
<h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>给定一个数n，求将n划分成若干个正整数的方案数。</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示用不超过$j$的数来组成$i$</p>
</li>
<li><p>状态转移<br>$i &lt; j \;\;\; dp[i][j]=dp[i][i]$<br>$i = j \;\;\; dp[i][j]=dp[i][j-1]+1$<br>$i &gt; j \;\;\; dp[i][j]=dp[i-j][j-1]+dp[i][j-1]$</p>
</li>
</ul>
<h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>一个人站在楼梯的第一级上，每次他可以向上走1~m级。有某些级楼梯是坏的，不能走上去。而且连续走了$k$次$m$级之后你接下来的一步只能走1级。问走到第N级的方案数。</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$在第$i$级台阶上，连续走了$j$次$m$级</p>
</li>
<li><p>状态转移<br>$ \sum_{j=1}^{m-1}dp[i+j][0]+= \sum_{l=0}^{k-1}dp[i][l]$(我自己按老师的意思写的方程我自己都看不懂……)<br>$dp[i+1][0]+=dp[i][k]$<br>$dp[i+m][l+1]+=f[i][l]\;(l\neq k)$</p>
</li>
</ul>
<h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><a href="http://codeforces.com/problemset/problem/467/C" target="_blank" rel="noopener">Codeforces 467C George and Job</a></p>
<p>给定一个长度为n的序列，从序列中选出k个不重叠且连续的m个数，要求和最大。<br>$1&lt;=m\times k&lt;=n&lt;=5000$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$sum[]$为前缀和，$dp[i][j]$选了$j$段，以$i$为结尾</p>
</li>
<li><p>状态转移<br>$dp[i][j]=max(dp[i-m][j-1]+sum[i]-sum[i-m],dp[i-1][j])$</p>
</li>
</ul>
<h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1354" target="_blank" rel="noopener">51nod 1354 选数字</a></p>
<p>当给定一个序列$a[0],a[1],a[2],…,a[n-1]$和一个整数$K$时，我们想找出有多少子序列里面的所有元素乘起来恰好等于$K$。<br>方案数对$10^9+7$取模。<br>$n &lt;= 1000,k &lt;= 10^8$</p>
<p><strong>不会，全程懵逼</strong></p>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>考试，估计要爆零……</p>
<p>嗯，60分，还不错——至少比想象中的高</p>
<h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/problemset.pdf" target="_blank" rel="noopener">考试题目</a></h3><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/sol.pdf" target="_blank" rel="noopener">官方题解</a></h3><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul>
<li><p>T1<br>只能说我太菜了，根本不会DP，爆搜+数据特判，40分滚粗</p>
</li>
<li><p>T2<br>我会最短路，怎么才20分？好吧，那30%$k=1$的测试点我承认我删边删错了。题目是双向边，我也是按双向边存的，结果删的时候只删了一条边……</p>
</li>
<li><p>T3<br>不会，讲了也不会 (｀＾´)ノ</p>
</li>
</ul>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>上午先讲了昨天没讲完的几道题，好吧，我太菜了，一道也不会 QAQ</p>
<hr>
<p>接Day1 例7</p>
<h3 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1294" target="_blank" rel="noopener">51nod 1294 修改数组</a></p>
<p>给出一个整数数组A，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？<br>$ n &lt; = 100000$</p>
<p>题解：</p>
<p>这道题思路很妙。</p>
<ul>
<li>$a[\;]$表示原序列<br>首先，我们将每个数$a[i]$减去它们对应的下标$i$，然后将$&lt; 0$的$a[i]$删去。因为每一个数都要是正整数，所以如果$a[i] &lt; i$，那它肯定不符合要求。<br>然后我们再在更改后的序列上找最长不下降子序列。最后用n-最长不下降子序列的长度就OK了</li>
</ul>
<h3 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h3><p>OpenJudge 6047 (找不到这道题 $\rm{Orz}$)</p>
<p>有一块矩形大蛋糕，长和宽分别是整数$w ,h$。现要将其切成$m$块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的$m$块小蛋糕中，最大的那块蛋糕的面积下限。<br>$w,h,m &lt;= 20$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k]$表示长宽为$i,j$的蛋糕切$k$刀的答案</p>
</li>
<li><p>边界条件<br>$dp[i][j][0]=i\times j$</p>
</li>
<li><p>状态转移<br>$dp[i][j][k]=min(max(dp[i][o][p],dp[i][j-o][k-1-p],dp[o][j][p],dp[i-o][j][k-p-1]))$</p>
</li>
</ul>
<h3 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h3><p><a href="http://codeforces.com/problemset/problem/407/B" target="_blank" rel="noopener">Codeforces 407B Long Path</a></p>
<p>有$n+1$个房间，一个人在1号房间。如果这是他第奇数次到当前房间（$i$号），那么他会去$pi\; (pi { &lt;= }i)$号房间，否则他会去$i+1$号房间。不管他去了那个房间，他的移动次数+1。<br>到达n+1号房间停止移动。问这时他的移动次数。答案对$1000000007$取模。<br>$n &lt;= 1000$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][0]$表示奇数次到达$i$号房间，$dp[i][1]$表示偶数次到达$i$号房间</p>
</li>
<li><p>状态转移<br>方程不如代码好表达(不想再写一个自己都看不懂的$\Sigma$了)，所以我就把代码给搬上来了 qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a[i]是原序列,dp数组如上所说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;i;j++)</span><br><span class="line">        dp[i][<span class="number">1</span>]+=(dp[j][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n][<span class="number">1</span>]+dp[n][<span class="number">0</span>])%mod;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>至此，基础(?)的DP就讲完了</p>
<hr>
<p>进入——<strong>区间DP</strong></p>
<h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1541" target="_blank" rel="noopener">NOIp2010 乌龟棋</a></p>
<p>在一行n个格子上进行游戏，每个格子有一个分数a[i]。你在1号格子，每次可以向前走1/2/3/4个格子，每种走法限制最多走b1/b2/b3/b4次。一次走法的分数是走过的格子的分数和。问走到n号格子的最大分数。<br>保证$b_1+2\times b_2+3\times b_3+4\times b_4=n-1$（恰好走完所有的次数）<br>$n&lt;=350,a[i]&lt;=100,bi&lt;=40$</p>
<p>题解：</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k][l]$表示各种类别的卡片分别还剩多少</p>
</li>
<li><p>状态转移<br>算了，本来想打方程的，懒了，丢代码吧，感受一下四维DP的魅力吧！ 233</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cards[<span class="number">1</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cards[<span class="number">2</span>];j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cards[<span class="number">3</span>];k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cards[<span class="number">4</span>];l++)&#123;</span><br><span class="line">          pos=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span>(i) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(j) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(k) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(l) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+mark[pos]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[cards[<span class="number">1</span>]][cards[<span class="number">2</span>]][cards[<span class="number">3</span>]][cards[<span class="number">4</span>]]+mark[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P2679" target="_blank" rel="noopener">NOIp2015 子串</a></p>
<p>有两个仅包含小写英文字母的字符串$A$和$B$。现在要从字符串$A$中取出$k$个互不重叠的非空子串,然后把这$k$个子串按照其在字符串$A$中出现的顺序依次连接起来得到一个新的字符串,请问有多少种方案可以使得这个新串与字符串$B$相等？注意：子串取出的位置不同也认为是不同的方案。输出方案数%1000000007<br>$length(A) &lt;= 1000,1 &lt;= k &lt;= length(B) &lt;= 200$</p>
<p>题解：</p>
<p>这道挺毒的，卡空间，必须用滚动数组优化</p>
<ul>
<li><p>定义状态<br>$dp[i][j][k][0/1]$表示字符串$A$到$i$，字符串$B$到$j$，取出了$k$个字符串，第$i$个字符选不选</p>
</li>
<li><p>边界条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态转移<br>以后有代码就直接丢代码了，懒了懒了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++,pos^=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=k;o++)&#123;</span><br><span class="line">          dp[pos][j][o][<span class="number">0</span>]=dp[pos^<span class="number">1</span>][j][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j][o][<span class="number">0</span>]%mod;</span><br><span class="line">          <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            dp[pos][j][o][<span class="number">1</span>]=dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">0</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">1</span>]%mod;</span><br><span class="line">          <span class="keyword">else</span> dp[pos][j][o][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n&amp;<span class="number">1</span>][m][k][<span class="number">0</span>]+dp[n&amp;<span class="number">1</span>][m][k][<span class="number">1</span>])%mod;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">NOI1995 石子合并</a></p>
<p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。<br>$n { &lt;= } 100$</p>
<p>题解：</p>
<p>这个题目要求最小代价，除了最小代价，Luogu还要求求出最大代价，不过实现的方法一模一样</p>
<p>很经典的一道题目，区间DP入门必刷题</p>
<p>首先要破环为链+前缀和处理</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示合并区间$[i,j]$的最小代价</p>
</li>
<li><p>状态转移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+n;j++)&#123;</span><br><span class="line">	  dp2[i][j]=<span class="number">214748364</span>;</span><br><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">	  	dp2[i][j]=min(dp2[i][j],dp2[i][k]+dp2[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1040" target="_blank" rel="noopener">NOIp2003 加分二叉树</a></p>
<p>设一个$n$个节点的二叉树$tree$的中序遍历为$(1,2,3,…,n)$，其中数字$1,2,3,…,n$为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为$di$,$tree$及它的每个子树都有一个加分，任一棵子树$subtree$（也包含$tree$）的加分计算方法如下：<br>$subtree$的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。<br>若某个子树为空，规定其加分为$1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>试求一棵符合中序遍历为$(1,2,3,…,n)$且加分最高的二叉树$tree$。要求输出$tree$的最高加分<br>$n {&lt;=} 30$</p>
<p>题解：</p>
<p>emmmm，第三次碰到这题了，到现在还记得当时爆零的屈辱</p>
<ul>
<li><p>定义状态<br>$dp[i][j]$表示区间$[i,j]$的最大得分</p>
</li>
<li><p>边界条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	dp[i][i]=num[i]; <span class="comment">//num[ ]为原序列</span></span><br><span class="line">	dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态转移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">	  <span class="keyword">if</span>(dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k]&gt;dp[i][j])&#123;</span><br><span class="line">			  dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k];</span><br><span class="line">			  tree[i][j]=k; <span class="comment">//用于输出</span></span><br><span class="line">	  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出<br>这道题输出也是个坑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;tree[l][r]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	print(l,tree[l][r]<span class="number">-1</span>);</span><br><span class="line">	print(tree[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="例5-1"><a href="#例5-1" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">SCOI2003 字符串折叠</a></p>
<p>折叠的定义如下：</p>
<p>一个字符串可以看成它自身的折叠。记作$S = S$<br>$X(S)$是$X(X&gt;1)$个$S$连接在一起的串的折叠。记作$X(S) = SSSS…S(X$个$S)$。</p>
<p>如果$A = A’,B = B’$，则$AB = A’B’$例如，因为$3(A) = AAA, 2(B) = BB$，所以$3(A)C2(B) = AAACBB$，而$2(3(A)C)2(B) = AAACAAACBB$</p>
<p>给一个字符串，求它的最短折叠。例如$AAAAAAAAAABABABCCD$的最短折叠为：$9(A)3(AB)CCD$。</p>
<p><strong>日常懵逼，不会</strong></p>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MorsLin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/07/15/清北学堂2018DP-图论精讲班-DP学习笔记/">http://yoursite.com/2018/07/15/清北学堂2018DP-图论精讲班-DP学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">默思·朸安</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/学习笔记/">学习笔记</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/07/13/Goodbye/"><span>Goodbye</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 By MorsLin</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><p id="hitokoto">:D 获取中...</p><script src="https://v1.hitokoto.cn/?encode=js&select=%23hitokoto" defer></script></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>