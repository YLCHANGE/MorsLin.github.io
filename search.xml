<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>网络流24题 飞行员配对方案问题</title>
      <link href="/2018/08/08/wll24t-fxypdwt/"/>
      <url>/2018/08/08/wll24t-fxypdwt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>虽然这题是“网络流24题”，但我匈牙利<del>Van♂</del>完全不虚，还比$dinic$好写不少（不过就是慢一些）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>t,nex;</span><br><span class="line">&#125;e[<span class="number">10001</span>*<span class="number">2</span>]; <span class="keyword">int</span> head[<span class="number">101</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">101</span>];<span class="keyword">int</span> lin[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nex)</span><br><span class="line">      <span class="keyword">if</span>(!vis[e[i].t])&#123;</span><br><span class="line">          vis[e[i].t]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(!lin[e[i].t]||find(lin[e[i].t]))&#123;</span><br><span class="line">              lin[e[i].t]=x; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m; m=read(),n=read();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>&amp;&amp;y==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        add(x,y); add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lin[i]&gt;<span class="number">0</span>&amp;&amp;lin[i]&lt;=m&amp;&amp;ans)&#123;</span><br><span class="line">            ans--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,lin[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流24题 魔术球问题</title>
      <link href="/2018/08/08/wll24t-msqwt/"/>
      <url>/2018/08/08/wll24t-msqwt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2765" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>又是一个神奇的建图题，建图$Van$♂全不会啊</p><p>大体就是我们一个一个的把球放进来，每放进来一个，我们就求出当前的最小路径覆盖数(当前顶点数-最大流)，直到最小路径覆盖数${&gt;}$柱子数。此时的球的编号$-1$就是第一问的答案。第二问就是求每一条路径，顺着推下来就好了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">20010</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">e[++tot].t=y;</span><br><span class="line">e[tot].len=z;</span><br><span class="line">e[tot].nex=head[x];</span><br><span class="line">head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,t=<span class="number">20000</span>,vis[<span class="number">20010</span>],pre[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(s); vis[s]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> k=q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(vis[to]||!e[i].len) <span class="keyword">continue</span>;</span><br><span class="line">q.push(to); vis[to]=vis[k]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest=<span class="number">0</span>,fl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(vis[to]==vis[now]+<span class="number">1</span>&amp;&amp;(fl=dfs(to,min(flow,e[i].len))))&#123;</span><br><span class="line">e[i].len-=fl, e[i^<span class="number">1</span>].len+=fl, rest+=fl;</span><br><span class="line"><span class="keyword">if</span>(rest==flow) <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rest&lt;flow) vis[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs()) ans+=dfs(s,<span class="number">2147483647</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> jl[<span class="number">20010</span>]; <span class="keyword">int</span> next[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),cnt=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt&lt;=n)&#123;</span><br><span class="line">num++; cnt++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sqrt</span>(i+num)==(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(i+num))</span><br><span class="line">add(i,num+<span class="number">10000</span>,<span class="number">1</span>),add(num+<span class="number">10000</span>,i,<span class="number">0</span>);</span><br><span class="line">add(s,num,<span class="number">1</span>); add(num,s,<span class="number">0</span>);</span><br><span class="line">add(num+<span class="number">10000</span>,t,<span class="number">1</span>); add(t,num+<span class="number">10000</span>,<span class="number">0</span>);</span><br><span class="line">cnt-=dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,--num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=e[j].nex)&#123;</span><br><span class="line"><span class="keyword">if</span>(!e[j].len)&#123;</span><br><span class="line">next[i]=e[j].t<span class="number">-10000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(jl[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> x=i;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">-10000</span>)&#123;</span><br><span class="line">jl[x]=<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">"%d "</span>,x);</span><br><span class="line">x=next[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流24题 最长不下降子序列问题</title>
      <link href="/2018/08/08/wll24t-zcbxjzxywt/"/>
      <url>/2018/08/08/wll24t-zcbxjzxywt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2766" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>这个建图啊，十分巧妙，我是真没看出来（我太蒟了）</p><p>首先要先跑一遍最长不下降子序列的$O(n^2)$解法，预处理出以$i$结尾的最长不下降子序列的长度$dp[i]$，然后找出最大的$dp[i]$，记为$cnt$，输出$cnt$，第一问就结束了。</p><p>从源点向长度为$1$的点连一条容量为$1$的边，长度为$cnt$的点向汇点连一条容量为$1$的边。因为每个点只能用一次，所以我们还要把一个点拆成两个，在它们之间连一条容量为$1$的边。之后$n^2$枚举每两个点，若两个点$i,j$满足$j{&lt;}i$且$dp[i]=dp[j]+1$，则在$i,j$之间连一条容量为$1$的边。建好图后跑一边最大流，就是第二问的答案。</p><p>第三问就好办了，将源点向$1$连的边的容量改为$\rm{INF}$，$1$和$1$被拆之后的点$1’$之间的容量也改为$\rm{INF}$。同理，$n$和$n’$之间的边、$n’$和汇点之间的边（如果存在的话）容量也要改为$\rm{INF}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">20010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">10010</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">e[++tot].t=y;</span><br><span class="line">e[tot].len=z;</span><br><span class="line">e[tot].nex=head[x];</span><br><span class="line">head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">10010</span>],s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    dis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">            <span class="keyword">if</span>(dis[to]||!e[i].len) <span class="keyword">continue</span>;</span><br><span class="line">            dis[to]=dis[k]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest=<span class="number">0</span>,fl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(dis[to]==dis[now]+<span class="number">1</span>&amp;&amp;(fl=dfs(to,min(e[i].len,flow))))&#123;</span><br><span class="line">            e[i].len-=fl, e[i^<span class="number">1</span>].len+=fl, rest+=fl;</span><br><span class="line">            <span class="keyword">if</span>(rest==flow) <span class="keyword">return</span> rest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest&lt;flow) dis[now]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bfs()) ans+=dfs(s,INF);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">510</span>],dp[<span class="number">510</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(); t=(n&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read(),dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">  <span class="keyword">if</span>(a[j]&gt;=a[i]) dp[j]=max(dp[j],dp[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt=max(cnt,dp[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,n,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">add(i,i+n,<span class="number">1</span>); add(i+n,i,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[i]==cnt) add(i+n,t,<span class="number">1</span>),add(t,i+n,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[i]==<span class="number">1</span>) add(s,i,<span class="number">1</span>),add(i,s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>==dp[i])</span><br><span class="line">  add(j+n,i,<span class="number">1</span>),add(i,n+j,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dinic());</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>+n,INF),add(n+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">add(n,n&lt;&lt;<span class="number">1</span>,INF),add(n&lt;&lt;<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>]==<span class="number">1</span>) add(s,<span class="number">1</span>,INF), add(<span class="number">1</span>,s,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[n]==cnt) add(n&lt;&lt;<span class="number">1</span>,t,INF), add(t,n&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dinic());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDOI2009 HH的项链</title>
      <link href="/2018/08/08/sdoi2009%20hhdxl/"/>
      <url>/2018/08/08/sdoi2009%20hhdxl/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1972" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fu2e66jzukg308c04okh0.gif" alt=""></p><p>这题是一道很好的<del>莫队</del>树状数组题目。</p><p>首先，我们需要离线操作，把询问全存下来，然后按询问的右端点排序</p><p>排好序后，我们可以更改树状数组维护的区间，同时记录每一个元素最后出现的位置，因为我们是从左向右来回答每个询问，所以在右面的元素肯定比在左面的相同元素作用更大一些，所以我们在相同元素中只保存在我们当前维护的区间内且最靠右的一个就好了。</p><p>之后就可以用前缀和来处理答案了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb i&amp;-i</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1000010</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lb)</span><br><span class="line">  tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=lb)</span><br><span class="line">  anss+=tree[i];</span><br><span class="line"><span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,pos;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zzz x,zzz y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.r!=y.r) <span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500010</span>],last[<span class="number">1000010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">int</span> m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">  q[i].l=read(),q[i].r=read(),q[i].pos=i;</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;q[j].r)&#123;  <span class="comment">//i相当于一个指针，表示我们当前处理到哪</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(last[a[i]])&#123;</span><br><span class="line">add(last[a[i]],<span class="number">-1</span>); add(i,<span class="number">1</span>); <span class="comment">//及时更改</span></span><br><span class="line">last[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">add(i,<span class="number">1</span>); last[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[q[j].pos]=sum(q[j].r)-sum(q[j].l<span class="number">-1</span>); <span class="comment">//处理询问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HNOI2008 玩具装箱TOY</title>
      <link href="/2018/08/05/hnoi2008-wjzx/"/>
      <url>/2018/08/05/hnoi2008-wjzx/</url>
      <content type="html"><![CDATA[<p>$rqy\; tql$ （日常%$rqy$）</p><hr><p><a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>若果我们在输入时将所有的$C_i$和$L+1$，原公式可以化为$(S-L)^2$</p><p>用$f_i$表示前$i$个数的最小花费<br>$f_i=min(f_j+(S_i-S_j-L)^2)\;\; 1 {&lt;=}j{&lt;=}i-1$<br>$f_i=min(f_j+(S_i-L)^2-2(S_i-L)S_j+S_j^2)$<br>$\;\;\;\;=(S_i-L)^2+min(y_j-k_ix_j)$<br>$y_j=f_j+S_j^2,k_i=2(S_i-L),x_j=S_j$</p><p>所以我们就可用斜率优化来$A$掉这道题了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll dp[<span class="number">50010</span>],sum[<span class="number">50010</span>],l;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">x</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> sum[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">y</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> dp[i]+sum[i]*sum[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">k</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> <span class="number">2L</span>L*(sum[i]-l); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y(a)-y(c))*(x(b)-x(c))-(y(b)-y(c))*(x(a)-x(c))&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll q[<span class="number">100010</span>],h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),l=read()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+read()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;y(q[h])-k(i)*x(q[h])&gt;=y(q[h+<span class="number">1</span>])-k(i)*x(q[h+<span class="number">1</span>])) h++;</span><br><span class="line">        dp[i]=(sum[i]-l)*(sum[i]-l)+y(q[h])-k(i)*x(q[h]);</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;check(q[t<span class="number">-1</span>],q[t],i)) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOI2005 瑰丽华尔兹</title>
      <link href="/2018/08/04/noi2005-glhez/"/>
      <url>/2018/08/04/noi2005-glhez/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2254" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>在这先膜一波$\mathcal{rqy}$，$rqy\; tql$！</p><hr><p>首先应该能想到正解是$DP$。我们可以枚举每个时间点来列出转移方程。<br>用$f[i][x][y]$表示在$i$这个时间点走到$(x,y)$这个位置的最长路径，我们以向下走为例，则：<br>$dp[i][x][y]=\max(dp[i-1][x][y],dp[i-1][x-1][y]+1)$<br>期望得分$50$分</p><p>但不要忘了，题目中的时间是按段给你的，所以我们没有必要去枚举每个时间点，直接枚举时间段就好了。<br>$dp[i][x][y]$表示在第$i$个时间点结束时走到了$(x,y)$这个位置的最长路径，我们还是以向下走为例：<br>$dp[i][x][y]=\max(dp[i-1][t][y]+x-t)=\max(dp[i][t][y]-t)+x$，$len$表示这次时间段的长度,$t\in [x-len,x]$。<br>这时，我们就可以用单调队列来优化$max(dp[i][t][y]-t)$，时间复杂度$O(nmk)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> mapp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">210</span>][<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,pos;</span><br><span class="line">&#125;q[<span class="number">100010</span>]; <span class="keyword">int</span> h,t;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, <span class="comment">//控制向哪个方向滑动</span></span><br><span class="line">    dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=-inf,n,m;</span><br><span class="line"><span class="comment">// ==================算法主体==============</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> tim,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;y&lt;=m)&#123;  <span class="comment">//判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(mapp[x][y]) h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">//如果有障碍,则从之前的状态无法到达 ,清空队列,重新开始</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 入队,成为候选答案</span></span><br><span class="line">            <span class="keyword">if</span>(dp[tim<span class="number">-1</span>][x][y]!=-inf)&#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;dp[tim<span class="number">-1</span>][x][y]-now&gt;=q[t].st) t--;</span><br><span class="line">                q[++t].st=dp[tim<span class="number">-1</span>][x][y]-now;</span><br><span class="line">                q[t].pos=now; <span class="comment">//记录下标,判断是否超出长度限制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;now-q[h].pos&gt;len) h++; <span class="comment">//如果当前的队头超出长度限制 ,则出队</span></span><br><span class="line">        <span class="keyword">if</span>(h&lt;=t) dp[tim][x][y]=q[h].st+now; <span class="comment">// 单调队列,队头即为最大值,直接加上即可</span></span><br><span class="line">        <span class="keyword">else</span> dp[tim][x][y]=-inf; <span class="comment">//无法到达则置为 -inf</span></span><br><span class="line">        ans=max(ans,dp[tim][x][y]); <span class="comment">//ans记录最大值</span></span><br><span class="line">        x+=dx[d], y+=dy[d]; ++now;  <span class="comment">//继续滑动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read(); <span class="keyword">int</span> sx=read(),sy=read(),num=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(getchar()==<span class="string">'x'</span>) mapp[i][j]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">128</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[<span class="number">0</span>][i][j]=-inf;</span><br><span class="line">    dp[<span class="number">0</span>][sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> si=read(),ti=read(),dic=read();</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) f(i,n,j,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) f(i,<span class="number">1</span>,j,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">3</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f(i,j,m,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">4</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f(i,j,<span class="number">1</span>,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以如果遇到类似的$DP$方程，可以考虑单调队列优化</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOI2015 软件包管理器</title>
      <link href="/2018/08/03/noi2015-rjbglq/"/>
      <url>/2018/08/03/noi2015-rjbglq/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2146" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>树剖裸题……就是把区间修改变为了区间覆盖。</p><p>不过，我在处理询问的时候相当暴力，每次询问我都查了三遍……有几个点是卡过去的……它要卡卡常我说不定就$\tt{T}$了……</p><p>Luogo此题最优解倒数第12……BZOJ直接$T$飞……</p><p>具体看代码吧……</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,nex;</span><br><span class="line">&#125;e[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">100010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>],son[<span class="number">100010</span>],size[<span class="number">100010</span>],deth[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[now]=fa, deth[now]=deth[fa]+<span class="number">1</span>, size[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(to,now);</span><br><span class="line">        size[now]+=size[to];</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;size[son[now]]) son[now]=to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn,top[<span class="number">100010</span>],pos[<span class="number">100010</span>],rank[<span class="number">100010</span>],a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">    top[now]=topp, pos[now]=++dfn, rank[dfn]=a[now];</span><br><span class="line">    <span class="keyword">if</span>(!son[now]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[now],topp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(to!=f[now]&amp;&amp;to!=son[now]) dfs2(to,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>],tag[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=rank[l]; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123; <span class="comment">//下传懒标记也要注意</span></span><br><span class="line">    <span class="keyword">if</span>(tag[p]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    tag[ls]=tag[p], tag[rs]=tag[p];</span><br><span class="line">    tree[ls]=(mid-l+<span class="number">1</span>)*tag[p];</span><br><span class="line">    tree[rs]=(r-mid)*tag[p];</span><br><span class="line">    tag[p]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tree[p]=(r-l+<span class="number">1</span>)*k; tag[p]=k; <span class="comment">//线段树区间覆盖</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        update(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x],k);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x]);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(); <span class="built_in">memset</span>(tag,<span class="number">-1</span>,<span class="keyword">sizeof</span>(tag)); <span class="comment">//因为有"0"和"1"两种操作,初值赋为"-1"</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read();</span><br><span class="line">        add(x+<span class="number">1</span>,i), add(i,x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); dfs2(<span class="number">1</span>,<span class="number">1</span>); build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123; <span class="comment">//这是最暴力的部分……</span></span><br><span class="line">        <span class="built_in">string</span> s; <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'i'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k1=sum(<span class="number">1</span>,x); upd(<span class="number">1</span>,x,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> k2=sum(<span class="number">1</span>,x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k2-k1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k1=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">            update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> k2=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k1-k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树剖 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树链剖分~~不详细~~讲解</title>
      <link href="/2018/08/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2018/08/02/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      <content type="html"><![CDATA[<p>前置技能：线段树、DFS</p><p>当我第一次听到<strong>“树链剖分”</strong>这个算法的时候，感觉它一定很高大上。现在看来，它确实很高大上，不过也十分的<strong>暴力</strong>(个人认为，不喜勿喷)</p><hr><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><blockquote><p>　树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。<br>　————某度百科　</p></blockquote><p>百度百科对什么是树剖已经说的很明白了，接下来我们再了解一下其他的概念。</p><ul><li>重儿子：对于每一个非叶子节点，它的儿子中子树节点最多的儿子</li><li>轻儿子：对于每一个非叶子节点，它的除重儿子以外的儿子</li><li>重边：父亲节点连向重儿子的边</li><li>轻边：父亲节点连向轻儿子的边</li><li>重链：由多条重边连成的一条树链</li><li>轻链：由多条轻边连成的一条树链</li></ul><p><img src="http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_c83d70cf3bc79f3d3adc2d8cb9a1cd11728b2949.jpg" alt=""></p><p>在这张图片中，带红点的就是轻儿子，其余为重儿子；加粗的边为重边，其余的为轻边；$1-&gt;14,\;2-&gt;11,\;3-&gt;7 $的路径为重链，其余的为轻链。</p><p>前面某度已经说了，树链剖分要通过轻重边剖分将树分为多条链，那么它是怎么找出轻重边，又是怎么剖分的的呢？不要着急，我们接着讲</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>先来说一说我们需要求哪些东西</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$f[i]$</td><td style="text-align:center">结点$i$的父亲</td></tr><tr><td style="text-align:center">$son[i]$</td><td style="text-align:center">结点$i$的重儿子(如果有$i$有两个及以上的重儿子，则随便指定一个)</td></tr><tr><td style="text-align:center">$size[i]$</td><td style="text-align:center">结点$i$的子树大小</td></tr><tr><td style="text-align:center">$deth[i]$</td><td style="text-align:center">结点$i$的深度</td></tr><tr><td style="text-align:center">$top[i]$</td><td style="text-align:center">结点$i$所在的重链的顶端(若$i$为轻儿子,则$top[i]$等于它本身)</td></tr><tr><td style="text-align:center">$pos[i]$</td><td style="text-align:center">结点$i$的新编号(可以理解为点$i$对应的$rank$数组的下标)</td></tr><tr><td style="text-align:center">$rank[i]$</td><td style="text-align:center">编号$i$对应的树上的结点的点权</td></tr></tbody></table></div><p>其中，前四个变量可以通过一次$DFS$求出，其余三个可以在第一次$DFS$的基础上再通过一次$DFS$求出</p><p>代码是这样滴：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[now]=fa, deth[now]=deth[fa]+<span class="number">1</span>, size[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(to,now);</span><br><span class="line">size[now]+=size[to];</span><br><span class="line"><span class="keyword">if</span>(size[to]&gt;size[son[now]]) son[now]=to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">top[now]=topp, pos[now]=++dfn, rank[dfn]=a[now];</span><br><span class="line"><span class="comment">//a[i]表示结点i的点权</span></span><br><span class="line"><span class="keyword">if</span>(!son[now]) <span class="keyword">return</span> ;</span><br><span class="line">dfs2(son[now],topp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(to!=son[now]&amp;&amp;to!=f[now]) dfs2(to,to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们进行第二次$DFS$的时候，我们是优先搜索重儿子，这是为了保证重链在$rank$数组里的连续性，除了重链，一颗子树的编号在$rank$数组里也是连续的。</p><p>为什么要这么做？接下来你就知道了。</p><p>到此，我们的树链剖分就讲完了。可是，现在我们求出了这么多东西，它们能干什么呢？</p><p>还记得一开始某度百科上说过可以“<em>通过数据结构(树状数组、SBT、SPLAY、线段树等)来维护每一条链</em>”吗？没错，在求出了这么多东西后，我们就可以用我们所熟悉的数据结构来瞎搞这颗树了（大雾</p><p>为了方便理解+应用广泛，我们以线段树为例来讲一下树链的维护(<del>其实是因为博主太蒟，只会线段树</del>)</p><p>假设题目让我们进行以下操作：</p><ol><li>将树从x到y结点最短路径上所有节点的值都加上z</li><li>求树从x到y结点最短路径上所有节点的值之和</li><li>将以x为根节点的子树内所有节点值都加上z</li><li>求以x为根节点的子树内所有节点值之和</li></ol><p>上文我们说过：重链在$rank$数组里是连续的，一颗子树在$rank$数组里也是连续的。所以我们可以用线段树通过多次区间修改和多次区间查询来搞定这四个操作。</p><p>首先是线段树：</p><p>其实线段树的一切都没什么变化，该怎么打还是怎么打，只不过要维护的数组变成我们剖出来的$rank$数组</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=rank[l]; <span class="keyword">return</span> ; <span class="comment">//要注意这里的数组是rank</span></span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//下传懒标记(我太蒟了,不会标记永久化)</span></span><br><span class="line">    tag[ls]+=tag[p]; tag[rs]+=tag[p];</span><br><span class="line">    tree[ls]+=(mid-l+<span class="number">1</span>)*tag[p];</span><br><span class="line">    tree[rs]+=(r-mid)*tag[p];</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,ll k)</span></span>&#123; <span class="comment">//区间修改</span></span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tag[p]+=k; tree[p]+=(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123; <span class="comment">//区间查询</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这棵线段树该怎么用呢？</p><p>如果点$x$和$y$不在一条重链上，就让它们一直跳，直到跳到一条重链上。为了防止越跳越远，我们让深度更深的先跳到另一条链上。在跳的时候，因为重链在数组中是<strong>连续</strong>的，我们就可以用线段树进行<strong>区间更改/查询</strong>来处理这一部分，通过多次区间操作，就能够实现这操作1、2。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll k)</span></span>&#123;  <span class="comment">//将树从x到y结点最短路径上所有节点的值都加上z</span></span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123; <span class="comment">//如果不在一条重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        update(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x],k);</span><br><span class="line">        x=f[top[x]]; <span class="comment">//让更深的跳上来，跳到另一条链上，顺便加上区间修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在一条链上</span></span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y],k); <span class="comment">//则处理一下两节点之间的区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//查询操作和修改是一样的……</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x]);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于操作3、4，则更为简单。因为子树在数组中是连续的，我们又知道每棵子树的大小，所以直接一波线段树就可以了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>,y);  <span class="comment">//将以x为根节点的子树内所有节点值都加上z</span></span><br><span class="line">query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>)； <span class="comment">//求以x为根节点的子树内所有节点值之和</span></span><br></pre></td></tr></table></figure></p><p>到此，树剖就真的讲完了，不知众看官看懂了多少……</p><h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><ul><li><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">Luogu【模板】树链剖分</a> (也就是我们讲的例题)</li><li><a href="https://www.luogu.org/problemnew/show/P3178" target="_blank" rel="noopener">HAOI2015 树上操作</a></li><li><a href="https://www.luogu.org/problemnew/show/P2146" target="_blank" rel="noopener">NOI2015 软件包管理器</a></li></ul><p>以上这些都是一些裸题。树剖本身不难理解，但因为代码较长，比较容易写错……又全是递归，不好调试……所以要多练……</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/George1994/p/7821357.html" target="_blank" rel="noopener">树链剖分原理和实现</a> —— $banananana$<br><a href="http://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">树链剖分详解</a>—— $ChinHhh$<br><a href="https://www.luogu.org/blog/communist/shu-lian-pou-fen-yang-xie" target="_blank" rel="noopener">树链剖分详解</a>—— $communist$</p>]]></content>
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树剖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JLOI2011 飞行路线</title>
      <link href="/2018/08/01/jloi2011%20fxlx/"/>
      <url>/2018/08/01/jloi2011%20fxlx/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4568" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>分层图$SPFA$……听起来好高级的样子……嗯，所以我选分层图$\rm{dijkstra}$</p><p><img src="http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_QQ%e6%88%aa%e5%9b%be20180801193256.png" alt=""></p><p>这题好像是会卡$SPFA$，要加一个玄学$SLF$优化才可以……</p><p>所以还是用堆优化$\rm{dijkstra}$吧，多好<img src="http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_QQ%e5%9b%be%e7%89%8720180623180015.png" alt=""></p><p>以上全是瞎扯，但卡$SPFA$是<strong>真的</strong></p><hr><p>用$\tt{dis[i][j]}$表示免费乘坐了$i$次到达点$j$的最小代价，跑最短路的时候顺推下来就可以了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">50010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">10010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].len=z;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">21</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,cnt,pos;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> hhh &amp;y) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; y.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;hhh&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span>(dis)); dis[<span class="number">0</span>][s]=<span class="number">0</span>;</span><br><span class="line">    q.push(hhh&#123;<span class="number">0</span>,<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        hhh k=q.top(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(dis[k.cnt][k.pos]!=k.v) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k.pos];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">            <span class="keyword">if</span>(dis[k.cnt][to]&gt;dis[k.cnt][k.pos]+e[i].len)&#123;</span><br><span class="line">                dis[k.cnt][to]=dis[k.cnt][k.pos]+e[i].len;</span><br><span class="line">                q.push(hhh&#123;dis[k.cnt][to],k.cnt,to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k.cnt+<span class="number">1</span>&lt;=num&amp;&amp;dis[k.cnt][k.pos]&lt;dis[k.cnt+<span class="number">1</span>][to])&#123;</span><br><span class="line">                dis[k.cnt+<span class="number">1</span>][to]=dis[k.cnt][k.pos];</span><br><span class="line">                q.push(hhh&#123;dis[k.cnt+<span class="number">1</span>][to],k.cnt+<span class="number">1</span>,to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),k=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read(),z=read();</span><br><span class="line">        add(x,y,z), add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>,k);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[k][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\;Round\;500\;(Div. 2)$</title>
      <link href="/2018/08/01/codeforces-round500-div-2/"/>
      <url>/2018/08/01/codeforces-round500-div-2/</url>
      <content type="html"><![CDATA[<h2 id="tt-A-Piles-With-Stones"><a href="#tt-A-Piles-With-Stones" class="headerlink" title="$\tt{A. Piles\;With\;Stones}$"></a>$\tt{A. Piles\;With\;Stones}$</h2><p>水题，直接输入两个数组，比较它们两个和的大小，然后输出”Yes”或”No”</p><h2 id="rm-B-And"><a href="#rm-B-And" class="headerlink" title="$\rm{B. And}$"></a>$\rm{B. And}$</h2><p>这题还算简单，因为当一个数$\And x$后，无论再怎么$\And x$结果都不会变了，所以这道题的答案就只有$-1/0/1/2$四种，暴力枚举每一个数判断就好<del>（结果我因为一个小错误，FST了）</del></p><h2 id="C-Photo-of-The-Sky"><a href="#C-Photo-of-The-Sky" class="headerlink" title="$C.\;Photo\;of\;The\;Sky$"></a>$C.\;Photo\;of\;The\;Sky$</h2><p>假设输入的数组为$a[2n]$，为了方便，我们把要分成的两个可重集叫做$X$和$Y$</p><p>首先肯定要$sort$一下，使得数组有序，方便操作（下文提到的数组都是有序的）</p><p>接下来就是分类讨论了：</p><ul><li><p>第一种情况：数组a的最大值和最小值都在$X$里。那么$X$的极差就是$a[2n]-a[1]$，接下来我们要使$Y$的极差尽量小，我们就需要枚举一下每个元素$a[i]$，因为集合里要有$n$个元素，所以对于每个$a[i]$，能使$Y$的极差最小的方式就是将$a[i]$~$a[i+n-1]$全部放到$Y$里，所以$Y$的极差就是$\min(a[i+n-1]-a[i])\;i\in [2,n+1]$</p><p>答案为 $\min((a[i+n-1]-a[i])\cdot(a[2n]-a[1]))\;i\in [2,n+1]$</p></li></ul><ul><li><p>第二种情况：最小值（$a[1]$）和最大值（$a[2n]$）分别在$X$和$Y$里。这样我们就要使$X$的最大值尽量小，$Y$的最小值尽量大，那么$X$的极差最小就为$a[n]-a[1]$，$Y$的极差最小为$a[2n]-a[n+1]$</p><p>答案为 $(a[n]-a[1])\cdot (a[2n]-a[n+1])$</p></li></ul><p>最终的答案从这两种情况中取一个最小值就好了。</p><p>时间复杂度$O(nlogn)$（也就是排序的复杂度）</p><p>最后提醒一句：<strong>别忘了开$\mathfrak{long\;long}$</strong></p><p>上一份代码吧……</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">ll a[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">1</span>;i++) a[i]=read();</span><br><span class="line">sort(a+<span class="number">1</span>,a+(n&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">ans=(a[n]-a[<span class="number">1</span>])*(a[n&lt;&lt;<span class="number">1</span>]-a[n+<span class="number">1</span>]); <span class="comment">//第二种情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)  <span class="comment">//第一种情况</span></span><br><span class="line">ans=min((a[n&lt;&lt;<span class="number">1</span>]-a[<span class="number">1</span>])*(a[i+n<span class="number">-1</span>]-a[i]),ans);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>然后后面的题就都不会了，$CF$止步于此……</p><p>我果然还是太菜了……</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2016提高组 蚯蚓</title>
      <link href="/2018/07/31/noip2016-qy/"/>
      <url>/2018/07/31/noip2016-qy/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2827" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>刚看到这道题：这题直接用堆+模拟不就可以了(并没有认真算时间复杂度)</p><p>于是用priority_queue水到了85分…… (STL大法好)</p><p>天真的我还以为是常数问题，于是疯狂卡常……<del>(我是ZZ)</del></p><p>直到我下了组数据，结果它跑了……跑了……<strong>10s</strong> <del>(这叫我怎么卡常)</del></p><p>OK，闲聊到次结束，接下来说正解</p><hr><p>其实这道题并不需要用堆，因为我们可以蚯蚓其实是满足单调性的，因为后切的蚯蚓一定要比先切的短，所以堆是不必要的，我们只用三个队列，分别记录没被切的蚯蚓、被切了的短的蚯蚓、被切了的长的蚯蚓，每次把三个队列的队头取出来比较，切掉最长的，再分别入队。</p><p>时间复杂度：$O(n+m)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"><span class="keyword">int</span> qy[<span class="number">100010</span>],cut1[<span class="number">10000010</span>],cut2[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">1</span>,ta,h1=<span class="number">1</span>,t1,h2=<span class="number">1</span>,t2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("hhh.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("hhh.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),q=read(),u=read(),v=read(),t=read();</span><br><span class="line">    <span class="built_in">memset</span>(cut1,<span class="number">-127</span>,<span class="keyword">sizeof</span>(cut1));</span><br><span class="line">    <span class="built_in">memset</span>(cut2,<span class="number">-127</span>,<span class="keyword">sizeof</span>(cut2));</span><br><span class="line">    <span class="built_in">memset</span>(qy,<span class="number">-127</span>,<span class="keyword">sizeof</span>(qy));</span><br><span class="line">    p=(<span class="keyword">double</span>)u/(<span class="keyword">double</span>)v; ta=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) qy[i]=read();</span><br><span class="line">    sort(qy+<span class="number">1</span>,qy+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">-2147483647</span>; <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qy[h]&gt;=cut1[h1]&amp;&amp;qy[h]&gt;=cut2[h2]&amp;&amp;h&lt;=ta)&#123;</span><br><span class="line">    maxn=qy[h]+(i<span class="number">-1</span>)*q; h++; flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf("%d %d\n",h,ta);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut1[h1]&gt;=cut2[h2]&amp;&amp;cut1[h1]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h1&lt;=t1)&#123;</span><br><span class="line">            maxn=cut1[h1]+(i<span class="number">-1</span>)*q; h1++; flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",h1,t1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut2[h2]&gt;=cut1[h1]&amp;&amp;cut2[h2]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h2&lt;=t2)&#123;</span><br><span class="line">            maxn=cut2[h2]+(i<span class="number">-1</span>)*q; h2++; flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",h2,t2);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("%d %d %d\n",qy[h],cut1[h1],cut2[h2]);</span></span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>,maxn);</span><br><span class="line">        <span class="keyword">int</span> k=maxn*p;</span><br><span class="line">        cut1[++t1]=k-i*q; cut2[++t2]=maxn-k-i*q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">-2147483647</span>; <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qy[h]&gt;=cut1[h1]&amp;&amp;qy[h]&gt;=cut2[h2]&amp;&amp;h&lt;=ta)&#123;</span><br><span class="line">    maxn=qy[h]+m*q; h++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut1[h1]&gt;=cut2[h2]&amp;&amp;cut1[h1]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h1&lt;=t1)&#123;</span><br><span class="line">            maxn=cut1[h1]+m*q; h1++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut2[h2]&gt;=cut1[h1]&amp;&amp;cut2[h2]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h2&lt;=t2)&#123;</span><br><span class="line">            maxn=cut2[h2]+m*q; h2++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d "</span>,maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2011提高组 聪明的质监员</title>
      <link href="/2018/07/30/noip2011-cmdzjy/"/>
      <url>/2018/07/30/noip2011-cmdzjy/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1314" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>讲真，既然质监员这么聪明，为什么要让我们帮他设计程序？</p><p><del>所以还是叫ZZ的质检员吧</del></p><p>其实，我最想说的，不是这个题，而是这个$\Sigma$<del>(一见 $\Sigma$ 就懵逼系列)</del></p><p>这个题的式子是这样的：<br><img src="https://cdn.luogu.org/upload/pic/105.png" alt=""></p><p>嗯，它的意思是：在$L_i$到$R_i$这段区间里，合法的矿石的数量$\times$合法矿石的总价值</p><p>接下来就是这道题的思路了，知道这道题是二分后，这道题还是挺简单的，注意一下$\tt{long\;long}$的细节就可以了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">ll sum[<span class="number">200010</span>],ans=<span class="number">999999999999999999L</span>L;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">200010</span>],v[<span class="number">200010</span>],w[<span class="number">200010</span>],l[<span class="number">200010</span>],r[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">100000000</span>,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read(); ll s=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">w[i]=read(),v[i]=read(),h=min(w[i],h),t=max(w[i],t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">l[i]=read(), r[i]=read();</span><br><span class="line">h--, t++;</span><br><span class="line"><span class="keyword">while</span>(h&lt;t)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(h+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cnt[i]=cnt[i<span class="number">-1</span>]; sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(w[i]&gt;=mid) cnt[i]++,sum[i]+=v[i];</span><br><span class="line">&#125;</span><br><span class="line">ll y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">y+=(cnt[r[i]]-cnt[l[i]<span class="number">-1</span>])*(sum[r[i]]-sum[l[i]<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">y=s-y;</span><br><span class="line"><span class="keyword">if</span>(llabs(y)&lt;ans) ans=llabs(y);</span><br><span class="line"><span class="keyword">if</span>(y&lt;=<span class="number">0</span>) h=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清北学堂2018DP-图论精讲班-图论学习笔记</title>
      <link href="/2018/07/22/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/22/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>因为图论有好多东西比较基础，所以这篇笔记可能比较简略（<del>主要原因:博主太懒</del>）<br>因为老师可能不喜欢讲题，所以例题几乎没有<br>因为这篇笔记是我后来才补上的，所以也懒得按天数分了……</p><hr><h1 id="图论基本概念"><a href="#图论基本概念" class="headerlink" title="图论基本概念"></a>图论基本概念</h1><p>在这只列出一些定义名称，不知道的请自行百度。</p><ul><li>图<ul><li>顶点和边</li><li>顶点的度</li><li>带权图/完全图</li><li>邻接/路径</li><li>连通/强连通</li><li>稀疏图/稠密图</li><li>欧拉路</li><li>二分图</li><li>图的存储</li></ul></li><li>树<ul><li>根结点/叶子结点</li><li>高度/深度</li><li>树的遍历</li><li>二叉树的性质</li><li>树的直径</li></ul></li></ul><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><ul><li>$Prim$</li><li>$Kruskal$</li></ul><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><ul><li>$Floyd$</li><li>$Bellman-Ford$（$SPFA$）</li><li>$Dijkstra$</li></ul><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="noopener">BZOJ1001 狼抓兔子</a></p><p>平面图转对偶图跑最短路（神奇的解法）</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul><li><p>启发式合并<br>在合并集合S1、S2的时候，我们让较小的树成为较大的树的子树。这里可以是深度、节点个数等启发函数来比较树的大小。</p></li><li><p>路径压缩<br>我们在查找完u至根节点的路径之后，一般将这条路径上的 所有节点的父节点都设为根节点，这样可以大大减少之后的查找次数。</p></li></ul><p><a href="https://www.luogu.org/problemnew/show/P1196" target="_blank" rel="noopener">NOI2002 银河英雄传说</a><br>带权并查集</p><p>关于并查集还有好多好多骚操作，在这就不详细介绍了（<del>其实我也不会</del>）</p><h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><ul><li>$Tarjan$</li></ul><h1 id="割点、桥和双连通分量"><a href="#割点、桥和双连通分量" class="headerlink" title="割点、桥和双连通分量"></a>割点、桥和双连通分量</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>割点：删掉某点之后，G分裂成两个或两个以上子图<br>割点集合：删掉某点集之后，G分裂成两个或两个以上子图<br>点连通度：最小割点集合大小<br>割边：删掉某边之后，G分裂成两个或两个以上子图<br>割边集合：删掉某边集之后，G分裂成两个或两个以上子图<br>边连通度：最小割边集合大小<br>点双联通分量：点连通度大于1的极大子图<br>边双联通分量：边连通度大于1的极大子图<br>缩点：将点双联通分量缩为一个点的过程，即删除双联通分量内所有点，然后新建一个点，向所有双联通分量内的点有边相连的外部点连边</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="求割点和桥"><a href="#求割点和桥" class="headerlink" title="求割点和桥"></a>求割点和桥</h3><h4 id="判断一个点是否为割点："><a href="#判断一个点是否为割点：" class="headerlink" title="判断一个点是否为割点："></a>判断一个点是否为割点：</h4><ol><li>该点为根节点，且有多于1个子树</li><li>该点不是根节点，但存在$(u,v)$为树枝边使得$dfn[u]{&lt;=}low[u]$</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[<span class="number">100010</span>],low[<span class="number">100010</span>],deth,cut[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line">dfn[f]=low[f]=++deth;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">son++;</span><br><span class="line">tarjan(to,fa); low[f]=min(low[to],low[f]);</span><br><span class="line"><span class="keyword">if</span>((low[to]&gt;=dfn[f]&amp;&amp;f!=fa)||(f==fa&amp;&amp;son&gt;<span class="number">1</span>)) cut[f]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[f]=min(low[f],dfn[to]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断一条边是否为桥："><a href="#判断一条边是否为桥：" class="headerlink" title="判断一条边是否为桥："></a>判断一条边是否为桥：</h4><ol><li>$(u,v)$为树枝边，且满足$dfn[u]{&lt;}low[v]$(P.S. 注意重边)</li></ol><p>老师的代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[MXN], low[MXN], num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, edge *b)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line"><span class="keyword">for</span> (edge *lk = e[u]; lk; lk=lk-&gt;next) <span class="keyword">if</span> (lk != b)</span><br><span class="line"><span class="keyword">if</span> (!dfn[lk-&gt;t])&#123;</span><br><span class="line">tarjan(lk-&gt;t, op(lk)), low[u] = min(low[u], low[lk-&gt;t]);</span><br><span class="line"><span class="keyword">if</span> (dfn[u] &lt; low[lk-&gt;t])&#123;</span><br><span class="line"><span class="comment">// (u, lk-&gt;t) is bridge</span></span><br><span class="line">&#125;</span><br><span class="line">sbri[u] += sbri[lk-&gt;t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  low[u] = min(low[u], dfn[lk-&gt;t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h4><p>建立一个栈，存储DFS过程中访问的节点，初次访问一个点时把该点入栈。<br><strong>割点可能属于多个点双连通分量</strong>，其余点和每条边属于且仅属于一个点双连通分量。因此在从栈中取出节点时，要把u留在栈中。</p><h4 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h4><p>边双连通分量的求法非常简单，只需在求出所有的桥以后，把桥边删除。此时原图分成了若干个连通块，每个连通块就是一个边双连通分量。<br>桥不属于任何一个边双连通分量；其余的边和每个顶点都属于且仅属于一个边双连通分量。</p><h1 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先$(LCA)$"></a>最近公共祖先$(LCA)$</h1><ul><li>倍增</li><li>Tarjan</li><li><del>树链剖分</del></li></ul><h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>讲真这一部分超级学术，听的超级懵逼……<br>把概念名称打出来，自行百度吧……</p><ul><li>点支配集、点覆盖集、点独立集</li><li>边覆盖集与匹配</li></ul><p>重要结论：</p><ul><li>点覆盖数$+$点独立数$=n$</li><li>边覆盖数$+$边独立数$=n$</li><li>二分图的最小点覆盖数$=$最大匹配数</li><li>二分图的最大点独立数$=$顶点个数$-$最大匹配数。(前提是该二分图没有孤立顶点，如果有孤立顶点，对这些孤立顶点要单独考虑)</li></ul>]]></content>
      
      <categories>
          
          <category> 培训 </category>
          
          <category> 清北学堂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清北学堂2018DP&amp;图论精讲班 DP部分学习笔记</title>
      <link href="/2018/07/15/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/15/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>讲的挺基础的……不过还是有些地方不太明白</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p> 给定一个数n，求将n划分成若干个正整数的方案数。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p> 数字三角形</p><h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p>最长不下降子序列</p><p><strong>以上太过于基础，不做深入讨论</strong></p><hr><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>给定一个数n，求将n划分成若干个正整数的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$表示用不超过$j$的数来组成$i$</p></li><li><p>状态转移<br>$i &lt; j \;\;\; dp[i][j]=dp[i][i]$<br>$i = j \;\;\; dp[i][j]=dp[i][j-1]+1$<br>$i &gt; j \;\;\; dp[i][j]=dp[i-j][j-1]+dp[i][j-1]$</p></li></ul><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>一个人站在楼梯的第一级上，每次他可以向上走1~m级。有某些级楼梯是坏的，不能走上去。而且连续走了$k$次$m$级之后你接下来的一步只能走1级。问走到第N级的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$在第$i$级台阶上，连续走了$j$次$m$级</p></li><li><p>状态转移<br>$ \sum_{j=1}^{m-1}dp[i+j][0]+= \sum_{l=0}^{k-1}dp[i][l]$(我自己按老师的意思写的方程我自己都看不懂……)<br>$dp[i+1][0]+=dp[i][k]$<br>$dp[i+m][l+1]+=f[i][l]\;(l\neq k)$</p></li></ul><h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><a href="http://codeforces.com/problemset/problem/467/C" target="_blank" rel="noopener">Codeforces 467C George and Job</a></p><p>给定一个长度为n的序列，从序列中选出k个不重叠且连续的m个数，要求和最大。<br>$1&lt;=m\times k&lt;=n&lt;=5000$</p><p>题解：</p><ul><li><p>定义状态<br>$sum[]$为前缀和，$dp[i][j]$选了$j$段，以$i$为结尾</p></li><li><p>状态转移<br>$dp[i][j]=max(dp[i-m][j-1]+sum[i]-sum[i-m],dp[i-1][j])$</p></li></ul><h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1354" target="_blank" rel="noopener">51nod 1354 选数字</a></p><p>当给定一个序列$a[0],a[1],a[2],…,a[n-1]$和一个整数$K$时，我们想找出有多少子序列里面的所有元素乘起来恰好等于$K$。<br>方案数对$10^9+7$取模。<br>$n &lt;= 1000,k &lt;= 10^8$</p><p><strong>不会，全程懵逼</strong></p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>考试，估计要爆零……</p><p>嗯，60分，还不错——至少比想象中的高</p><h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/problemset.pdf" target="_blank" rel="noopener">考试题目</a></h3><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/sol.pdf" target="_blank" rel="noopener">官方题解</a></h3><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul><li><p>T1<br>只能说我太菜了，根本不会DP，爆搜+数据特判，40分滚粗</p></li><li><p>T2<br>我会最短路，怎么才20分？好吧，那30%$k=1$的测试点我承认我删边删错了。题目是双向边，我也是按双向边存的，结果删的时候只删了一条边……</p></li><li><p>T3<br>不会，讲了也不会 (｀＾´)ノ</p></li></ul><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>上午先讲了昨天没讲完的几道题，好吧，我太菜了，一道也不会 QAQ</p><hr><p>接Day1 例7</p><h3 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1294" target="_blank" rel="noopener">51nod 1294 修改数组</a></p><p>给出一个整数数组A，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？<br>$ n &lt; = 100000$</p><p>题解：</p><p>这道题思路很妙。</p><ul><li>$a[\;]$表示原序列<br>首先，我们将每个数$a[i]$减去它们对应的下标$i$，然后将$&lt; 0$的$a[i]$删去。因为每一个数都要是正整数，所以如果$a[i] &lt; i$，那它肯定不符合要求。<br>然后我们再在更改后的序列上找最长不下降子序列。最后用n-最长不下降子序列的长度就OK了</li></ul><h3 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h3><p>OpenJudge 6047 (找不到这道题 $\rm{Orz}$)</p><p>有一块矩形大蛋糕，长和宽分别是整数$w ,h$。现要将其切成$m$块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的$m$块小蛋糕中，最大的那块蛋糕的面积下限。<br>$w,h,m &lt;= 20$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k]$表示长宽为$i,j$的蛋糕切$k$刀的答案</p></li><li><p>边界条件<br>$dp[i][j][0]=i\times j$</p></li><li><p>状态转移<br>$dp[i][j][k]=min(max(dp[i][o][p],dp[i][j-o][k-1-p],dp[o][j][p],dp[i-o][j][k-p-1]))$</p></li></ul><h3 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h3><p><a href="http://codeforces.com/problemset/problem/407/B" target="_blank" rel="noopener">Codeforces 407B Long Path</a></p><p>有$n+1$个房间，一个人在1号房间。如果这是他第奇数次到当前房间（$i$号），那么他会去$pi\; (pi { &lt;= }i)$号房间，否则他会去$i+1$号房间。不管他去了那个房间，他的移动次数+1。<br>到达n+1号房间停止移动。问这时他的移动次数。答案对$1000000007$取模。<br>$n &lt;= 1000$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][0]$表示奇数次到达$i$号房间，$dp[i][1]$表示偶数次到达$i$号房间</p></li><li><p>状态转移<br>方程不如代码好表达(不想再写一个自己都看不懂的$\Sigma$了)，所以我就把代码给搬上来了 qwq</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a[i]是原序列,dp数组如上所说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;i;j++)</span><br><span class="line">        dp[i][<span class="number">1</span>]+=(dp[j][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n][<span class="number">1</span>]+dp[n][<span class="number">0</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><p>至此，基础(?)的DP就讲完了</p><hr><p>进入——<strong>区间DP</strong></p><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1541" target="_blank" rel="noopener">NOIp2010 乌龟棋</a></p><p>在一行$n$个格子上进行游戏，每个格子有一个分数$a[i]$。你在$1$号格子，每次可以向前走$1/2/3/4$个格子，每种走法限制最多走$b_1/b_2/b_3/b_4$次。一次走法的分数是走过的格子的分数和。问走到n号格子的最大分数。<br>保证$b_1+2\times b_2+3\times b_3+4\times b_4=n-1$（恰好走完所有的次数）<br>$n&lt;=350,a[i]&lt;=100,b_i&lt;=40$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k][l]$表示各种类别的卡片分别还剩多少</p></li><li><p>状态转移<br>算了，本来想打方程的，懒了，丢代码吧，感受一下四维DP的魅力吧！ 233</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cards[<span class="number">1</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cards[<span class="number">2</span>];j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cards[<span class="number">3</span>];k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cards[<span class="number">4</span>];l++)&#123;</span><br><span class="line">          pos=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span>(i) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(j) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(k) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(l) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+mark[pos]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[cards[<span class="number">1</span>]][cards[<span class="number">2</span>]][cards[<span class="number">3</span>]][cards[<span class="number">4</span>]]+mark[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P2679" target="_blank" rel="noopener">NOIp2015 子串</a></p><p>有两个仅包含小写英文字母的字符串$A$和$B$。现在要从字符串$A$中取出$k$个互不重叠的非空子串,然后把这$k$个子串按照其在字符串$A$中出现的顺序依次连接起来得到一个新的字符串,请问有多少种方案可以使得这个新串与字符串$B$相等？注意：子串取出的位置不同也认为是不同的方案。输出方案数%1000000007<br>$length(A) &lt;= 1000,1 &lt;= k &lt;= length(B) &lt;= 200$</p><p>题解：</p><p>这道挺毒的，卡空间，必须用滚动数组优化</p><ul><li><p>定义状态<br>$dp[i][j][k][0/1]$表示字符串$A$到$i$，字符串$B$到$j$，取出了$k$个字符串，第$i$个字符选不选</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>状态转移<br>以后有代码就直接丢代码了，懒了懒了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++,pos^=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=k;o++)&#123;</span><br><span class="line">          dp[pos][j][o][<span class="number">0</span>]=dp[pos^<span class="number">1</span>][j][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j][o][<span class="number">0</span>]%mod;</span><br><span class="line">          <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            dp[pos][j][o][<span class="number">1</span>]=dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">0</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">1</span>]%mod;</span><br><span class="line">          <span class="keyword">else</span> dp[pos][j][o][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n&amp;<span class="number">1</span>][m][k][<span class="number">0</span>]+dp[n&amp;<span class="number">1</span>][m][k][<span class="number">1</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">NOI1995 石子合并</a></p><p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。<br>$n { &lt;= } 100$</p><p>题解：</p><p>这个题目要求最小代价，除了最小代价，Luogu还要求求出最大代价，不过实现的方法一模一样</p><p>很经典的一道题目，区间DP入门必刷题</p><p>首先要破环为链+前缀和处理</p><ul><li><p>定义状态<br>$dp[i][j]$表示合并区间$[i,j]$的最小代价</p></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+n;j++)&#123;</span><br><span class="line">  dp2[i][j]=<span class="number">214748364</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">  dp2[i][j]=min(dp2[i][j],dp2[i][k]+dp2[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1040" target="_blank" rel="noopener">NOIp2003 加分二叉树</a></p><p>设一个$n$个节点的二叉树$tree$的中序遍历为$(1,2,3,…,n)$，其中数字$1,2,3,…,n$为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为$di$,$tree$及它的每个子树都有一个加分，任一棵子树$subtree$（也包含$tree$）的加分计算方法如下：<br>$subtree$的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。<br>若某个子树为空，规定其加分为$1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>试求一棵符合中序遍历为$(1,2,3,…,n)$且加分最高的二叉树$tree$。要求输出$tree$的最高加分<br>$n {&lt;=} 30$</p><p>题解：</p><p>emmmm，第三次碰到这题了，到现在还记得当时爆零的屈辱</p><ul><li><p>定义状态<br>$dp[i][j]$表示区间$[i,j]$的最大得分</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=num[i]; <span class="comment">//num[ ]为原序列</span></span><br><span class="line">dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">  <span class="keyword">if</span>(dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k]&gt;dp[i][j])&#123;</span><br><span class="line">  dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k];</span><br><span class="line">  tree[i][j]=k; <span class="comment">//用于输出</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>输出<br>这道题输出也是个坑</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tree[l][r]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">print(l,tree[l][r]<span class="number">-1</span>);</span><br><span class="line">print(tree[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例5-1"><a href="#例5-1" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">SCOI2003 字符串折叠</a></p><p>折叠的定义如下：</p><p>一个字符串可以看成它自身的折叠。记作$S = S$<br>$X(S)$是$X(X&gt;1)$个$S$连接在一起的串的折叠。记作$X(S) = SSSS…S(X$个$S)$。</p><p>如果$A = A’,B = B’$，则$AB = A’B’$例如，因为$3(A) = AAA, 2(B) = BB$，所以$3(A)C2(B) = AAACBB$，而$2(3(A)C)2(B) = AAACAAACBB$</p><p>给一个字符串，求它的最短折叠。例如$AAAAAAAAAABABABCCD$的最短折叠为：$9(A)3(AB)CCD$。</p><p><strong>日常懵逼，不会</strong></p><p>区间DP就这么结束了</p><hr><p>接下来是<strong>背包</strong>和<strong>数位DP</strong></p><p><strong>背包</strong></p><h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>因篇幅原因$+$过于基础，在这里我们<strong>跳过所有背包模板</strong></p><h3 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h3><p>有$n$个人参加拔河比赛，要把他们分为两组，每人的实力为$a_i$，一组的实力为这组人的实力之和。求两队实力差的最小值。（两队的人数没有限制）</p><p>题解：</p><p>以$\frac{\sum_{i=1}^{n}a[i]}{2}$为背包容量，跑一遍阉割版的01背包即可</p><h3 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1782" target="_blank" rel="noopener">Luogu P1782 旅行商的背包</a></p><p>你有一个背包容积为$V$，有$n$种不可分割的物品（每种$p_i$个），每件的体积为$v_i$和价值$c_i$，你还有$m$种神奇的物品，它们的价值$c_i=a<em>v^2+b</em>v+c$，$v$是你决定的这件物体体积（大于等于0）。求最优价值。<br>$V&lt;=1000,n&lt;=1000,p_i&lt;=1000,m&lt;=5$</p><p>题解：</p><p>两种背包分开跑，先跑神奇的物品，再用跑完的dp数组去跑多重背包</p><h3 id="例3-2"><a href="#例3-2" class="headerlink" title="例3"></a>例3</h3><p><a href="https://vijos.org/p/1240" target="_blank" rel="noopener">Vijos P1240 朴素的网络游戏</a></p><p>有一家旅馆，有$n$间房间，每间可以住$a_i$人，需要$b_i$元。<br>有$i$个男人，$j$个女人来住宿，其中有$k$对夫妻，要求每间房间住的全是同性或者是一对夫妻(单人间无法住夫妻)。<br>问最少的总租金。<br>$n,i,j&lt;=300$</p><p>题解：</p><p><del>一看到这道题，机房里就充满了快♂活的气息</del></p><p> 首先，你需要想到：存在一种最优方案使得之多有一对夫妻在一件房间内。因为如果有两对，使两个男性住一间，两个女性住一间。</p><p>所以这道题里，我们只要考虑有一对夫妻就可以了</p><ul><li><p>定义状态<br>$dp[i][j][k][0/1]$表示前$i$个房间里住了$j$个男性、$k$个女性、有没有夫妻</p></li><li><p>状态转移<br>$dp[i][j][k][0]=min(dp[i-1][j][k][0],dp[i-1][j-a[i]][k][0]+b[i],dp[i-1][j][k-a[i]][0]+b[i])$<br>$dp[i][j][k][1]=min(dp[i-1][j][k][1],dp[i-1][j-1][k-1][0]+b[i],$ $dp[i-1][j-a[i]][k][1]+b[i],dp[i-1][j][k-a[i]][1]+b[i])$</p></li></ul><h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1877" target="_blank" rel="noopener">HAOI2012 音量调节</a></p><p>开始有一个数$begin$，给一个长为$n$的序列$c_i$，每次操作可以选择把开始的数加或减$c_i$，变为新的数，之后在上一次的数的基础上加或减。要求每次操作之后的数要大于等于0，小于等于$max$，求最后一次操作之后这个数的最大值。如果没有满足要求的解输出-1.<br>$0 {&lt;=} begin {&lt;=} max {&lt;=} 1000,1{&lt;=}n{&lt;=}50$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$表示$i$次操作后，数为$j$是否可行</p></li><li><p>状态转移<br>$if\;\;dp[i][j]{==}1$<br>$dp[i+1][j+c[i]]=1(j+c[i]&lt;=max)$<br>$dp[i+1][j-c[i]]=1(j-c[i]&gt;=0)$</p></li></ul><h3 id="例5-2"><a href="#例5-2" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2287" target="_blank" rel="noopener">Bzoj 2287 消失之物</a></p><p>有$n$件物品，每件物品有体积$v_i$，问装满体积$V$的方案数。答案对10取模。<br>但是你要输出：如果第i件物品消失了，装了体积为j的方案数。$i=1…n,j=1…V$<br>$n,V&lt;=1000$</p><p><strong>嗯，不会</strong></p><hr><p><strong>数位</strong></p><p>感觉数位DP有些迷，真心没怎么听懂</p><h3 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h3><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009" target="_blank" rel="noopener">51nod 1009 数字1的数量</a></p><p>给定一个十进制正整数N，写下从1开始，到N的所有正数，计算出其中出现所有1的个数。<br>例如：n = 12，包含了5个1。1,10,12共包含3个1，11包含2个1，总共5个1。</p><p>题解：</p><ul><li><p>首先可以预处理出来如果后$i$位数字随便选，那么一共有多少个$1$，记为$f[i]$。$f[i]=i\times 10^{i-1}$<br>分别计算如果前$i$位和$n$的前$i$位恰好相同，那么有多少个$1$.</p></li><li><p>如：<br>$n=124056$ 第一位为0~1<br>考虑第一位为0时，那么之后的位可以随便选，对答案贡献$f[5]$，而这一位的0不贡献答案<br>第一位为1时，那么之后的为不能随便选，只有$24057$种选法。这一位对答案的贡献是$24057$，之后继续计算后五位对答案的贡献<br>此时第一位固定为$1$。第二位可以是$0/1/2$。<br>是0时，第2位不贡献答案，但是后面4位随便选。贡献$f[4]$<br>是1时，第2位贡献答案为$10^4$。后面4位随便选，贡献$f[4]$<br>是2时，第2位不贡献答案，后面4位不能随便选，答案不能直接计算，继续固定第二位，看第3位的数值<br>……<br>直到最后一位。</p></li></ul><h3 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3652" target="_blank" rel="noopener">Hdu 3652 B-number</a></p><p>找出1~n范围内含有13并且能被13整除的数字的个数<br>$n&lt;=10^{17}$</p><p><strong>我太菜了，van♂全不会</strong></p><p>背包和数位就到此结束了</p><hr><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>接下来让我们进入<strong>状压DP</strong></p><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-4"><a href="#例1-4" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P2622" target="_blank" rel="noopener">Luogu P2622 关灯问题II</a></p><p>现有$n$盏灯，以及$m$个按钮。每个按钮可以同时控制这$n$盏灯——按下了第$i$个按钮，对于所有的灯都有一个效果。按下$i$按钮对于第$j$盏灯，是下面3中效果之一：如果$a[i][j]$为$1$，那么当这盏灯开了的时候，把它关上；如果为$-1$的话，如果这盏灯是关的，那么把它打开；如果是$0$，则无效果。<br>现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。</p><p>题解：</p><ul><li><p>emmmmm，这题只状压，不DP</p></li><li><p>存状态的时候状压</p></li><li><p>然后将能互相到达的状态之间连边，然后广搜最短路就好了</p></li></ul><h3 id="例2-4"><a href="#例2-4" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1896" target="_blank" rel="noopener">SCOI2005 互不侵犯</a></p><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上、下、左、右，以及左上、左下、右上、右下八个方向上附近的各一个格子，共8个格子。<br>$n&lt;=9,k&lt;=n^2$</p><p>题解：</p><ul><li><p>定义状态<br>肯定要状压<br>$dp[i][k][j]$表示前$i$行放了$k$个国王，j表示第$i$行的摆放方式</p></li><li><p>状态转移<br>我们要快速的判断摆放方式是否合法<br>用$i$表示某一行的状态</p><ul><li>同一行<br>$i\And (i { &gt; &gt; }1)$</li><li>相邻行的状态$k$<br>$i\And k$<br>$i\And (k{ &gt; &gt; }1)$<br>$i\And (k{ &lt; &lt; }1)$</li></ul><p>以上的式子中如果有一个结果为1，说明无法转移<br>$get[i]$表示数字$i$的二进制位中$1$的数量，也就是第$i$行的国王数量，$l$表示$i-1$行国王的状态<br>$dp[i][k][j]+=dp[i-1][k-get[i]][l]$</p></li></ul><p>状压完结散花</p><hr><p>欢迎来到<strong>DP优化</strong>！</p><h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><p>除了例1，别的啥都不会，只会暴力DP……什么矩阵加速、数据结构维护，不存在的。</p><h2 id="例1-5"><a href="#例1-5" class="headerlink" title="例1"></a>例1</h2><p>斐波那契数列<br>$f[1]=f[2]=1$<br>$f[n]=f[n-1]+f[n-2] (n {&gt;=} 3)$<br>求$f[n]\mod(10^9+7)$<br>$n&lt;=10^{18}$</p><p>题解：</p><p>矩阵快速幂加速，不解释</p><h2 id="例2-5"><a href="#例2-5" class="headerlink" title="例2"></a>例2</h2><p><a href="http://codeforces.com/problemset/problem/821/E" target="_blank" rel="noopener">Codeforces 821E Okabe and El Psy Kongroo</a></p><p>你在$(0,0)$。在$(x,y)$时，每次移动可以到达$(x+1,y+1),(x+1,y),(x+1,y-1)$，平面上有$n$条线段，平行于$x$轴，参数为$a_i,b_i,c_i$，表示在$(a_i,c_i)$到$(b_i,c_i)$的一条线段，保证$b[i]=a[i+1]$，要求你一直在线段的下方且在$x$轴上方，即$a_i {&lt;= } x { &lt;=} b_i$时，$0 { &lt;= }y{ &lt;= }c_i$。问到达$(k,0)$的方案数，对$10^9+7$取模。<br>$n&lt;=100,k&lt;=10^{18},ci&lt;=15$</p><p>题解：</p><p>实现不是很会，但明白了做法，思路确实很神奇</p><p>直接DP就是：$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+dp[i+1][j-1]$</p><p>但是肯定会T，所以我们可以用矩阵来加速</p><p>$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}$ $\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}$</p><p>这样应该就可以了吧？(超级不自信)</p><h2 id="例3-3"><a href="#例3-3" class="headerlink" title="例3"></a>例3</h2><p><a href="http://noi.openjudge.cn/ch0206/9277/" target="_blank" rel="noopener">Openjudge  Noi 9277 Logs Stacking</a></p><p>给出在最底层的木头的个数，问有多少种堆放木头的方式，当然你的堆放方式不能让木头掉下来.<br>在堆放的时候木头必须互相挨着在一起.<br>$n &lt;= 200000$</p><p>题解：</p><ul><li><p>正常解法<br>$dp[i]=dp[i]+s[i]$<br>其中s是dp的前缀和。</p></li><li><p>非正常解法<br>找规律 2333</p></li></ul><h2 id="例4-3"><a href="#例4-3" class="headerlink" title="例4"></a>例4</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 4362 Dragon Ball</a></p><p>在连续的$n$秒中，在$x$轴上每秒会出现$m$个龙珠，出现之后会立即消失，知道了第一秒所在的位置，每从一个位置移动到另一个位置的时候，消耗的价值为$abs(i-j)$, 拿到龙珠也要消耗一个价值（不同龙珠的价值不同），问$n$秒之后最少消耗多少价值。<br>$m &lt;= 500,n&lt;=1000$</p><p>题解：</p><p>虽然老师在上面讲+$\mathfrak{Lancelot}$ dalao给我私下讲，但我还是有些迷，我太蒟了怎么破QAQ</p><ul><li><p>暴力DP<br>$dp[i][j]$表示在$i$秒后，在第$j$个龙珠的位置上的最小代价。<br>$dp[i][j]=min(dp[i-1][k]+abs(pos[i-1][k]-pos[i][j]))(k=1..m)+cost[i][j]$<br>时间复杂度$O(m^2n)$</p></li><li><p>优化DP<br>把绝对值拆开，变成向左走和向右走两种。<br>把当前时间的龙珠按位置排序，从左到右扫描，维护一个最小的$s=dp[i-1][k]-pos[i-1][k]$，这样$dp[i][j]=s+pos[i][j]+cost[i][j]$<br>从右到左类似。<br>$O(mnlogm)$</p></li></ul><h2 id="例5-3"><a href="#例5-3" class="headerlink" title="例5"></a>例5</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 5009 Paint Pearls</a></p><p>给你一个数组，每个值代表一种颜色，每次选一个区间删去，代价是区间内颜色种类数的平方，删完所有数组，问你最小代价是多少。<br>$n&lt;=50000$</p><p>题解：</p><p>没怎么听<del>因为听了也听不懂</del></p><p>但是应该是双向链表+DP。DP转移时直接从上一个最后一次出现的颜色那转移过来就可以。另外，区间的长度最多为$\sqrt n$个，也可以剪枝<br>时间复杂度$O(n\sqrt{n})$</p><p>DP优化也就这样了</p><hr><p>嗯，树上DP了解一下</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-6"><a href="#例1-6" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1352" target="_blank" rel="noopener">Luogu P1352 没有上司的舞会</a></p><p>某大学有$N$个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。<br>$n&lt;=6000$</p><p>题解：</p><p>树上DP经典题目</p><ul><li><p>定义状态<br>$dp[i][0/1]$表示节点i不被选/被选所获得的最大快乐指数</p></li><li><p>边界条件<br>$dp[leaf][1]=a[i]$<br>$leaf$表示叶子结点，$a[i]$是原序列</p></li><li><p>状态转移<br>$dp[from][0]+=max(dp[to][1],dp[to][0])$<br>$dp[from][1]+=dp[to][0]+a[from]$</p></li></ul><h3 id="例2-6"><a href="#例2-6" class="headerlink" title="例2"></a>例2</h3><p>树的直径</p><p>给一棵树，求树上最长路径的长度。<br>$n&lt;=500000$</p><p>题解：</p><ul><li><p>解法一：</p><ul><li>DP<br>考虑树上dp，确定一个根，一条路径一定存在一个深度最浅的节点。枚举每个点成为lca，看向子树伸出去的两条路径的长度和最长是多少。<br>$dp[i][0/1]$表示从i号点向下的最长/次长路径长度。<br>$dp[i][0]=max(dp[son][0])+1$注意只能用每个子树的最长路径更新i的最长和次长路径。即使一个子树次长路径很大，也不能更新，否则lca不是i。<br>$O(n)$</li></ul></li><li><p>解法二：</p><ul><li>随便找一个点，用$\mathcal{dfs}$找到离这个点最远的点$i$，再用$\mathcal{dfs}$找离$i$最远的点$j$。$i$到$j$的路径是一条直径。<br>证明正确性吗？不存在的，我懒得打了（逃。<br>P.S. 法二不能用于负边权</li></ul></li></ul><h3 id="例3-4"><a href="#例3-4" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P2014" target="_blank" rel="noopener">Luogu P2014 选课</a></p><p>有$n$节课可以选，每节课有至多一个前置课程，和这节课的学分，问如果只能选$m$节课，最多有多少学分。<br>$n&lt;=300$</p><p>题解：</p><ul><li><p>我说这题是树上跑背包你信么？</p></li><li><p>算法主体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">310</span>][<span class="number">310</span>],a[<span class="number">310</span>],n,m; <span class="comment">//dp[i][j]表示a[ ]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    dp[f][<span class="number">1</span>]=a[f];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i!=<span class="number">-1</span>;i=tree[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=tree[i].t; dfs(to);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o=j<span class="number">-1</span>;o&gt;=<span class="number">1</span>;o--)</span><br><span class="line">              dp[f][j]=max(dp[f][j],dp[f][j-o]+dp[to][o]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例4-4"><a href="#例4-4" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4679" target="_blank" rel="noopener">Hdu 4079 Terrorist’s destroy</a></p><p>给定一颗树，每条边有一个权值w,问切掉哪条边之后，分成的两颗树的较大的直径*切掉边的权值最小？如果存在多条边使得结果相同，输出边id最小的。<br>$n&lt;=100000$</p><p>题解：</p><p>我们要分类讨论一下：</p><ul><li><p>要切的边在不在直径上<br>我们直接用那条边的权值去乘直径就可以了</p></li><li><p>要切的边在直径上<br>这时就需要我们能够快速的算出切开后两部分的的直径<br>要解决这个问题，我们要先算出图的一条直径，记下起点$s$和终点$t$，然后分别以$s$和$t$为根，去找直径，处理出来的$dp[u]$就是$fa[u]-&gt;u$被切开后的直径</p></li></ul><h3 id="例4-5"><a href="#例4-5" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/CF219D" target="_blank" rel="noopener">Codeforces 219D Choosing Capital for Treeland</a></p><p>给一棵树，每条边有方向，改变一条边方向的代价是1.<br>对于一个点，如果选它为根，那么需要把方向不对的边改变方向（都变成深度小的点指向深度大的点）。<br>问选一个点为根的最小代价。和选哪些点的代价是这个数字。<br>$n&lt;=200000$</p><p>题解：</p><p>$dp[u]$表示以$u$为根要调整的次数，再记录下方向<br>一遍DFS，同向加，反向减</p><h3 id="例5-4"><a href="#例5-4" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P2607" target="_blank" rel="noopener">ZJOI2008 骑士</a></p><p>给一个环套树森林，求最大权独立集。（就是相邻的点不能同时选）<br>$n&lt;=1000000$</p><p>题解：</p><blockquote><p>先找到那个环。随便找两个点，暴力枚举这两个点选不选。之后变成森林。</p></blockquote><p>这是老师PPT上的题解，就一句话，十分简练。</p><p>嗯，然后我就懵逼了……</p><p>树型DP就这么在懵逼中结束了，接下来有更懵逼的……</p><hr><p>期望DP是什么？能吃吗？斜率优化又是什么？</p><p>讲真，下午彻底懵逼</p><h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><h3 id="例1-7"><a href="#例1-7" class="headerlink" title="例1"></a>例1</h3><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3551" target="_blank" rel="noopener">Zoj 3551 Bloodsucker</a></p><p>开始有一个吸血鬼，n-1个平民百姓。每天等概率选出两个人，如果是一个吸血鬼一个平民，平民以p的概率被转化为吸血鬼，否则什么也不发生。问每个人都变成吸血鬼的天数期望。<br>$n&lt;=100000$</p><p>题解：</p><p>设$dp[i]$为有$i$个吸血鬼的话还期望需要多少天完成。<br>设$p[i]$为此时转换了一个平民的概率。<br>$p[i]=\frac{2\times (n-i)\times i}{n\times(n-1)}\times p$<br>$dp[i]=p[i]\times dp[i+1]+(1-p[i])\times(dp[i])+1$</p><h3 id="例2-7"><a href="#例2-7" class="headerlink" title="例2"></a>例2</h3><p><a href="http://poj.org/problem?id=3744" target="_blank" rel="noopener">Poj 3744 Scout YYF I</a></p><p>在$x$轴上，你现在的起点在$1$处。在$N$个点处布有地雷，$1&lt;=N&lt;=10$。地雷点的坐标范围：$[1,100000000]$.<br>每次前进$p$的概率前进$1$步，$1-p$的概率前进$2$步。问顺利通过这条路的概率。就是不要走到有地雷的地方。</p><p>题解：</p><ul><li><p>设$dp[i]$表示一条路径经过i的概率。<br>$dp[1]=1,dp[i]=p\times dp[i-1]+(1-p)\times dp[i-2]$<br>快速幂算出$1-dp[x_1]$就是安全通过第一个地雷的概率，此时在$x_1+1$，你又要通过$x_2,…x_n$，就是把$(x_1+1)\text{~}x_2$再做一次，全都安全通过的概率乘起来。</p></li><li><p><em>嗯，以上全都是抄的老师的PPT</em></p></li></ul><h3 id="例3-5"><a href="#例3-5" class="headerlink" title="例3"></a>例3</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2262" target="_blank" rel="noopener">hdu 2262 Where is the canteen</a></p><p>现在在一个$n\times m$规模的区域上从$’@’$处出发,每次都随机向前后左右四个方向中选择可以走的方向进入（$’#‘$不可走, 不能越过边界）。现在问到达终点$’$‘$的期望步数, 终点可能有多个, 输入保证一定有起点$n,m&lt;=15$, 如果无法到达任何一个终点输出$-1$</p><p>题解：</p><p>高斯消元，爱信不信。</p><h3 id="例4-6"><a href="#例4-6" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">hdu 3507 Print Article</a></p><p>给一个数列ai，要求划分成若干段，一段的代价是$\sum a_i^2+M$，总的代价是每段代价和。<br>求最小总代价。<br>$n&lt;=500000$</p><p>题解：</p><ul><li>嗯，真·斜率优化</li><li>嗯，真·不会</li><li>嗯，还是把老师的代码放上来吧</li></ul><p>膜拜一下老师 orz<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , sum[<span class="number">500010</span>] , q[<span class="number">500010</span>] , dp[<span class="number">500010</span>] , head , tail;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getup</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x] + sum[x]*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdown</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) <span class="built_in">scanf</span> ( <span class="string">"%d"</span> , &amp;sum[i] );</span><br><span class="line">    sum[<span class="number">0</span>] = dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">    q[<span class="number">1</span>] = <span class="number">0</span>; head = tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">        <span class="comment">//斜率优化</span></span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; getup(q[head+<span class="number">1</span>]) - getup(q[head]) &lt;= sum[i]*(getdown(q[head+<span class="number">1</span>])-getdown(q[head])) ) head++;</span><br><span class="line">        dp[i] = dp[q[head]] + ( sum[i] - sum[q[head]] ) * ( sum[i] - sum[q[head]] ) + m;</span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; ( getup(q[tail]) - getup(q[tail<span class="number">-1</span>])) * ( getdown(i) - getdown(q[tail]) ) &gt;=</span><br><span class="line">                                            ( getup(i) - getup(q[tail]) ) * ( getdown(q[tail]) - getdown(q[tail<span class="number">-1</span>]) ) ) tail--;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%d\n"</span> , dp[n] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span> ( <span class="string">"%d%d"</span> , &amp;n , &amp;m ) != EOF ) work ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，DP应该就告一段落了。</p><p>我DP掌握的还是不够好，以后也要多加锻炼。</p>]]></content>
      
      <categories>
          
          <category> 培训 </category>
          
          <category> 清北学堂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Goodbye</title>
      <link href="/2018/07/13/Goodbye/"/>
      <url>/2018/07/13/Goodbye/</url>
      <content type="html"><![CDATA[<p>嗯，我又双叒换了一个$\tt{Blog}$……</p><p><del>zzc说得对，Blog的美化是没有尽头的</del></p><hr><p>既然又换了一个$\tt{Blog}$，那就要有一个新的开始，所以说：</p><p>再见了，以前的$\mathcal{Blog}$……</p><p>再见了，以前的时光……</p><p>最重要的是———</p><p>再见了，颓废……</p><hr><p>回首过去，我真的太菜了……</p><p>我到底干了些什么，干成了些什么，连我自己都不知道，</p><p>只知道，我太菜了……</p><p>我只能告诉自己：要加油啊……</p><hr><p>我希望能变成一个新的自己</p><p>不再软弱，不再无能，不再颓废……</p><p>再见了，以前的自己</p><p>我希望变成一个不一样的自己……</p><hr><p>这是我其他的$\tt{Blog}$，没事就去逛逛吧，内容可能和这个博客不太一样</p><p>虽说再见，但我还是不会抛弃他们的……<del>所以说看官没事去点个赞呗</del></p><ul><li><a href="https://www.luogu.org/blog/34188/" target="_blank" rel="noopener">Luogu Blog</a></li><li><a href="http://www.cnblogs.com/wxl-Ezio/" target="_blank" rel="noopener">Cnblog</a></li></ul><hr><p><strong>我期盼着一个新的开始……</strong></p><hr><p>$ $<br>$ $<br>$ $<br>$ $<br>$ $<br>$ $<br>$ $</p><p>……</p><p>你觉得我是这么悲伤消沉的人么？</p><p>你觉得我要开始奋进了么？</p><p>$Too\;young,too\;simple$</p><p>该颓的总是要颓的，学个**!</p>]]></content>
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
