<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>USACO17JAN Hoof, Paper, Scissor</title>
      <link href="/2019/01/07/usaco17jan/"/>
      <url>/2019/01/07/usaco17jan/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3609" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>这种$DP$能有蓝题？反正我是不信</p><hr><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><code>f[i][j][k]</code> 表示当前是第$i$局，已经变了$j$次手势，当前的手势是$k$，之后能赢多少场</p><h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>用一种类似后缀和的方式，记录下如果当前变为该手势，则之后能赢多少局（其实这步并不必要，但我觉得更好理解一些）</p><p>之后疯狂判断就好了</p><p><code>f[i][j][k]=max(f[i][j][k],f[i][j-1][k]-sum_now[i]+sum_change[i])</code></p><p>其中<code>sum_now[i]</code>为 当前手势之后能赢多少场，<code>sum_change[i]</code>为 改变后的手势之后能赢多少场</p><h4 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h4><p>特判有点冗杂，但还是挺容易理解的……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc() getchar()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;LL k=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=gc();<span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>; c=gc();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)k=k*<span class="number">10</span>+c<span class="number">-48</span>,c=gc();<span class="keyword">return</span> k*f;&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">read_c</span><span class="params">()</span></span>&#123;<span class="keyword">char</span> c=gc();<span class="keyword">while</span>((c&lt;<span class="string">'a'</span>||c&gt;<span class="string">'b'</span>)&amp;&amp;(c&lt;<span class="string">'A'</span>||c&gt;<span class="string">'Z'</span>))c=gc();<span class="keyword">while</span>((c&gt;=<span class="string">'a'</span>&amp;&amp;c&lt;=<span class="string">'z'</span>)||(c&gt;=<span class="string">'A'</span>&amp;&amp;c&lt;=<span class="string">'Z'</span>))<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>][<span class="number">21</span>][<span class="number">4</span>],s[<span class="number">100010</span>],m[<span class="number">100010</span>],b[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),k=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">char</span> c=read_c();</span><br><span class="line">        s[i]=s[i+<span class="number">1</span>]; m[i]=m[i+<span class="number">1</span>]; b[i]=b[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'P'</span>) s[i]++;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'S'</span>) m[i]++;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'H'</span>) b[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=s[<span class="number">1</span>]; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]=m[<span class="number">1</span>]; f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">3</span>]=b[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            f[i][j][<span class="number">1</span>]=f[i<span class="number">-1</span>][j][<span class="number">1</span>]; f[i][j][<span class="number">2</span>]=f[i<span class="number">-1</span>][j][<span class="number">2</span>]; f[i][j][<span class="number">3</span>]=f[i<span class="number">-1</span>][j][<span class="number">3</span>];</span><br><span class="line">            ans=max(ans,max(f[i][j][<span class="number">1</span>],max(f[i][j][<span class="number">2</span>],f[i][j][<span class="number">3</span>])));</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            f[i][j][<span class="number">1</span>]=max(f[i][j][<span class="number">1</span>],max(f[i][j<span class="number">-1</span>][<span class="number">2</span>]-m[i]+s[i],f[i][j<span class="number">-1</span>][<span class="number">3</span>]-b[i]+s[i]));</span><br><span class="line">            f[i][j][<span class="number">2</span>]=max(f[i][j][<span class="number">2</span>],max(f[i][j<span class="number">-1</span>][<span class="number">1</span>]-s[i]+m[i],f[i][j<span class="number">-1</span>][<span class="number">3</span>]-b[i]+m[i]));</span><br><span class="line">            f[i][j][<span class="number">3</span>]=max(f[i][j][<span class="number">3</span>],max(f[i][j<span class="number">-1</span>][<span class="number">1</span>]-s[i]+b[i],f[i][j<span class="number">-1</span>][<span class="number">2</span>]-m[i]+b[i]));</span><br><span class="line">            ans=max(ans,max(f[i][j][<span class="number">1</span>],max(f[i][j][<span class="number">2</span>],f[i][j][<span class="number">3</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\; Good\; Bye\; 2018$</title>
      <link href="/2019/01/02/cf-gb2018/"/>
      <url>/2019/01/02/cf-gb2018/</url>
      <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1091" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><p>终于摆脱$pupil$！成为$Specialist$</p><p>元旦$RP++$</p><hr><h3 id="A-New-Year-and-the-Christmas-Ornament"><a href="#A-New-Year-and-the-Christmas-Ornament" class="headerlink" title="$A.New\; Year\; and\; the\; Christmas Ornament$"></a>$A.New\; Year\; and\; the\; Christmas Ornament$</h3><p>没什么好说的，送分题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y,b,r,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;y&gt;&gt;b&gt;&gt;r;</span><br><span class="line">    ans+=min(y,min(b<span class="number">-1</span>,r<span class="number">-2</span>))*<span class="number">3</span>+<span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-New-Year-and-the-Treasure-Geolocation"><a href="#B-New-Year-and-the-Treasure-Geolocation" class="headerlink" title="$B.New\; Year\; and\; the\; Treasure\; Geolocation$"></a>$B.New\; Year\; and\; the\; Treasure\; Geolocation$</h3><p>因为每个向量和每个坐标都是一一对应的，而它们又都指向目标地点，所以我们枚举目标地点就好了。<br>我们用第一个坐标去试每个向量，找出目标地点，再判断目标地点是否合法，即目标地点对于每一个向量，都有一个坐标对应<br>偷懒用$map$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">bool</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1010</span>],b[<span class="number">1010</span>],xx,yy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) xx=x,yy=y;</span><br><span class="line">        q[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> ansx=xx+a[i],ansy=yy+b[i];</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!q[ansx-a[j]][ansy-b[j]])&#123;</span><br><span class="line">                flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ansx&lt;&lt;<span class="string">" "</span>&lt;&lt;ansy;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-New-Year-and-the-Sphere-Transmission"><a href="#C-New-Year-and-the-Sphere-Transmission" class="headerlink" title="$C.New\; Year\; and\; the\; Sphere\; Transmission$"></a>$C.New\; Year\; and\; the\; Sphere\; Transmission$</h3><p>虽然我不会证，但我会猜结论啊！</p><p>$10^9$的数据范围，不是$O(\sqrt n)$就是$O(\log n)$<br>再根据这道题的实际情况，可以猜出$k$只跟$n$的因数有关。要快速的算出“快乐值”，我们可以用等差数列求和公式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">LL a[<span class="number">100010</span>],tot,ans[<span class="number">100100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)</span><br><span class="line">      <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        a[++tot]=i,a[++tot]=n/i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)        </span><br><span class="line">      ans[i]=(<span class="number">1</span>+(n-a[i]+<span class="number">1</span>))*(n/a[i])/<span class="number">2</span>; <span class="comment">//等差数列求和公式</span></span><br><span class="line">    sort(ans+<span class="number">1</span>,ans+tot+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pos=unique(ans+<span class="number">1</span>,ans+tot+<span class="number">1</span>)-ans<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=pos;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元旦快乐</title>
      <link href="/2018/12/31/happy2019/"/>
      <url>/2018/12/31/happy2019/</url>
      <content type="html"><![CDATA[<h2 id="祝福"><a href="#祝福" class="headerlink" title="祝福"></a>祝福</h2><p>$2019$来临，<strong>祝大家元旦快乐！在新的一年里能心想事成，AK所有比赛！</strong></p><h2 id="新年计划"><a href="#新年计划" class="headerlink" title="新年计划"></a>新年计划</h2><p>新年新气象，也要有新目标。现在先把$flag$插在这里。</p><ol><li>过年之前不学新算法。<br>目前我最大的问题是<strong>基础比较薄弱</strong>，所以过年之前要巩固基础，<strong>尤其是DP</strong>，码力也要着重培养一下。</li><li>努力刷题，为$Noip2019$做好准备</li><li>过年之后不断学习并及时巩固</li><li>关于<del>颓废</del>博客<br>感觉只是$OI$的$Blog$有些无趣，所以打算在博客里也写一些<del>颓废</del>好玩的东西。<br>具体是什么还没想好，不过应该会有的……（咕咕警告）</li></ol><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>$Noip2019$过后，兄弟们都走散了……<br>也是，就像濛哥说的，<strong>人各有志</strong>。</p><p>希望我能在$OI$的路上走得远一些吧！<br>不要辜负自己的期望。</p>]]></content>
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZJOI2004 午餐</title>
      <link href="/2018/12/21/zjoj2005-wc/"/>
      <url>/2018/12/21/zjoj2005-wc/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1273" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>嗯……我承认我看了题解，不过好歹有了点自己的思路，大约蒙出来了$30\%$（个人感觉）……</p><p>学会$DP$，任重而道远啊!</p><hr><h3 id="Step1-贪心排序"><a href="#Step1-贪心排序" class="headerlink" title="Step1.贪心排序"></a>Step1.贪心排序</h3><p>先将每个人按<strong>吃饭的快慢</strong>排序，然后再进行$DP$<br>稍微证明一下这个贪心吧</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设两个人排队和吃饭的时间分别为$a_1,b_1$和$a_2,b_2$， 且$b_1 &gt; b_2$，那么$1$同学在前时，所花费的总时间为$(a_1+b_1)+(a_2+b_2-b_1)$（因为$1$同学吃饭的时间和$2$同学打饭并吃饭的时间是重叠的，所以要减去）<br>化简后为$a_1+a_2+b_2$<br>同理，如果$2$同学在前，总时间为$a_1+a_2+b_1$<br>因为$b_1 &gt; b_2$，所以$1$同学在前时花费的总时间少  </p><p>当然，如果$b_1 \geq a_2+b_2$时，$(a_1+b_1)+(a_2+b_2-b_1)$化简后应为$a_1+b_1$（因为不可能存在负数时间）<br>但即使这样，$1$同学在前仍然更优，因为$a_1+b_1$显然$&lt;a_1+a_2+b_1$</p><h3 id="Step2-DP"><a href="#Step2-DP" class="headerlink" title="Step2.DP"></a>Step2.DP</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>设<code>f[i][j]</code>表示前$i$个人在$1$号窗口排队打饭的时间为$j$时，吃完饭的时间  </p><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><ul><li>当第$i$个人在$1$号窗口打饭时<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p[i].a&lt;=j) f[i][j]=min(f[i][j],max(f[i<span class="number">-1</span>][j-p[i].a],j+p[i].b));</span><br></pre></td></tr></table></figure></li></ul><p>因为全部吃完饭的时刻为最后一个人吃完饭的时刻，即$max(\text{i同学打完饭的时间+i同学吃饭的时间})$，而新加进来的这名同学有可能是最后一个吃完的，所以要<code>max(f[i-1][j-p[i].a],j+p[i].b))</code>，即在加这位同学之前的最晚时间和这位同学吃完饭的时间中取一个最大值。</p><ul><li>当第$i$个人在$2$号窗口打饭时<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j]=min(f[i][j],max(f[i<span class="number">-1</span>][j],suma[i]-j+p[i].b));</span><br></pre></td></tr></table></figure></li></ul><p>$max$函数同理，<code>suma[i]</code>表示前$i$位同学打饭所花的时间</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>, c=getchar();</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">&#125;p[<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zzz x,zzz y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.b &gt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">210</span>][<span class="number">40010</span>],f2[<span class="number">210</span>],ti[<span class="number">210</span>][<span class="number">210</span>],suma[<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  p[i].a=read(),p[i].b=read();</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  suma[i]=suma[i<span class="number">-1</span>]+p[i].a;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">127</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=suma[i];j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i].a&lt;=j) f[i][j]=min(f[i][j],max(f[i<span class="number">-1</span>][j-p[i].a],j+p[i].b));</span><br><span class="line">f[i][j]=min(f[i][j],max(f[i<span class="number">-1</span>][j],suma[i]-j+p[i].b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=suma[n];i++)</span><br><span class="line">  ans=min(ans,f[n][i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Educational Codeforces Round 56 (Rated for Div. 2)</title>
      <link href="/2018/12/17/ecf-r50-2/"/>
      <url>/2018/12/17/ecf-r50-2/</url>
      <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1093" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><p>感觉这次$CF$的$C$题好简单，做出$3$道题+全部$AC$，涨了29分，摆脱$pupil$，指日可待！</p><hr><h3 id="A-Dice-Rolling"><a href="#A-Dice-Rolling" class="headerlink" title="$A.Dice\;Rolling$"></a>$A.Dice\;Rolling$</h3><p>这道题最大的难度在理解题意上，只要输出合法的方案即可，所以不要想得太复杂。<br>我们可以发现，除了$0,1$以外，任何自然数都可以用$2,3$的和表示出来，那我们直接将点数$/2$，就好了，相当于我们我们只用$2,3$来投出那个数。<br>这么简单，代码就不放了。</p><h3 id="B-Letters-Rearranging"><a href="#B-Letters-Rearranging" class="headerlink" title="$B.Letters\;Rearranging$"></a>$B.Letters\;Rearranging$</h3><p>题意很简单，让你打乱一个字符串，使打乱后的字符串不为回文串，无解输出$-1$。<br>直接$sort$字符串，排完序再检查一遍是否为回文串(其实没必要单独再扫一遍，直接判断第一个字符和最后一个字符是否相等即可)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        k=k*<span class="number">10</span>+c<span class="number">-48</span>; c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=read();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">string</span> s; <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        sort(s.begin(),s.end()); <span class="comment">//sort大法好</span></span><br><span class="line">        <span class="keyword">int</span> len=s.size()<span class="number">-1</span>; <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=s[len-i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="C-Mishka-and-the-Last-Exam"><a href="#C-Mishka-and-the-Last-Exam" class="headerlink" title="$C.Mishka\;and\;the\;Last\;Exam$"></a>$C.Mishka\;and\;the\;Last\;Exam$</h3><p>这可能是我做过的除了<a href="https://morslin.github.io/2018/08/18/cf-r504-12/#sf-C-Bracket-Subsequence">这道题</a>以外的最简单的$C$题了</p><p>有一个长度为 $n$（$n$ 为偶数）的数列 $a_{1..n}$和长度为$\frac n 2$的数列$b$</p><script type="math/tex; mode=display">a_i\le a_{i+1}(1\le i<n)\;,\; b_j=a_j+a_{n-j+1}(1\le j \le \frac n 2 )</script><p>现在告诉你 $n$和数列$b$，请求出任意一组 $a_{1..n}$ (保证有解)</p><p>可以贪心的将$b$拆分成一个满足条件的尽量小的数和满足条件的尽量大的数。那$a_i$最好等于$a_{i-1}$，$a_{n-i+1}$最好等于$a_{n-i+2}$，但情况并不总是这么完美，那我们只要保证满足其中一个条件就好了，可以发现，这么做是一定有解的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        k=k*<span class="number">10</span>+c<span class="number">-48</span>; c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line">LL a[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) a[i]=read();</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>,ans[n+<span class="number">1</span>]=<span class="number">1000000000000000001L</span>L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]-ans[i<span class="number">-1</span>]&lt;=ans[n-i+<span class="number">2</span>])&#123;</span><br><span class="line">    ans[i]=ans[i<span class="number">-1</span>],ans[n-i+<span class="number">1</span>]=a[i]-ans[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ans[n-i+<span class="number">1</span>]=ans[n-i+<span class="number">2</span>],ans[i]=a[i]-ans[n-i+<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="D-Beautiful-Graph"><a href="#D-Beautiful-Graph" class="headerlink" title="$D.Beautiful\;Graph$"></a>$D.Beautiful\;Graph$</h3><p>当时并不会做，看题解后恍然大悟。</p><p>因为只能标$1,2,3$三个数，且相连的两个点加起来必须为奇数，那么只有这两种情况$1-2\;,\;3-2$。我们可以发现，当这个图中存在一个长度为奇数的环的时候是肯定无解的，换句话说，<strong>当且仅当这张图是一张二分图的时候有解</strong>。</p><p>这就启发我们了，当有解的时候，我们还可以发现，当一个点 点权为$2$且每有一条出边的时候，当前的方案数是要$\times 2$的，因为$2$可以连$1$或$3$；反之，方案数不变，因为$1,3$只能去连$2$。</p><p>到这里，思路就很清晰了，对于每一个连通块，我们跑一遍二分图染色，记录下两部分的点的个数，分别计为$s_1,s_2$，那么这个连通块的方案数为$2^{s_1}+2^{s_2}$(因为起始点既可以标$1$或$3$，也可以标$2$，这两种方案会导致标$2$的点发生变化，所以要将方案数相加)，再将每个连通块的方案数相乘就好了(乘法原理)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,nex;</span><br><span class="line">&#125;e[<span class="number">300010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">300010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">300010</span>];</span><br><span class="line">LL sum[<span class="number">5</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[e[i].t]==<span class="number">-1</span>)&#123;</span><br><span class="line">            vis[e[i].t]=(vis[x]^<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!dfs(e[i].t)) <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[e[i].t]==vis[x])</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[vis[x]]++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">qpow</span><span class="params">(LL b,LL p)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ans=(ans*b)%mod;</span><br><span class="line">        b=(b*b)%mod;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>,c=getchar();</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t=read();</span><br><span class="line">    qwq:</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        ans=<span class="number">1</span>; tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=read(),m=read();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) vis[i]=<span class="number">-1</span>,head[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">            add(x,y); add(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum[<span class="number">0</span>]=sum[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(i))&#123;</span><br><span class="line">                    flag=<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">goto</span> qwq;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  ans=(ans*(((qpow(<span class="number">2</span>,sum[<span class="number">0</span>]))%mod+qpow(<span class="number">2</span>,sum[<span class="number">1</span>]))%mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2009 道路游戏</title>
      <link href="/2018/12/17/noip2009-dlyx/"/>
      <url>/2018/12/17/noip2009-dlyx/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1070" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>爆肝$DP$！</p><hr><p>虽然看数据范围，$O(n^3)$显然过不了，但是数据很水，$O(n^3)$不仅能过，而且时限还绰绰有余。</p><h3 id="定义状态"><a href="#定义状态" class="headerlink" title="定义状态"></a>定义状态</h3><p><code>f[i]</code>表示前$i$个时间最多能获得多少金币</p><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>很显然，一层循环$i$枚举时间，一层循环$j$枚举道路，还有一层循环$k$枚举上一个机器人走了几步。  </p><p><code>f[i]=max(f[i-k]+sum-cost[i-k])</code><br>其中$sum$是上一步从$(j-k)$号工厂到$j$号工厂获得的金币数量</p><p>稍微难处理一点的就是怎么计算$sum$。<br>我们可以在枚举步数的时候顺便更新下一步所用到的金币数量，这样比较方便+容易理解</p><p>另外要注意的一点是<strong>$1$号工厂是和$n$号工厂相连的</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">c=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>, c=getchar();</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mon[<span class="number">1010</span>][<span class="number">1010</span>],<span class="built_in">cos</span>[<span class="number">1010</span>],f[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read(),p=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    mon[i][j]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cos</span>[i]=read();</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">1000</span>,<span class="keyword">sizeof</span>(f)); f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//因为金币可以为负，所以初始化为一个极小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=(j<span class="number">-1</span>)&lt;=<span class="number">0</span>? n:j<span class="number">-1</span>; <span class="comment">//1号工厂和n号工厂相连</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;=<span class="number">0</span>) pos=n;</span><br><span class="line">    <span class="keyword">int</span> sum=mon[pos][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=min(i,p);k++)&#123;</span><br><span class="line">    f[i]=max(f[i],f[i-k]+sum-<span class="built_in">cos</span>[pos]);</span><br><span class="line">    pos=(pos<span class="number">-1</span>)&lt;=<span class="number">0</span>? n:pos<span class="number">-1</span>;</span><br><span class="line">  sum+=mon[pos][i-k];  <span class="comment">//更新金币数量</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>登峰造极境</title>
      <link href="/2018/11/08/IGNB/"/>
      <url>/2018/11/08/IGNB/</url>
      <content type="html"><![CDATA[<blockquote><p>攀越最高的峰，创造属于我们的极境</p></blockquote><p>$\mathfrak{iG}$夺冠已经过去四天了<br><strong>恭喜iG，iGNB</strong></p><p>那一刻，金雨天降<br>那一刻，骄傲的呐喊：<strong>我们，是冠军！</strong><br>那一刻，全国各地都在欢呼：<strong>iGNB</strong></p><hr><p>在之前，$\mathcal{iG}$被人忽视，所有人目光聚集之处，皆是$\mathtt{RNG}$<br>$\mathtt{RNG}$却因轻敌自大而止步八强……  </p><p>全国人的目光，终于聚集到了$\mathcal{iG}$的身上！</p><p>而$\mathcal{iG}$也不负众望，零封$G2,FNC$</p><p><strong>此刻，冠军是属于他们的！</strong></p><p><strong>初心不改，静水流深</strong></p><hr><p>$\mathcal{NOip}$在即，愿$\mathcal{OIer}$们也能<strong>登峰造极境，创造属于我们的传奇！</strong></p>]]></content>
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HAOI2008 硬币购物</title>
      <link href="/2018/11/08/haoi2008-ybgw/"/>
      <url>/2018/11/08/haoi2008-ybgw/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1450" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>据说$NOIp$前写题解会$\mathcal{RP}$++</p><hr><p>看数据范围，肯定不能写多重背包，会$T$飞~<br>如果每种硬币没有个数限制，就可以用完全背包了。</p><p>正难则反，我们可以先用完全背包预处理，然后减去不合法的情况。不合法的情况就是一个$s-(d+1) \times c$的背包<br>但如果我们直接减去，会导致重复计算。比如我们减去第一种超的和第二种超的，第一种和第二种都超的就被减了两次。所以要再容斥一波<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[<span class="number">100010</span>],c[<span class="number">5</span>],d[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++) c[i]=read();</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1L</span>L;  <span class="comment">//完全背包预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=c[i];j&lt;=<span class="number">100001</span>;j++)</span><br><span class="line">    f[j]+=f[j-c[i]];</span><br><span class="line"><span class="keyword">int</span> t=read();</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++) d[i]=read();</span><br><span class="line"><span class="keyword">int</span> s=read(); ans=f[s];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)&#123;  <span class="comment">//用子集枚举来容斥</span></span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>,num=s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">  <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">num-=(d[j]+<span class="number">1</span>)*c[j],++flag; <span class="comment">//减去不合法情况</span></span><br><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">0</span>)  <span class="comment">//容斥:奇减偶加</span></span><br><span class="line">  <span class="keyword">if</span>(flag&amp;<span class="number">1</span>) ans-=f[num];</span><br><span class="line">  <span class="keyword">else</span> ans+=f[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P3801 红色的幻想乡</title>
      <link href="/2018/11/08/luogu-p3801-hsdhxx/"/>
      <url>/2018/11/08/luogu-p3801-hsdhxx/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3801" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>据说$NOIp$前写题解可以$\mathtt{RP}$++</p><hr><h3 id="20pts"><a href="#20pts" class="headerlink" title="20pts"></a>20pts</h3><p><strong>我会暴力！</strong></p><h3 id="40pts"><a href="#40pts" class="headerlink" title="40pts"></a>40pts</h3><p><strong>我会二维树状数组（线段树）！</strong></p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p>$n,m,q&lt;=100000$，二维肯定会炸。考虑每次修改都是修改一整行和一整列，可以分别对行和列建线段树，统计区间内有多少行、列被放过红雾。<br>因为我们用线段树统计了有多少行、列被修改过，但询问的是有多少点有红雾，所以答案应为$x\times len_n+y\times len_m$，其中x，y表示区间内有红雾的行、列数，$len$表示对应的区间长度。<br>但这么做肯定是不对的，因为行列的交点被我们算了两次，而它们应该没有红雾。所以我们应用容斥原理，将它们减去就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span>  <span class="comment">//线段树统计有红雾的行、列</span></span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p]^=<span class="number">1</span>; <span class="keyword">return</span> ;  <span class="comment">//因为在已经有红雾的行和列上放红雾会全部抵消，所以是xor操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=mid) update(l,mid,ls,pos);</span><br><span class="line"><span class="keyword">else</span> update(mid+<span class="number">1</span>,r,rs,pos);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;hang,lie;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>, c=getchar();</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read(),q=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> opt=read();</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">hang.update(<span class="number">1</span>,n,<span class="number">1</span>,x);</span><br><span class="line">lie.update(<span class="number">1</span>,n,<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">LL a=read(),b=read(),c=read(),d=read();</span><br><span class="line">LL hh=hang.query(<span class="number">1</span>,n,<span class="number">1</span>,a,c);</span><br><span class="line">LL ll=lie.query(<span class="number">1</span>,n,<span class="number">1</span>,b,d);</span><br><span class="line">LL ans=hh*(d-b+<span class="number">1</span>)+ll*(c-a+<span class="number">1</span>)<span class="number">-2</span>*hh*ll;  <span class="comment">//如上文式子所说，有红雾的行列数*行列长度-交点*2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容斥 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>USACO09FEB Fair Shuttle</title>
      <link href="/2018/11/08/usaco09feb-fs/"/>
      <url>/2018/11/08/usaco09feb-fs/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1607" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>据说$NOIp$前写题解可以$\mathfrak{RP}$++</p><hr><p>因为要尽可能满足更多奶牛，所以按照这种区间贪心题的套路，先按右端点排序，然后依次遍历，能坐车的就让它们坐车，这样一定是最优的。<br>在贪心的时候，我们要知道在车在当前的时间段中最少有多少空位，可以用线段树维护（也可以不用线段树，但个人感觉用线段树比较好理解）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>,c=getchar();</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> st,en,num;</span><br><span class="line">&#125;cow[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zzz x,zzz y)</span></span>&#123; <span class="comment">//按右端点排序</span></span><br><span class="line"><span class="keyword">return</span> x.en &lt; y.en;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">20010</span>&lt;&lt;<span class="number">2</span>],tag[<span class="number">20010</span>&lt;&lt;<span class="number">2</span>];  <span class="comment">//以下为线段树维护区间最大值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[ls]+=tag[p]; tree[rs]+=tag[p];</span><br><span class="line">tag[ls]+=tag[p]; tag[rs]+=tag[p];</span><br><span class="line">tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p]=max(tree[ls],tree[rs]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line">tree[p]+=k; tag[p]+=k; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) ans=max(ans,query(l,mid,ls,nl,nr));</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) ans=max(ans,query(mid+<span class="number">1</span>,r,rs,nl,nr));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=read(),n=read(),c=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">  cow[i].st=read(),cow[i].en=read()<span class="number">-1</span>,cow[i].num=read();</span><br><span class="line">sort(cow+<span class="number">1</span>,cow+k+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;  <span class="comment">//遍历区间</span></span><br><span class="line"><span class="keyword">int</span> x=query(<span class="number">1</span>,n,<span class="number">1</span>,cow[i].st,cow[i].en);</span><br><span class="line"><span class="keyword">if</span>(x&lt;c)&#123;</span><br><span class="line"><span class="keyword">int</span> f=min(c-x,cow[i].num);  <span class="comment">//当前能有几头奶牛上车</span></span><br><span class="line">maxn+=f;</span><br><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,cow[i].st,cow[i].en,f);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxn;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2017 宝藏</title>
      <link href="/2018/11/06/noip2017-bz/"/>
      <url>/2018/11/06/noip2017-bz/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3959" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>感觉这个题被玩坏了……<br>翻看了一下题解区，发现了$N$种神仙做法：  </p><ol><li>随机化搜索(伪模拟退火)</li><li>搜索+剪枝  </li><li>模拟退火</li><li>不对但是能A的状压$DP$</li><li>正确的状压$DP$<br>其中$DP$又分用$DFS$的$DP$，不用$DFS$的$DP$，而且各种$DP$的时间复杂度也各不相同……  </li></ol><p>我还有什么话可说呢？</p><hr><blockquote><p>学习科学，使用玄学<br>——zhx</p></blockquote><p>既然标签上都写了搜索和随机化了，那我们肯定要用第一种神仙做法<del>(其实是因为我看不懂状压DP)</del></p><p>这里的随机化用到了一点模拟退火的思想，以一定的概率去接受新的连边方式，这个概率是随着$n$的上升而增大的<br>为了寻找最优解，我们可以让它多跑几遍，取最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">15</span>][<span class="number">15</span>],deth[<span class="number">15</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> f,t;</span><br><span class="line">&#125;pass[<span class="number">1010</span>]; <span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (struct zzz a,struct zzz b)&#123;</span><br><span class="line"><span class="keyword">return</span> deth[a.f]*g[a.f][a.t] &gt; deth[b.f]*g[b.f][b.t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue &lt;zzz&gt; q;</span><br><span class="line"><span class="keyword">int</span> cost=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//将一开始的边入堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">if</span>(g[s][i]&lt;inf)</span><br><span class="line">    q.push(zzz&#123;s,i&#125;);</span><br><span class="line"><span class="comment">//因为要多加(n-1)条边,所以循环到n-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">zzz e=q.top(); q.pop();</span><br><span class="line"><span class="keyword">while</span>(!q.empty()&amp;&amp;(vis[e.t]||(rand()%n&lt;<span class="number">1</span>)))&#123; <span class="comment">//随机找边</span></span><br><span class="line"><span class="keyword">if</span>(!vis[e.t]) pass[++top]=e;  <span class="comment">//跳过的边仍然可能用到,先将它们存起来</span></span><br><span class="line">e=q.top(); q.pop();  <span class="comment">//随机一条新边</span></span><br><span class="line">&#125;</span><br><span class="line">vis[e.t]=<span class="number">1</span>; deth[e.t]=deth[e.f]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)  <span class="comment">//将之前跳过的边在怼进堆里</span></span><br><span class="line">  q.push(pass[i]);</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">if</span>(g[e.t][i]&lt;inf&amp;&amp;!vis[i])  <span class="comment">//扩展新的边</span></span><br><span class="line">q.push(zzz&#123;e.t,i&#125;);</span><br><span class="line">cost+=g[e.f][e.t]*deth[e.f];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>, c=getchar();</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">srand(<span class="number">19</span>****<span class="number">17</span>); <span class="comment">//打码保平安</span></span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;  <span class="comment">//因为点少边多,使用邻接矩阵存图更为方便</span></span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">g[x][y]=g[y][x]=min(g[x][y],read());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i++)  <span class="comment">//为寻找最优解,多跑几遍</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  <span class="comment">//枚举根节点</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">memset</span>(deth,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(deth));</span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">  deth[i]=vis[i]=<span class="number">1</span>; top=<span class="number">0</span>;</span><br><span class="line">  ans=min(ans,bfs(i))</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考资料<br><a href="https://www.luogu.org/blog/SkeletonSerpent/solution-p3959" target="_blank" rel="noopener">题解 P3959【宝藏】</a>——EternalAlexander</li></ul>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P4996 咕咕咕</title>
      <link href="/2018/11/05/luogu-p4996-ggg/"/>
      <url>/2018/11/05/luogu-p4996-ggg/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4996" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>题目名字真是十分契合Luogu的性质啊</p><p><strong>IG NB</strong></p><hr><p>$3^n$的子集枚举不会……看了题解后只会正解</p><p>对于每个状态，其实对我们有用的只有这个状态中有多少个$1$，而$1$的位置我们并不关心，因为具有相同个数个$1$的状态，它们出现的次数一定是相同的。</p><p>所以我们考虑用<code>dp[i]</code>表示有$i$个$1$的方案数，因为我们可以一步一步的填$1$，所以<code>dp[i]=dp[i]+dp[i-j]*c[i][j]</code>，其中<code>c[i][j]</code>表示$C^j_i$，即$dp[i]=\sum\limits_{j=1}^{i} dp[i-j] \cdot C^j_i$<br>有了上面的式子，我们预处理组合数和$dp[i]$就好了</p><p>一定要多取模，不然会炸。 <em>十年OI一场空，忘掉取模见祖宗</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL c[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line">LL dp[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">    c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">dp[i]=(dp[i]+(dp[i-j]*c[i][j])%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>) c=getchar();</span><br><span class="line"><span class="keyword">return</span> c<span class="number">-48</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL cnt,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">  <span class="keyword">if</span>(read()) cnt++;</span><br><span class="line">LL k; <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">ans=(ans+(((k*dp[cnt])%mod)*dp[n-cnt])%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2014 解方程</title>
      <link href="/2018/11/05/noip2014-jfc/"/>
      <url>/2018/11/05/noip2014-jfc/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2312" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>第一次用秦九韶公式，有点小激动<del>(然而并不)</del></p><hr><p>可以很暴力的从$1$到$m$依次代数。因为用了秦九韶，计算一次是$O(n)$的，总复杂度$O(nm)$。<br>高精其实没什么必要，我们直接模一个大质数来判断就可以。当它们在模$p$意义下为$0$，就认为原式为$0$，因为懒，我只用了一个质数。保险起见，建议使用$\geq2$个质数<br>为了读入$a$，强制使用快读，读入时取模<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7ffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar();</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;LL k=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=gc;<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>)f=<span class="number">-1</span>;c=gc;&#125;<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))&#123;k=(k*<span class="number">10</span>+c<span class="number">-48</span>)%mod;c=gc;&#125;<span class="keyword">return</span> k*f;&#125;</span><br><span class="line">LL a[<span class="number">110</span>],n,m;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;  <span class="comment">//秦九韶</span></span><br><span class="line">LL sum=a[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  sum=(sum*x+a[i<span class="number">-1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000010</span>],top;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!calc(i)) ans[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,top);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2014 飞扬的小鸟</title>
      <link href="/2018/11/05/noip2014-flappy-bird/"/>
      <url>/2018/11/05/noip2014-flappy-bird/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1941" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>我小黄鸟表示不服<br><img src="https://s1.ax2x.com/2018/11/05/5mM40H.th.png" alt="可爱的小黄鸟 qwq"></p><hr><p>这个题能转换成背包也是很神了……</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>f[i][j]</code>表示到坐标$(i,j)$的最少点击次数，若无法到达，则置为$inf$</p><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>以下代码片段可能比较迷乱……</p><ul><li><p>预处理<br>因为可以从第一列任何地方开始所以第一列都是$0$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>上升<br>上升有可能是从前一列飞到这当前列(点了一次)，也有可能是在当前列点了好几次，可以把它看成完全背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=jum[i].x;j&lt;=jum[i].x+m;j++)</span><br><span class="line">    dp[i][j]=min(dp[i<span class="number">-1</span>][j-jum[i].x],dp[i][j-jum[i].x])+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上升还要注意特判飞到顶部的情况，因为飞到顶部就不能再向上飞了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m+<span class="number">1</span>;j&lt;=jum[i].x+m;j++)</span><br><span class="line">    dp[i][m]=min(dp[i][m],dp[i][j]);</span><br></pre></td></tr></table></figure></li><li><p>下降<br>下降就只可能是从前一列掉下来的，也就是说在同一列只能下降一次，可以把它看成$01$背包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m-jum[i].y;j++)</span><br><span class="line">    dp[i][j]=min(dp[i][j],dp[i<span class="number">-1</span>][j+jum[i].y]);</span><br></pre></td></tr></table></figure></li><li><p>无法通过<br>也就是管子，赋值为$inf$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;low[i];j++) dp[i][j]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;high[i];j--) dp[i][j]=inf;</span><br></pre></td></tr></table></figure></li></ul><p>剩下要注意的就是输出了，其实也没什么要注意的，会了$DP$,剩下的都好说……(<del><strong>但我就是不会DP！！！</strong></del>)</p><h3 id="tt-code"><a href="#tt-code" class="headerlink" title="$\tt{code}$"></a>$\tt{code}$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7ffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gc getchar();</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> k=<span class="number">0</span>;<span class="keyword">char</span> c=gc;<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))c=gc;<span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))&#123;k=k*<span class="number">10</span>+c<span class="number">-48</span>;c=gc;&#125;<span class="keyword">return</span> k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_c</span><span class="params">()</span></span>&#123;<span class="keyword">int</span> k=<span class="number">0</span>;<span class="keyword">char</span> c=gc;<span class="keyword">while</span>(c&lt;<span class="string">'a'</span>||c&gt;<span class="string">'z'</span>)c=gc;<span class="keyword">return</span> c-<span class="string">'a'</span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;jum[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> high[<span class="number">10010</span>],low[<span class="number">100010</span>],flag[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),k=read();</span><br><span class="line">    <span class="comment">//=======处理信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      jum[i].x=read(),jum[i].y=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) low[i]=<span class="number">1</span>, high[i]=m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=read(),l=read(),h=read();</span><br><span class="line">        flag[p]=<span class="number">1</span>; low[p]=l+<span class="number">1</span>; high[p]=h<span class="number">-1</span>;;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">127</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//======DP主体</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=jum[i].x;j&lt;=jum[i].x+m;j++)</span><br><span class="line">          dp[i][j]=min(dp[i<span class="number">-1</span>][j-jum[i].x],dp[i][j-jum[i].x])+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m+<span class="number">1</span>;j&lt;=jum[i].x+m;j++)</span><br><span class="line">          dp[i][m]=min(dp[i][m],dp[i][j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m-jum[i].y;j++)</span><br><span class="line">          dp[i][j]=min(dp[i][j],dp[i<span class="number">-1</span>][j+jum[i].y]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;low[i];j++)</span><br><span class="line">          dp[i][j]=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;high[i];j--)</span><br><span class="line">          dp[i][j]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出答案</span></span><br><span class="line">    <span class="keyword">int</span> ans=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=low[n];i&lt;=high[n];i++)</span><br><span class="line">      <span class="keyword">if</span>(dp[n][i]&lt;=<span class="number">100000</span>)</span><br><span class="line">        ans=min(ans,dp[n][i]);</span><br><span class="line">    <span class="keyword">if</span>(ans!=inf)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"1\n%d"</span>,ans);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">bool</span> hhh=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">      <span class="keyword">if</span>(dp[i][j]&lt;=<span class="number">100000</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[i]) ans++;</span><br><span class="line">  hhh=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(!hhh) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P5008 逛庭院</title>
      <link href="/2018/11/05/luogu-p5008-gty/"/>
      <url>/2018/11/05/luogu-p5008-gty/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5008" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>我校神仙出的神仙题 $\%\%\%$</p><hr><h3 id="30分"><a href="#30分" class="headerlink" title="30分"></a>30分</h3><p>找出所有有入度的点，排序，选前$k$个点，好了，30分到手。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100010</span>],sum,in[<span class="number">100010</span>],b[<span class="number">100010</span>],top;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read(),k=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">in[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">if</span>(in[i])  b[++top]=a[i];</span><br><span class="line">sort(b+<span class="number">1</span>,b+top+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) sum+=b[i];</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><del>就这么简单</del><br><del>我跟你讲，这个做法以前是可以AC的</del></p><p>这个做法可以$A$掉$DAG$的$Subtask$<br>因为图是一个$DAG$，所以<strong>对于所有有入度的点，一定可以将它们全部删去</strong>——从后向前删即可。既然所有有入度的点都能删去，我们只要贪心的取出前$k$大就好了。</p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p>对于$DAG$，一定可以将所有有入度的点全部删去，而普通有向图就不一样了——有环的存在<br><img src="https://s1.ax2x.com/2018/11/05/5mMQ8n.png" alt="5mMQ8n.png"><br>如上面$4$个点，它们形成了一个环，我们最多只能删掉$3$个。因为必定会有一个点被留下，所以我们贪心的留下点权最小的点。<br>但对环的讨论是十分繁琐的，我们可以先将整张图用$Tarjan$缩成一张$DAG$，每个强连通分量内一定至少有一个环。对于强连通分量，我们分类讨论一下。  </p><ul><li>对于缩点后有入度的强连通分量，十分显然，它内部的点我们可以随便选</li><li>没有入度的强连通分量，我们必定要留下一个，理由如上所说。同理，我们贪心的留下点权最小的点即可。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int read()&#123;</span><br><span class="line">    int k=0; char c=getchar();</span><br><span class="line">    for(;c&lt;&apos;0&apos;||c&gt;&apos;9&apos;;) c=getchar();</span><br><span class="line">    for(;c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;;c=getchar())</span><br><span class="line">      k=k*10+c-48;</span><br><span class="line">    return k;</span><br><span class="line">&#125;</span><br><span class="line">struct zzz&#123;</span><br><span class="line">    int f,t,nex;</span><br><span class="line">&#125;e[2000010]; int head[500010],tot;</span><br><span class="line">void add(int x,int y)&#123;</span><br><span class="line">    e[++tot].t=y; e[tot].f=x;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line">struct hhh&#123;</span><br><span class="line">    int v,pos;</span><br><span class="line">&#125;a[500010];</span><br><span class="line">int dfn[500010],low[500010],deep,vis[500010],colnum[500010],belong[500010],col,s[500010],top;</span><br><span class="line">void Tarjan(int now)&#123;  //Tarjan缩点</span><br><span class="line">    dfn[now]=low[now]=++deep; s[++top]=now; vis[now]=1;</span><br><span class="line">    for(int i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        if(!dfn[e[i].t])&#123;</span><br><span class="line">            Tarjan(e[i].t);</span><br><span class="line">            low[now]=min(low[now],low[e[i].t]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[e[i].t])</span><br><span class="line">          low[now]=min(low[now],dfn[e[i].t]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[now]==low[now])&#123;</span><br><span class="line">        col++;</span><br><span class="line">        int v=0;</span><br><span class="line">        do&#123;</span><br><span class="line">            v=s[top--];</span><br><span class="line">            vis[v]=0;</span><br><span class="line">            colnum[col]++;</span><br><span class="line">            belong[v]=col;</span><br><span class="line">        &#125;while(v!=now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int in[500010],ans;</span><br><span class="line">bool cmp(hhh x,hhh y)&#123;</span><br><span class="line">    return x.v &lt; y.v;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp2(hhh x,hhh y)&#123;</span><br><span class="line">    return x.v &gt; y.v;</span><br><span class="line">&#125;</span><br><span class="line">bool flag[500010],mapp[500010];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n=read(),m=read(),k=read();</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      a[i].v=read(), a[i].pos=i;</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int x=read(),y=read();</span><br><span class="line">        add(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">      if(!dfn[i]) Tarjan(i);</span><br><span class="line">    memset(head,0,sizeof(head));</span><br><span class="line">    for(int i=1;i&lt;=tot;i++)&#123;  //缩点之后处理入度</span><br><span class="line">        if(belong[e[i].f]!=belong[e[i].t])</span><br><span class="line">          ++in[belong[e[i].t]];</span><br><span class="line">    &#125;</span><br><span class="line">    //=======剔除入度为0的强联通分量里点权最小的点</span><br><span class="line">    sort(a+1,a+n+1,cmp);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!in[belong[a[i].pos]]&amp;&amp;!flag[belong[a[i].pos]])&#123;</span><br><span class="line">            flag[belong[a[i].pos]]=1;</span><br><span class="line">            mapp[a[i].pos]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    //=======贪心的从大到小选点</span><br><span class="line">    sort(a+1,a+n+1,cmp2);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(cnt==k) break;</span><br><span class="line">        if(mapp[a[i].pos]) continue;</span><br><span class="line">        ans+=a[i].v; cnt++; </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文章的最后,放一下<a href="https://www.luogu.org/blog/fusu2333/ibvl-zhan-dui-di-mo-ni-sai-ti-xie-c" target="_blank" rel="noopener">官方题解</a>，233~~~</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1471 方差</title>
      <link href="/2018/11/05/luogu-p1471-fc/"/>
      <url>/2018/11/05/luogu-p1471-fc/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1471" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>开了<strong>十倍空间</strong>才过是什么鬼？该不会我线段树炸了吧……<br><em>细思极恐</em></p><hr><p>平均数都会求，维护区间和，到时候除一下就好了。</p><p>方差的求法如下<br><img src="https://cdn.luogu.org/upload/pic/2264.png" alt="">(用的Luogu的图片)<br>因为要维护一个平方，我们可以考虑使用<del>van♂</del>完全平方公式将它拆开，这样只用线段树维护区间和和区间平方和就可以了。<br>对于区间修改，同样使用完全平方公式。</p><p>要注意的一点是，修改时，要先修改平方和，再修改和，因为我们修改平方和时要用到区间和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> sum,pf;</span><br><span class="line">&#125;tree[<span class="number">1000010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> tag[<span class="number">1000010</span>&lt;&lt;<span class="number">2</span>],a[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">tree[p].pf=tree[ls].pf+tree[rs].pf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].sum=a[l];</span><br><span class="line">tree[p].pf=a[l]*a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="comment">//用完全平方公式修改平方和</span></span><br><span class="line">tree[ls].pf+=<span class="number">2</span>*tree[ls].sum*tag[p]+tag[p]*tag[p]*(mid-l+<span class="number">1</span>);</span><br><span class="line">tree[rs].pf+=<span class="number">2</span>*tree[rs].sum*tag[p]+tag[p]*tag[p]*(r-mid);</span><br><span class="line"><span class="comment">//维护区间和</span></span><br><span class="line">tree[ls].sum+=tag[p]*(mid-l+<span class="number">1</span>);</span><br><span class="line">tree[rs].sum+=tag[p]*(r-mid);</span><br><span class="line">tag[ls]+=tag[p]; tag[rs]+=tag[p]; tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">double</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line">tree[p].pf+=<span class="number">2</span>*tree[p].sum*k+k*k*(r-l+<span class="number">1</span>);</span><br><span class="line">tree[p].sum+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">tag[p]+=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p].sum;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p].pf;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) ans+=query2(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) ans+=query2(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i]);</span><br><span class="line">build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> opt=read(),l=read(),r=read();</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> k; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;k);</span><br><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,query(<span class="number">1</span>,n,<span class="number">1</span>,l,r)/(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> sum=query(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">double</span> pj=sum/(r-l+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">double</span> pf=query2(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>,(pf<span class="number">-2</span>*sum*pj+pj*pj*(r-l+<span class="number">1</span>))/(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>USACO08FEB Hotel</title>
      <link href="/2018/11/02/usaco08feb-hotel/"/>
      <url>/2018/11/02/usaco08feb-hotel/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><hr><p>线段树维护区间</p><ul><li><p>线段树结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">    <span class="comment">//l为以左端点的为起点的最长子串</span></span><br><span class="line">    <span class="comment">//r为以右端点为终点的最长子串</span></span><br><span class="line">    <span class="comment">//mi是区间内部的最长子串</span></span><br><span class="line">&#125;tree[<span class="number">50010</span>&lt;&lt;<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li><li><p>合并<br>合并的时候要考虑左右区间互拼的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].l==mid-l+<span class="number">1</span>)</span><br><span class="line">  tree[p].l=tree[ls].l+tree[rs].l;</span><br><span class="line"><span class="keyword">else</span> tree[p].l=tree[ls].l;</span><br><span class="line"><span class="keyword">if</span>(tree[rs].r==r-mid)</span><br><span class="line">  tree[p].r=tree[rs].r+tree[ls].r;</span><br><span class="line"><span class="keyword">else</span> tree[p].r=tree[rs].r;</span><br><span class="line">tree[p].mi=max(max(tree[ls].mi,tree[rs].mi),tree[ls].r+tree[rs].l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>询问<br>因为要查找最左的房间，所以尽量向左找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].mi&gt;=k) <span class="keyword">return</span> query(l,mid,ls,k);</span><br><span class="line"><span class="keyword">if</span>(tree[ls].r+tree[rs].l&gt;=k) <span class="keyword">return</span> mid-tree[ls].r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(mid+<span class="number">1</span>,r,rs,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最核心的就是这几个函数了，别的函数基本没有变化，直接看总代码就好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,mi;</span><br><span class="line">&#125;tree[<span class="number">50010</span>&lt;&lt;<span class="number">2</span>]; <span class="keyword">int</span> tag[<span class="number">50010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].l==mid-l+<span class="number">1</span>)</span><br><span class="line">  tree[p].l=tree[ls].l+tree[rs].l;</span><br><span class="line"><span class="keyword">else</span> tree[p].l=tree[ls].l;</span><br><span class="line"><span class="keyword">if</span>(tree[rs].r==r-mid)</span><br><span class="line">  tree[p].r=tree[rs].r+tree[ls].r;</span><br><span class="line"><span class="keyword">else</span> tree[p].r=tree[rs].r;</span><br><span class="line">tree[p].mi=max(max(tree[ls].mi,tree[rs].mi),tree[ls].r+tree[rs].l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].l=tree[p].r=tree[p].mi=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(l,r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tag[p]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">tree[ls].l=tree[ls].mi=tree[ls].r=(mid-l+<span class="number">1</span>)*tag[p];</span><br><span class="line">tree[rs].l=tree[rs].mi=tree[rs].r=(r-mid)*tag[p];</span><br><span class="line">tag[ls]=tag[rs]=tag[p];</span><br><span class="line">tag[p]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].mi&gt;=k) <span class="keyword">return</span> query(l,mid,ls,k);</span><br><span class="line"><span class="keyword">if</span>(tree[ls].r+tree[rs].l&gt;=k) <span class="keyword">return</span> mid-tree[ls].r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> query(mid+<span class="number">1</span>,r,rs,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line">tree[p].l=tree[p].r=tree[p].mi=k*(r-l+<span class="number">1</span>);</span><br><span class="line">tag[p]=k; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">down(l,r,p);</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">up(l,r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read();</span><br><span class="line"><span class="built_in">memset</span>(tag,<span class="number">-1</span>,<span class="keyword">sizeof</span>(tag));</span><br><span class="line">build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=read();</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> x=read();</span><br><span class="line"><span class="keyword">if</span>(tree[<span class="number">1</span>].mi&lt;x)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos=query(<span class="number">1</span>,n,<span class="number">1</span>,x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pos);</span><br><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,pos,pos+x<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,x,x+y<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> USACO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POI2015 WIL-Wilcze doły</title>
      <link href="/2018/10/30/poi-wwd/"/>
      <url>/2018/10/30/poi-wwd/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3594" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>很不错的一道单调队列神题</p><hr><p>可以发现，当我们向右移动右端点时，左端点也会向右移动或不动。所以我们可以从左向右移动右端点，以上一个区间的左端点作为这个区间的左端点，然后将左端点右移，直到这个区间为一个合法区间。</p><p>为了判断区间是否合法，我们可以维护每个元素的前缀和，从而得到每段长为$d$的区间的和。之后移动左端点时，就可以用这段区间的区间和减去区间内长度为$d$的最大区间和。</p><p>快速求出长度为$d$的最大区间，我们可以用单调队列来维护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line">LL a[<span class="number">2000010</span>],sum[<span class="number">2000010</span>];</span><br><span class="line">LL q[<span class="number">2000010</span>],h=<span class="number">1</span>,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL n=read(),p=read(),d=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read()+a[i<span class="number">-1</span>];  <span class="comment">//前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d;i&lt;=n;i++) sum[i]=a[i]-a[i-d];  <span class="comment">//长度为d,右端点为i的区间和</span></span><br><span class="line"><span class="keyword">int</span> ans=d,last=<span class="number">1</span>; q[++t]=d;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d+<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(sum[q[t]]&lt;sum[i]&amp;&amp;h&lt;=t) --t;  <span class="comment">//维护单调队列</span></span><br><span class="line">q[++t]=i;</span><br><span class="line"><span class="keyword">while</span>(q[h]-d+<span class="number">1</span>&lt;last&amp;&amp;h&lt;=t) ++h;  <span class="comment">//当最大值的左端点不在这个区间里,需要将它出队</span></span><br><span class="line"><span class="keyword">while</span>(h&lt;=t&amp;&amp;a[i]-a[last<span class="number">-1</span>]-sum[q[h]]&gt;p)&#123; <span class="comment">//向右移动左端点,直到区间合法</span></span><br><span class="line">last++;</span><br><span class="line"><span class="keyword">while</span>(q[h]-d+<span class="number">1</span>&lt;last&amp;&amp;h&lt;=t) ++h;  <span class="comment">//随着左端点右移,要时刻注意最大值的合法性</span></span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,i-last+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 国外OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P2073 送花</title>
      <link href="/2018/10/19/luogu-p2073-sh/"/>
      <url>/2018/10/19/luogu-p2073-sh/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2073" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>操作2和操作3<strong>反着</strong>是什么鬼？有点反人类</p><hr><p>权值线段树的模板题</p><p>然而AC后才发现，可以用$\tt{set}$水过……</p><p>权值线段树类似于用线段树来实现平衡树的一些操作，代码实现还是比较方便的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,c;</span><br><span class="line">&#125;tree[<span class="number">1000000</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123; <span class="comment">//合并线段树的信息</span></span><br><span class="line">tree[p].w=tree[ls].w+tree[rs].w;</span><br><span class="line">tree[p].c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].w) tree[p].c+=tree[ls].c;</span><br><span class="line"><span class="keyword">if</span>(tree[rs].w) tree[p].c+=tree[rs].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//初始化线段树</span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].c=l; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> k,<span class="keyword">int</span> f)</span></span>&#123;  <span class="comment">//添加一朵美丽值为f，价格为k的花</span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p].w) <span class="keyword">return</span> ;</span><br><span class="line">tree[p].w=f; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;=mid) add(l,mid,ls,k,f);</span><br><span class="line"><span class="keyword">else</span> add(mid+<span class="number">1</span>,r,rs,k,f);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del1</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//去掉最便宜的花</span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].w=<span class="number">0</span>; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[ls].w) del1(l,mid,ls);</span><br><span class="line"><span class="keyword">else</span> del1(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del2</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//去掉最贵的花</span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].w=<span class="number">0</span>; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[rs].w) del2(mid+<span class="number">1</span>,r,rs);</span><br><span class="line"><span class="keyword">else</span> del2(l,mid,ls);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1000001</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> k=read();</span><br><span class="line"><span class="keyword">while</span>(k!=<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> w=read(),c=read();</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1000001</span>,<span class="number">1</span>,c,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">3</span>) del1(<span class="number">1</span>,<span class="number">1000001</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">2</span>) del2(<span class="number">1</span>,<span class="number">1000001</span>,<span class="number">1</span>);</span><br><span class="line">k=read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tree[<span class="number">1</span>].w&lt;&lt;<span class="string">" "</span>&lt;&lt;tree[<span class="number">1</span>].c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1666 前缀单词</title>
      <link href="/2018/10/14/luogu-p1666-qzdc/"/>
      <url>/2018/10/14/luogu-p1666-qzdc/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1666" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>校内资格赛题目，差点高一就要$\tt{AFO}$了</p><hr><h4 id="30分思路"><a href="#30分思路" class="headerlink" title="30分思路"></a>30分思路</h4><blockquote><p>对30%的数据，满足$1≤n≤10 $</p></blockquote><p>所以我们可以子集枚举，实际得分40pts<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> word[<span class="number">51</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> sa[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%s"</span>,word[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">      <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> leni=<span class="built_in">strlen</span>(word[i]),lenj=<span class="built_in">strlen</span>(word[j]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">0</span>;pos&lt;=min(leni,lenj)<span class="number">-1</span>;pos++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(word[i][pos]!=word[j][pos])&#123;</span><br><span class="line">      flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) sa[i][j]=sa[j][i]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//很奇怪的子集枚举</span></span><br><span class="line">        <span class="keyword">int</span> s[<span class="number">1010</span>],tot=<span class="number">0</span>,top=<span class="number">0</span>,x=i;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;<span class="number">1</span>) s[++top]=tot;</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>; tot++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=top;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(sa[s[i]][s[j]])&#123;</span><br><span class="line">              flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><p>我们先对单词排序，然后预处理出每两个之间是否是安全的，令<code>dp[i]</code>表示前$i$个单词中包含第$i$个单词的子集个数，如果$j&lt;i$并且他们是安全的，<code>dp[i]+=dp[j]</code>。统计答案的时候，将$dp[i]$累加起来就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> word[<span class="number">51</span>];</span><br><span class="line"><span class="keyword">bool</span> sa[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,dp[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;word[i],dp[i]=<span class="number">1</span>;</span><br><span class="line">    sort(word+<span class="number">1</span>,word+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">      <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> leni=word[i].size(),lenj=word[j].size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">0</span>;pos&lt;=min(leni,lenj)<span class="number">-1</span>;pos++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(word[i][pos]!=word[j][pos])&#123;</span><br><span class="line">      flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) sa[i][j]=sa[j][i]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        dp[j]+=sa[i][j]? <span class="number">0</span> : dp[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=dp[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1558 色板游戏</title>
      <link href="/2018/10/13/luogu-p1558-sbyx/"/>
      <url>/2018/10/13/luogu-p1558-sbyx/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1558" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>我继承了上次<a href="https://morslin.github.io/2018/08/03/noi2015-rjbglq/">【NOI2015 软件包管理】</a>的优良传统，超级暴力。洛谷最优解再次倒数……</p><hr><p>因为为这道题只有$30$种颜色，所以我们可以用<strong>30颗线段树</strong>来分别维护每种颜色。<br>涂颜色就将对应颜色的线段树区间染色成$1$，其他的染成$0$。<br>统计颜色就把线段树都枚举一遍，统计在这个区间上有$1$的线段树数量</p><p>思路好想，理论时间复杂度也能过，就是常数大，在洛谷不开$O_2$过不去……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ls p&lt;&lt;1</span><br><span class="line">#define rs p&lt;&lt;1|1</span><br><span class="line">#define mid ((l+r)&gt;&gt;1)</span><br><span class="line">using namespace std;</span><br><span class="line">struct zzz&#123;  //线段树</span><br><span class="line">    int tree[100010&lt;&lt;2],tag[100010&lt;&lt;2];</span><br><span class="line">    void build(int l,int r,int p)&#123;</span><br><span class="line">        if(l==r)&#123;</span><br><span class="line">            tree[p]=1; return ;</span><br><span class="line">        &#125;</span><br><span class="line">        build(l,mid,ls); build(mid+1,r,rs);</span><br><span class="line">        tree[p]=tree[ls]+tree[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    inline void down(int l,int r,int p)&#123;</span><br><span class="line">        if(tag[p]==-1) return ;</span><br><span class="line">        tree[ls]=(mid-l+1)*tag[p];</span><br><span class="line">        tree[rs]=(r-mid)*tag[p];</span><br><span class="line">        tag[ls]=tag[p]; tag[rs]=tag[p]; tag[p]=-1;</span><br><span class="line">    &#125;</span><br><span class="line">    void update(int l,int r,int p,int nl,int nr,int k)&#123;</span><br><span class="line">        if(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line">            tree[p]=k*(r-l+1); tag[p]=k;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        down(l,r,p);</span><br><span class="line">        if(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line">        if(nr&gt;mid) update(mid+1,r,rs,nl,nr,k);</span><br><span class="line">        tree[p]=tree[ls]+tree[rs];</span><br><span class="line">    &#125;</span><br><span class="line">    int query(int l,int r,int p,int nl,int nr)&#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        if(l&gt;=nl&amp;&amp;r&lt;=nr) return tree[p];</span><br><span class="line">        down(l,r,p);</span><br><span class="line">        if(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line">        if(nr&gt;mid) ans+=query(mid+1,r,rs,nl,nr);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;color[31];  //三十颗线段树</span><br><span class="line">inline int read()&#123;</span><br><span class="line">    int k=0,f=1; char c=getchar();</span><br><span class="line">    for(;c&lt;&apos;0&apos;||c&gt;&apos;9&apos;;c=getchar())</span><br><span class="line">      if(f==&apos;-&apos;) f=-1;</span><br><span class="line">    for(;c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;;c=getchar())</span><br><span class="line">      k=k*10+c-48;</span><br><span class="line">    return k*f;</span><br><span class="line">&#125;</span><br><span class="line">inline char read_c()&#123;</span><br><span class="line">    char c=getchar();</span><br><span class="line">    for(;c&lt;&apos;A&apos;||c&gt;&apos;Z&apos;;) c=getchar();</span><br><span class="line">    for(;c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;;)</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n=read(),t=read(),m=read();</span><br><span class="line">    for(int i=1;i&lt;=t;i++) memset(color[i].tag,-1,sizeof(color[i].tag));</span><br><span class="line">    color[1].build(1,n,1);  //初始颜色全为1</span><br><span class="line">    for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        char c=read_c();</span><br><span class="line">        if(c==&apos;C&apos;)&#123;</span><br><span class="line">            int x=read(),y=read(),z=read();</span><br><span class="line">            if(x&gt;y) x^=y^=x^=y; //x^=y^=x^=y等价于swap(x,y)</span><br><span class="line">            for(int i=1;i&lt;=t;i++)&#123;  //涂颜色</span><br><span class="line">                if(i==z) color[i].update(1,n,1,x,y,1);</span><br><span class="line">                else color[i].update(1,n,1,x,y,0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            int x=read(),y=read(),anss=0;</span><br><span class="line">            if(x&gt;y) x^=y^=x^=y;</span><br><span class="line">            for(int i=1;i&lt;=t;i++)&#123;  //统计颜色</span><br><span class="line">                if(color[i].query(1,n,1,x,y)) ++anss;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;,anss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十个测试点刚好卡过<br><img src="https://s1.ax2x.com/2018/10/14/5TaFc2.png" alt="卡过"></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\;Round\;514\;(Div.2)$</title>
      <link href="/2018/10/12/cf-r514-2/"/>
      <url>/2018/10/12/cf-r514-2/</url>
      <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1059" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><p>熬夜氪肝打$CF$，好不容易搞出来三道题，<del>TMD</del>又$FST$了<br>$\rm{QAQ}$，还是第二道题，死因：数组开小。我什么时候能认真一些啊……</p><p>第三道题因为错了太多+做得完，和第二题一个分</p><p>不过我竟然涨了<strong>4个rating</strong>（可能是我太菜了，已经不屑于扣我的$\tt{rating}$了）</p><hr><h3 id="it-A-Cashier"><a href="#it-A-Cashier" class="headerlink" title="$\it{A.Cashier}$"></a>$\it{A.Cashier}$</h3><p>还是水，不过比上次好些<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),l=read(),a=read();</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        ans+=(x-x1)/a;</span><br><span class="line">        x1=x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=(l-x1)/a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="sf-B-Forgery"><a href="#sf-B-Forgery" class="headerlink" title="$\sf{B.Forgery}$"></a>$\sf{B.Forgery}$</h3><p>这题我一开始毫无思路，所以先刚的$C$题再回来做的，然后就数组开小了……</p><p>我们枚举每一个周围全是$#$的元素，然后将它中间的点的坐标入栈。<br>枚举完毕后，我们新建一张空白图，将坐标依次出栈，在空白图上将它周围的点全变成$#$,然后与原图比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> mapp[<span class="number">1010</span>][<span class="number">1010</span>],wmap[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//check枚举每个元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mapp[x+<span class="number">1</span>][y]&amp;&amp;mapp[x+<span class="number">2</span>][y]&amp;&amp;mapp[x][y+<span class="number">1</span>]&amp;&amp;mapp[x][y+<span class="number">2</span>]</span><br><span class="line">        &amp;&amp;mapp[x+<span class="number">1</span>][y+<span class="number">2</span>]&amp;&amp;mapp[x+<span class="number">2</span>][y+<span class="number">2</span>]&amp;&amp;mapp[x+<span class="number">2</span>][y+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> wx[<span class="number">1000010</span>],wy[<span class="number">1000010</span>],top;<span class="comment">//就是这个地方，数组开小了1000倍……</span></span><br><span class="line"><span class="keyword">int</span> fx[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    fy[<span class="number">9</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">          <span class="keyword">char</span> c; <span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">          <span class="keyword">if</span>(c==<span class="string">'#'</span>) mapp[i][j]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(mapp[i][j])&#123;</span><br><span class="line">              <span class="keyword">if</span>(check(i,j)) wx[++top]=i+<span class="number">1</span>,wy[top]=j+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//填新图</span></span><br><span class="line">    <span class="keyword">while</span>(top)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=wx[top],y=wy[top]; --top;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++) wmap[x+fx[i]][y+fy[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(mapp[i][j]!=wmap[i][j])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tt-C-Sequence-Transformation"><a href="#tt-C-Sequence-Transformation" class="headerlink" title="$\tt{C.Sequence\;Transformation}$"></a>$\tt{C.Sequence\;Transformation}$</h3><p>能自己做出$\mathbb{C}$题来，还是很开心的。</p><p>因为题中要求字典序最大，但开始几次无论我们删哪个数，它们的$gcd$肯定都是$1$,所以我们只要让数列的$gcd$尽量早的不为$1$就好了，所以我们可以先将奇数删去，这样可以最早的输出一个大于$1$的数——$2$。<br>以此类推，我们再留下$4$的倍数、留下$8$的倍数……一直到最接近并小于$n$的$2$的整数次幂。<br>之后比较麻烦的是最后一位数的判定。如果$n$能被$ans[n-1]$整除，那为了字典序最大，我们要最后再把$n$删去。如果$n$不能被$ans[n-1]$整除，为了字典序最大，我们要提前删去$n$，来保证最早输出$2$的幂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1000010</span>],hhh=<span class="number">1</span>,pos;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n=read(); <span class="keyword">long</span> <span class="keyword">long</span> cnt=n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tot=cnt/<span class="number">2</span>; <span class="keyword">if</span>(cnt%<span class="number">2</span>) tot++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=tot;i++) ans[++pos]=hhh;</span><br><span class="line">    cnt-=tot; hhh&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(n%(ans[n<span class="number">-1</span>]))) ans[n]=n;</span><br><span class="line">    <span class="keyword">else</span> ans[n]=(ans[n<span class="number">-1</span>]*(n/ans[n<span class="number">-1</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CodePlus4 最短路</title>
      <link href="/2018/10/12/codeplus4-zdl/"/>
      <url>/2018/10/12/codeplus4-zdl/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4366" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>北极为什么会有企鹅啊，而且北纬91°在哪啊？</p><hr><p>关键在建图</p><p>因为任意两个城市间都可以互相到达，再加上还有“快捷通道”，光是建图就已经$\rm{T}$了……</p><p>但这题给了一个提示：除去快捷通道，边权<strong>只与</strong>两个城市的<strong>异或值</strong>有关<br>根据这个性质，我们可以发现，直接建图时，有很多边是多余的，我们只要将异或值的二进制中只含有一个$’1’$的边加入图中就好了，其他的边都是不必要的<br>因为假如一条边中有多个$’1’$，我们完全可以通过走其他的只有一个$’1’$的边来将它“凑”出来，所以这条边的存在毫无意义<br>知道这个性质后，我们的建图就是$O(nlogn)$的了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;=n;i++)</span><br><span class="line">for(int j=0;j&lt;=20;j++)&#123;</span><br><span class="line">  int to=i^(1&lt;&lt;j);</span><br><span class="line">        //因为&quot;^&quot;本身就是自己的逆运算，所以计算出来的&quot;to&quot;一定满足&quot;to^i=(1&lt;&lt;j)&quot;</span><br><span class="line">  if(to&lt;=n) add(i,to,(1&lt;&lt;j)*c);  //因为一共只有n个点，计算出来的&quot;to&quot;不能大于n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建完图后，跑一边最短路即可（<strong>不建议使用SPFA</strong>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,nex,len;</span><br><span class="line">&#125;e[<span class="number">500010</span>&lt;&lt;<span class="number">4</span>]; <span class="keyword">int</span> head[<span class="number">500010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">e[++tot].t=y;</span><br><span class="line">e[tot].len=z;</span><br><span class="line">e[tot].nex=head[x];</span><br><span class="line">head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,l;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> hhh &amp;y) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> l &gt; y.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;hhh&gt; q;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read(),c=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">20</span>;j++)&#123;  <span class="comment">// 本题的核心</span></span><br><span class="line">  <span class="keyword">int</span> to=i^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">  <span class="keyword">if</span>(to&lt;=n) add(i,to,(<span class="number">1</span>&lt;&lt;j)*c);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read(),z=read();</span><br><span class="line">add(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=read(),end=read();</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">127</span>/<span class="number">3</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">q.push(hhh&#123;start,<span class="number">0</span>&#125;); dis[start]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">hhh k=q.top(); q.pop();</span><br><span class="line"><span class="keyword">if</span>(k.l!=dis[k.v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[k.v];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[e[i].t]&gt;dis[k.v]+e[i].len)&#123;</span><br><span class="line">dis[e[i].t]=dis[k.v]+e[i].len;</span><br><span class="line">q.push(hhh&#123;e[i].t,dis[e[i].t]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dis[end];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> CodePlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最大子矩阵问题———悬线法</title>
      <link href="/2018/10/12/xxf/"/>
      <url>/2018/10/12/xxf/</url>
      <content type="html"><![CDATA[<p>悬线法可以用来求一类带有障碍点的最大子矩阵问题，对于一个$N \times M$的矩阵，该算法时间复杂度$O(NM)$。</p><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>有效竖线：除了两个端点外，不覆盖任何一个障碍点的竖直线段  </li><li>悬线：上端覆盖了一个障碍点的或者到达整个矩形上边界的有效竖线</li><li>悬线对应矩形：如果把一个悬线向左右两个方向尽可能的移动，会得到了一个矩形，我们称它为悬线对应矩形</li><li>每个悬线与它底部的点<strong>一一对应</strong></li><li><strong>悬线对应矩形不一定是极大子矩形，但极大子矩形一定是悬线对应矩形</strong></li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>根据“基本概念”的最后一条，我们只要求出所有的悬线对应矩形，就能找出所有的极大子矩形，从而找出最大子矩形。因为悬线最多有$(N-1) \times M$条，只要我们能$O(1)$转移悬线，就能得到一个总时间复杂度为$O(NM)$的优秀算法</p><p>接下来我们考虑如何转移</p><div class="table-container"><table><thead><tr><th style="text-align:center">数组名</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>h[i][j]</code></td><td style="text-align:center">点$(i,j)$对应的悬线的长度</td></tr><tr><td style="text-align:center"><code>l[i][j]</code></td><td style="text-align:center">点$(i,j)$左边的第一个障碍（若没有，则为边界）</td></tr><tr><td style="text-align:center"><code>r[i][j]</code></td><td style="text-align:center">点$(i,j)$右边的第一个障碍（若没有，则为边界）</td></tr><tr><td style="text-align:center"><code>L[i][j]</code></td><td style="text-align:center">点$(i,j)$对应的悬线能移动到的最左边的位置</td></tr><tr><td style="text-align:center"><code>R[i][j]</code></td><td style="text-align:center">点$(i,j)$对应的悬线能移动到的最右边的位置</td></tr></tbody></table></div><p>首先，我们预处理一下<code>l,r,L,R</code>四个数组（不同的题目处理的方式可能有略微的差别）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(mapp[i][j]) l[i][j]=pos;</span><br><span class="line">        <span class="keyword">else</span> L[i][j]=<span class="number">0</span>,pos=j;</span><br><span class="line">        pos=m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mapp[i][j]) r[i][j]=pos;</span><br><span class="line">            <span class="keyword">else</span> R[i][j]=m+<span class="number">1</span>,pos=j;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面只是求出了不合法的<code>L[i][j],R[i][j]</code>，接下来我们要求出所有的<code>L[i][j],R[i][j]</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++) R[<span class="number">0</span>][i]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(mapp[i][j])&#123;</span><br><span class="line">      h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">          L[i][j]=max(l[i][j]+<span class="number">1</span>,L[i<span class="number">-1</span>][j]);</span><br><span class="line">          R[i][j]=min(r[i][j]<span class="number">-1</span>,R[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>之后我们遍历一下每个点，对于点$(i,j)$，它对应的矩形右下角为<code>(i,R[i][j])</code>，左上角为<code>(i-h[i][j]+1,L[i][j])</code></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3039" target="_blank" rel="noopener"><strong>BZOJ3039 玉蟾宫</strong></a>  </p><blockquote><p><em>这好像是一道权限题，不过<a href="https://www.luogu.org/problemnew/show/P4147" target="_blank" rel="noopener">Luogu上也有</a></em>  </p></blockquote><p>悬线法裸题，上面讲的代码就出自此题</p></li><li><p><a href="https://www.luogu.org/problemnew/show/P1169" target="_blank" rel="noopener"><strong>ZJOI2007 棋盘制作</strong></a><br>悬线法裸题+1，只不过将判断$0/1$换成了异或</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> pos;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  l[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line">  <span class="keyword">if</span>(mapp[i][j]^mapp[i][j<span class="number">-1</span>])</span><br><span class="line">    l[i][j]=l[i][j<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">else</span> l[i][j]=j;</span><br><span class="line">r[i][m]=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">  <span class="keyword">if</span>(mapp[i][j]^mapp[i][j+<span class="number">1</span>])</span><br><span class="line">    r[i][j]=r[i][j+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">else</span> r[i][j]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">  h[<span class="number">1</span>][i]=<span class="number">1</span>,L[<span class="number">1</span>][i]=l[<span class="number">1</span>][i],R[<span class="number">1</span>][i]=r[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">  <span class="keyword">if</span>(mapp[i][j]^mapp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">  h[i][j]=h[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">  L[i][j]=max(l[i][j],L[i<span class="number">-1</span>][j]);</span><br><span class="line">  R[i][j]=min(r[i][j],R[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">h[i][j]=<span class="number">1</span>;</span><br><span class="line">L[i][j]=l[i][j];</span><br><span class="line">R[i][j]=r[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 悬线法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\;Round\;513\;(Div.1+Div.2)$</title>
      <link href="/2018/10/12/cf-r513-12/"/>
      <url>/2018/10/12/cf-r513-12/</url>
      <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1060" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><p>10月4号的比赛，因为各种原因（主要是懒），今天才写总结……</p><p>Div1+Div2，只做出两个题+迟到$20min$，日常掉$rating$……</p><hr><h3 id="rm-A-Phone-Numbers"><a href="#rm-A-Phone-Numbers" class="headerlink" title="$\rm{A.Phone\;Numbers}$"></a>$\rm{A.Phone\;Numbers}$</h3><p>很水的一道题目，直接输出<code>cout&lt;&lt;min(n/11,tot);</code>（$tot$为数字$8$的数量）</p><h3 id="mathcal-B-Maximum-Sum-of-Digits"><a href="#mathcal-B-Maximum-Sum-of-Digits" class="headerlink" title="$\mathcal{B.Maximum\;Sum\;of\;Digits}$"></a>$\mathcal{B.Maximum\;Sum\;of\;Digits}$</h3><p>一点小贪心，我们让$9$最多就行了，证明吗……感性的理解一下吧</p><h3 id="mathfrak-C-Maximum-Subrectangle"><a href="#mathfrak-C-Maximum-Subrectangle" class="headerlink" title="$\mathfrak{C.Maximum\;Subrectangle}$"></a>$\mathfrak{C.Maximum\;Subrectangle}$</h3><p>因为矩阵的元素$C_{i,j}=a_i\times b_i$，所以<br>$\sum_{i=x_1}^{x2}{\sum_{j=y_1}^{y2}{C_{i,j}}}=(sumx[x_2]-sumx[x_1-1])\times (sumy[x_2]-sumy[x_1-1])$<br>其中<code>sumx</code>和<code>sumy</code>是$a$数列和$b$数列的前缀和。这样我们就可以$O(n^2)$处理出子矩阵长一定时候的最小值和宽一定时的最小值，然后$O(1)$判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sumx[<span class="number">2010</span>],sumy[<span class="number">2010</span>],minx[<span class="number">2010</span>],miny[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read();</span><br><span class="line"><span class="built_in">memset</span>(minx,<span class="number">127</span>,<span class="keyword">sizeof</span>(minx)), <span class="built_in">memset</span>(miny,<span class="number">127</span>,<span class="keyword">sizeof</span>(miny));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sumx[i]=sumx[i<span class="number">-1</span>]+read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) sumy[i]=sumy[i<span class="number">-1</span>]+read();</span><br><span class="line">    <span class="comment">//====预处理长宽一定时的最小值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">minx[i]=min(minx[i],sumx[j]-sumx[j-i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//====判断并记录ans</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j++)&#123;</span><br><span class="line">miny[i]=min(miny[i],sumy[j]-sumy[j-i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x=read(),ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">  <span class="keyword">if</span>(minx[i]*miny[j]&lt;=x) ans=max(ans,i*j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P3393 逃离僵尸岛</title>
      <link href="/2018/09/29/luogu-p3393-tljsd/"/>
      <url>/2018/09/29/luogu-p3393-tljsd/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3393" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>$\rm{kkksc03}$说是模板题，但像我这种蒟蒻觉得万分艰难</p><hr><p>这道题目的核心在于求出所有的危险城市，我们可以一次性将所有的被占领的城市全部加入队列里，然后扩展危险城市</p><p>还有一点就是点权最短路，具体看代码吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> js[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> pon[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,nex;</span><br><span class="line">&#125;e[<span class="number">200010</span>&lt;&lt;<span class="number">2</span>]; <span class="keyword">int</span> head[<span class="number">100010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> k,len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span> &lt;hhh&gt; q; <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">LL dis[<span class="number">100010</span>]; <span class="keyword">bool</span> vis[<span class="number">100010</span>],wrning[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),k=read(),s=read(),p1=read(),p2=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(); q.push(hhh&#123;x,s&#125;); js[x]=<span class="number">1</span>;</span><br><span class="line">        wrning[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        add(x,y); add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123; <span class="comment">//扩展危险城市</span></span><br><span class="line">        hhh k=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(!k.len) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k.k];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(js[e[i].t]) <span class="keyword">continue</span>;</span><br><span class="line">            js[e[i].t]=<span class="number">1</span>;</span><br><span class="line">            q.push(hhh&#123;e[i].t,k.len<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++) pon[i]= (js[i]? p2:p1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) dis[i]=(LL)<span class="number">922337203685</span>;</span><br><span class="line">    pon[n+<span class="number">1</span>]=(LL)<span class="number">922336854775</span>; dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q2.push(<span class="number">1</span>); vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q2.empty())&#123;  <span class="comment">//点权最短路</span></span><br><span class="line">        <span class="keyword">int</span> k=q2.front(); q2.pop(); vis[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wrning[e[i].t]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[e[i].t]&gt;dis[k]+pon[e[i].t])&#123;</span><br><span class="line">                dis[e[i].t]=dis[k]+pon[e[i].t];</span><br><span class="line">                <span class="keyword">if</span>(!vis[e[i].t])&#123;</span><br><span class="line">                    vis[e[i].t]=<span class="number">1</span>; q2.push(e[i].t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dis[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SCOI2011 糖果</title>
      <link href="/2018/09/27/scoi2011-tg/"/>
      <url>/2018/09/27/scoi2011-tg/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3275" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>比较裸的差分约束……</p><hr><ul><li>当$k=1$，在$a,b$之间连一条边权为$0$的双向边  </li><li>当$k=2$，从$a$向$b$连一条边权为$1$的边  </li><li>当$k=3$，从$b$向$a$连一条边权为$0$的边  </li><li>当$k=4$，从$b$向$a$连一条边权为$1$的边  </li><li>当$k=5$，从$a$向$b$连一条边权为$0$的边</li></ul><p>这里还有两个小剪枝，一个是如果$k=2$或$k=4$时，$a=b$，那么肯定无解；另一个是从$0$号虚拟节点向其他各节点连边时要反向循环，不然会$\tt{T}$一个点,具体原因不明……<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">     <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">200010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">100010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y; e[tot].len=z;</span><br><span class="line">    e[tot].nex=head[x]; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">100010</span>],inq[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),k=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k=read(),x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) add(x,y,<span class="number">0</span>), add(y,x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)&#123; <span class="comment">//剪枝1</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add(x,y,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">3</span>) add(y,x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)&#123;  <span class="comment">//剪枝1</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add(y,x,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">5</span>) add(x,y,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) add(<span class="number">0</span>,i,<span class="number">1</span>); <span class="comment">//剪枝2</span></span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">1277</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(<span class="number">0</span>); vis[<span class="number">0</span>]=<span class="number">1</span>; dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=q.front(); q.pop(); vis[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[e[i].t]&lt;dis[k]+e[i].len)&#123;</span><br><span class="line">                dis[e[i].t]=dis[k]+e[i].len;</span><br><span class="line">                <span class="keyword">if</span>(!vis[e[i].t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(inq[e[i].t]==n<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    inq[e[i].t]++;</span><br><span class="line">                    q.push(e[i].t), vis[e[i].t]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=dis[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 差分约束 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HNOI2001 产品加工</title>
      <link href="/2018/09/26/hnoi2001-cpjg/"/>
      <url>/2018/09/26/hnoi2001-cpjg/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2224" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>思路蛮巧妙的，像我这种蒟蒻根本想不到是背包……</p><hr><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>用<code>f[i]</code>表示在$A$机器上用了时间$i$时，$B$机器所用的时间  </p><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=read(),b=read(),c=read();</span><br><span class="line">flag+=max(a,max(b,c));</span><br><span class="line">        <span class="keyword">if</span>(!a) a=<span class="number">1</span>&lt;&lt;<span class="number">30</span>; <span class="keyword">if</span>(!b) b=<span class="number">1</span>&lt;&lt;<span class="number">30</span>; <span class="keyword">if</span>(!c) c=<span class="number">1</span>&lt;&lt;<span class="number">30</span>; <span class="comment">//如果不能在这台机器上加工，那么把它赋值为一个很大的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=flag;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="number">1</span>&lt;&lt;<span class="number">30</span>) dp[j]=b;</span><br><span class="line">            <span class="keyword">else</span> dp[j]+=b;</span><br><span class="line">            <span class="comment">//以上为赋初值——默认在B机器上加工</span></span><br><span class="line">            <span class="comment">//以下为状态转移</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a) dp[j]=min(dp[j],dp[j-a]);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=c) dp[j]=min(dp[j],dp[j-c]+c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">     <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">30010</span>],flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read();</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">2</span>,<span class="keyword">sizeof</span>(dp)); dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=read(),b=read(),c=read();</span><br><span class="line">flag+=max(a,max(b,c));</span><br><span class="line">        <span class="keyword">if</span>(!a) a=<span class="number">1</span>&lt;&lt;<span class="number">30</span>; <span class="keyword">if</span>(!b) b=<span class="number">1</span>&lt;&lt;<span class="number">30</span>; <span class="keyword">if</span>(!c) c=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=flag;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b==<span class="number">1</span>&lt;&lt;<span class="number">30</span>) dp[j]=b;</span><br><span class="line">            <span class="keyword">else</span> dp[j]+=b;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=a) dp[j]=min(dp[j],dp[j-a]);</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=c) dp[j]=min(dp[j],dp[j-c]+c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=flag;i++) ans=min(ans,max(dp[i],i));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HNOI2003 消防局的设立</title>
      <link href="/2018/09/18/hnoi2003-xfjdsl/"/>
      <url>/2018/09/18/hnoi2003-xfjdsl/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2279" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>据说是一道树形DP，这么高级的么……<br>然而贪心水过了……</p><hr><p>因为消防局可以扑灭与它距离<strong>不超过2</strong>的基地的火灾，所以我们可以每次找出深度最大的点（用堆维护），然后在他的爷爷节点（没有爷爷就在父亲节点）建一个消防局<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,nex;</span><br><span class="line">&#125;e[<span class="number">1010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">1010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">1010</span>],vis[<span class="number">1010</span>],deth[<span class="number">1010</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)</span><br><span class="line">      <span class="keyword">if</span>(e[i].t!=fa[now])&#123;</span><br><span class="line">          fa[e[i].t]=now; deth[e[i].t]=deth[now]+<span class="number">1</span>;</span><br><span class="line">          dfs(e[i].t);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> k,deth;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> hhh &amp;y) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deth &lt; y.deth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;hhh&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(); add(i,x); add(x,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q.push(hhh&#123;i,deth[i]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> k=q.top().k; q.pop();</span><br><span class="line">    <span class="keyword">if</span>(vis[k]) <span class="keyword">continue</span>;</span><br><span class="line">    ans++;</span><br><span class="line">        <span class="keyword">if</span>(fa[fa[k]])&#123;</span><br><span class="line">            vis[fa[fa[k]]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fa[fa[k]]];i;i=e[i].nex)&#123;</span><br><span class="line">                vis[e[i].t]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=head[e[i].t];j;j=e[j].nex) vis[e[j].t]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vis[fa[k]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[fa[k]];i;i=e[i].nex) vis[e[i].t]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1020 关路灯</title>
      <link href="/2018/09/14/luogu-p1020-gld/"/>
      <url>/2018/09/14/luogu-p1020-gld/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1220" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>我$DP$太菜了……只会抄题解……</p><p>抄了题解的我再来向你们瞎$\tt{bibi},$ 233~</p><hr><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>一道区间$DP$，我们用<code>dp[i][j]</code>表示将第$i$盏路灯到第$j$路灯之间的路灯全部关上的最小能耗，但这样我们很难转移，根本无从下手——不知道老张的位置。</p><p>既然我们缺少位置信息，那再加上一维不就好了么。于是我们可以用<code>dp[i][j][0/1]</code>表示将第$i$盏路灯到第$j$路灯之间的路灯全部关上，老张此时在第$i$盏路灯下（$0$）或第$j$盏路灯下（$1$）的最小能耗</p><p>那么初始状态很明显就是<code>dp[c][c][1]=dp[c][c][0]=0;</code></p><h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>因为我们要快速的求出总区间剔除出一段区间的和，所以可以用前缀和来维护</p><p>十分冗长的$\rm{code}$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i+<span class="number">1</span>][j][<span class="number">0</span>]+(x[i+<span class="number">1</span>]-x[i])*(sum[n]-sum[j]+sum[i]),dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+(x[j]-x[i])*(sum[n]-sum[j]+sum[i]));</span><br><span class="line">dp[i][j][<span class="number">1</span>]=min(dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+(x[j]-x[i])*(sum[n]-sum[j<span class="number">-1</span>]+sum[i<span class="number">-1</span>]),dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+(x[j]-x[j<span class="number">-1</span>])*(sum[n]-sum[j<span class="number">-1</span>]+sum[i<span class="number">-1</span>]));</span><br></pre></td></tr></table></figure></p><h3 id="mathcal-code"><a href="#mathcal-code" class="headerlink" title="$\mathcal{code}$"></a>$\mathcal{code}$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">51</span>][<span class="number">51</span>][<span class="number">2</span>],sum[<span class="number">51</span>],x[<span class="number">51</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),c=read(); <span class="built_in">memset</span>(dp,<span class="number">2</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=read(),sum[i]=sum[i<span class="number">-1</span>]+read();</span><br><span class="line">dp[c][c][<span class="number">1</span>]=dp[c][c][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=c;j&lt;=n;j++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=j<span class="number">-1</span>;i;i--)&#123;</span><br><span class="line">  dp[i][j][<span class="number">0</span>]=min(dp[i+<span class="number">1</span>][j][<span class="number">0</span>]+(x[i+<span class="number">1</span>]-x[i])*(sum[n]-sum[j]+sum[i]),dp[i+<span class="number">1</span>][j][<span class="number">1</span>]+(x[j]-x[i])*(sum[n]-sum[j]+sum[i]));</span><br><span class="line">  dp[i][j][<span class="number">1</span>]=min(dp[i][j<span class="number">-1</span>][<span class="number">0</span>]+(x[j]-x[i])*(sum[n]-sum[j<span class="number">-1</span>]+sum[i<span class="number">-1</span>]),dp[i][j<span class="number">-1</span>][<span class="number">1</span>]+(x[j]-x[j<span class="number">-1</span>])*(sum[n]-sum[j<span class="number">-1</span>]+sum[i<span class="number">-1</span>]));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[<span class="number">1</span>][n][<span class="number">0</span>],dp[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2004 虫食算</title>
      <link href="/2018/09/09/noip2004-css/"/>
      <url>/2018/09/09/noip2004-css/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1875" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>暴搜都打不对 QAQ 调了好久</p><hr><h3 id="40pts"><a href="#40pts" class="headerlink" title="40pts"></a>40pts</h3><p>显而易见，我们可以通过枚举全排列来找到一种合法的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans[<span class="number">27</span>];</span><br><span class="line"><span class="built_in">string</span> ss[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">27</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ss[<span class="number">1</span>]&gt;&gt;ss[<span class="number">2</span>]&gt;&gt;ss[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      ans[i]=i<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            k[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">              k[i]=k[i]*n+ans[ss[i][j]-<span class="string">'A'</span>+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k[<span class="number">1</span>]+k[<span class="number">2</span>]==k[<span class="number">3</span>])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(next_permutation(ans+<span class="number">1</span>,ans+n+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这么暴力当然是行不通的，暴力也要暴力的优雅一些，使用$next{-}permutation$枚举全排列会难以剪枝，不如暴搜，而这道题目暴搜是可以过的（然而官方正解是高斯消元）</p><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p><del>高斯消元</del> 暴搜+剪枝</p><p>剪枝：</p><ol><li>搜索顺序从后向前，从上到下</li><li>搜索时要判断一下当前的算式是否合法<br>别的……好像也没有什么了……</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> add[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">21</span>],b[<span class="number">21</span>],c[<span class="number">21</span>],num[<span class="number">110</span>],n;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;  <span class="comment">//搜出答案后判断是否合法</span></span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i!=<span class="number">-1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=(num[add[<span class="number">1</span>][i]]+num[add[<span class="number">2</span>][i]]+(<span class="keyword">int</span>)flag)%n;</span><br><span class="line">        <span class="keyword">if</span>(x!=num[add[<span class="number">3</span>][i]])&#123;</span><br><span class="line">            f=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag=(num[add[<span class="number">1</span>][i]]+num[add[<span class="number">2</span>][i]]+(<span class="keyword">int</span>)flag)/(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="string">'A'</span>;i&lt;=<span class="string">'A'</span>+n<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[i]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> y,<span class="keyword">bool</span> zzz)</span></span>&#123;  <span class="comment">//pos是第几列,y是第几行,zzz是当前是否要进位</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        judge(); <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">3</span>)&#123;  <span class="comment">//如果来到了答案行,直接根据答案行上方两个数+进位推出答案</span></span><br><span class="line">    <span class="keyword">if</span>(num[add[y][pos]]==<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]&amp;&amp;(num[add[<span class="number">1</span>][pos]]+num[add[<span class="number">2</span>][pos]]+zzz)%n==i)&#123;</span><br><span class="line">    vis[i]=<span class="number">1</span>; num[add[y][pos]]=i;</span><br><span class="line">    dfs(pos<span class="number">-1</span>,<span class="number">1</span>,(num[add[<span class="number">1</span>][pos]]+num[add[<span class="number">2</span>][pos]]+zzz)/n);</span><br><span class="line">    vis[i]=<span class="number">0</span>; num[add[y][pos]]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;  <span class="comment">//如果答案代表的数被其它字母占了,那么这组解一定不合法,也没有搜的必要了</span></span><br><span class="line"><span class="keyword">if</span>((num[add[<span class="number">1</span>][pos]]+num[add[<span class="number">2</span>][pos]]+zzz)%n!=num[add[<span class="number">3</span>][pos]])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs(pos<span class="number">-1</span>,<span class="number">1</span>,(num[add[<span class="number">1</span>][pos]]+num[add[<span class="number">2</span>][pos]]+zzz)/n); <span class="comment">//处理进位</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num[add[y][pos]]==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>; num[add[y][pos]]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n<span class="number">-1</span>;j++)&#123;  <span class="comment">//从整体上扫一遍算式,判断合不合法</span></span><br><span class="line">                <span class="keyword">if</span>(num[add[<span class="number">1</span>][j]]!=<span class="number">-1</span>&amp;&amp;num[add[<span class="number">2</span>][j]]!=<span class="number">-1</span>&amp;&amp;num[add[<span class="number">3</span>][j]]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((num[add[<span class="number">1</span>][j]]+num[add[<span class="number">2</span>][j]])%n!=num[add[<span class="number">3</span>][j]]&amp;&amp;(num[add[<span class="number">1</span>][j]]+num[add[<span class="number">2</span>][j]]+<span class="number">1</span>)%n!=num[add[<span class="number">3</span>][j]])&#123;  <span class="comment">//我懒,不想考虑进位了,直接进不进位都判断一下,应该会跑得慢一些</span></span><br><span class="line">                vis[i]=<span class="number">0</span>; num[add[y][pos]]=<span class="number">-1</span>; flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                flag=<span class="number">0</span>; <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            dfs(pos,y+<span class="number">1</span>,zzz);</span><br><span class="line">            vis[i]=<span class="number">0</span>; num[add[y][pos]]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs(pos,y+<span class="number">1</span>,zzz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">-1</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;add[<span class="number">1</span>]&gt;&gt;add[<span class="number">2</span>]&gt;&gt;add[<span class="number">3</span>];</span><br><span class="line">    dfs(n<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SP2713 GSS4-Can you answer these queries IV</title>
      <link href="/2018/09/05/spoj2713-gssf/"/>
      <url>/2018/09/05/spoj2713-gssf/</url>
      <content type="html"><![CDATA[<p><a href="https://www.spoj.com/problems/GSS4/" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>$ZHX\; TQL$ Orz</p><hr><p>这道题目我们可以用线段树维护……</p><p>可能有$dalao$会问：“线段树怎么维护区间开平方？”</p><p>而这道题的精髓就在于，它要我们维护的操作是<strong>开平方+下取整</strong>。也就是说经过一定的次数，要开平方的数会慢慢缩小为”$1$”，这个次数是很小的，而$\sqrt 1=1$。</p><p>所以在修改时，我们可以先查询这个区间是否全是”1”，如果是，那我们就不管它，再去寻找其他的区间进行修改，如果这个区间里有其他数，我们就将这些递归寻找这些数，然后单点修改进行开平方操作。</p><p>$\tt{P.S.}$ 要注意这个题目的输出格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">LL tree[<span class="number">100010</span>&lt;&lt;<span class="number">4</span>],a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p]=a[l]; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr)&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[p]&lt;=r-l+<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p]=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)tree[p]);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">up(p);</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr);</span><br><span class="line">up(p);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("hh.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("hh.out","w",stdout);</span></span><br><span class="line"><span class="keyword">int</span> n,tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>,&amp;n)!=EOF)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,++tot);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=read(),l=read(),r=read();</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>) update(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(<span class="number">1</span>,n,<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> SPOJ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APIO2008 免费道路</title>
      <link href="/2018/08/20/apio2008-mfdl/"/>
      <url>/2018/08/20/apio2008-mfdl/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3623" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>%%%$\sf{ZYD\;\;TQL}$</p><hr><p>感觉这个题的题意有点难懂，简单概括一下就是：<br><strong>有$n$个村庄，$m$条道路，道路分为水泥路和鹅卵石路，选择其中$n-1$条路使得所有村庄联通，并且选择的路中恰好有$k$条鹅卵石路。</strong></p><p>我们可以先对所有的水泥路跑一遍$Kruskal$，把它们全加入生成树，然后再对鹅卵石路跑一遍，此时加进生成树里的鹅卵石路是必须要加的，因为没有它们，是无法让图联通的</p><p>之后我们将图复原，现将必须要加的鹅卵石路加进去，再添加鹅卵石路，直至总数达到$k$，最后再加水泥路。</p><p>无解的情况有：</p><ul><li>找不到生成树</li><li>必须添加的鹅卵石路大于$k$</li><li>鹅卵石路的数量小于$k$</li></ul><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">20010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,t; <span class="keyword">bool</span> fl;</span><br><span class="line">&#125;e1[<span class="number">100010</span>],e2[<span class="number">100010</span>],imp[<span class="number">20010</span>],ans[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x]==x? x:fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt,tot1,tot2,tot3;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),k=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(read()) e2[++tot2].f=x,e2[tot2].t=y;</span><br><span class="line">        <span class="keyword">else</span> e1[++tot1].f=x,e1[tot1].t=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot1&lt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no solution"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot2;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(e2[i].f),y=find(e2[i].t);</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=fa[y]) fa[x]=fa[y],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot1;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(e1[i].f),y=find(e1[i].t);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">            fa[x]=fa[y],cnt++;</span><br><span class="line">            imp[++tot3]=e1[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>||tot3&gt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no solution"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot3;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(imp[i].f),y=find(imp[i].t);</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=fa[y])&#123;</span><br><span class="line">            fa[x]=fa[y]; cnt++;</span><br><span class="line">            ans[cnt]=imp[i]; ans[cnt].fl=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot1;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(e1[i].f),y=find(e1[i].t);</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=fa[y])&#123;</span><br><span class="line">            fa[x]=fa[y]; cnt++;</span><br><span class="line">            ans[cnt]=e1[i]; ans[cnt].fl=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==k) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;k)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no solution"</span>); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot2;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=find(e2[i].f),y=find(e2[i].t);</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=fa[y])&#123;</span><br><span class="line">            fa[x]=fa[y]; cnt++;</span><br><span class="line">            ans[cnt]=e2[i]; ans[cnt].fl=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans[i].f,ans[i].t,ans[i].fl);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> APIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>国家集训队 小Z的袜子</title>
      <link href="/2018/08/20/gjjxd-xzdwz/"/>
      <url>/2018/08/20/gjjxd-xzdwz/</url>
      <content type="html"><![CDATA[<h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><a href="https://www.luogu.org/problemnew/show/P1494" target="_blank" rel="noopener"><strong>题目传送门</strong></a></h3><p>自从“HH的项链”被树状数组干爆了之后，莫队终于扬眉吐气了一把。</p><hr><p>很经典的莫队模板题，好像没什么好说的……</p><p>代码有(十)些(分)冗长，将就着看吧……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    LL l,r,pos;</span><br><span class="line">&#125;que[<span class="number">50010</span>]; <span class="keyword">int</span> n,m,sq;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zzz x,zzz y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.l/sq != y.l/sq) <span class="keyword">return</span> x.l/sq &lt; y.l/sq;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">LL a[<span class="number">50010</span>],tong[<span class="number">50010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hhh</span>&#123;</span></span><br><span class="line">    LL fm,fz;</span><br><span class="line">&#125;anss[<span class="number">50010</span>];</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x%y==<span class="number">0</span>? y:gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read(); sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">      que[i].l=read(),que[i].r=read(), que[i].pos=i;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+m+<span class="number">1</span>,cmp);</span><br><span class="line">    LL l=<span class="number">1</span>,r=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;que[i].l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[l]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans-=tong[a[l]]*tong[a[l]];</span><br><span class="line">            tong[a[l++]]--;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[l<span class="number">-1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans+=tong[a[l<span class="number">-1</span>]]*tong[a[l<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;que[i].l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[l<span class="number">-1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans-=tong[a[l<span class="number">-1</span>]]*tong[a[l<span class="number">-1</span>]];</span><br><span class="line">            tong[a[--l]]++;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[l]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans+=tong[a[l]]*tong[a[l]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;que[i].r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[r+<span class="number">1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans-=tong[a[r+<span class="number">1</span>]]*tong[a[r+<span class="number">1</span>]];</span><br><span class="line">            tong[a[++r]]++;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[r]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans+=tong[a[r]]*tong[a[r]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;que[i].r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[r]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans-=tong[a[r]]*tong[a[r]];</span><br><span class="line">            tong[a[r--]]--;</span><br><span class="line">            <span class="keyword">if</span>(tong[a[r<span class="number">-1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">              ans+=tong[a[r+<span class="number">1</span>]]*tong[a[r+<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==r||ans==r-l+<span class="number">1</span>)&#123;</span><br><span class="line">            anss[que[i].pos].fz=<span class="number">0</span>; anss[que[i].pos].fm=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL g=gcd(ans-(r-l+<span class="number">1</span>),(r-l+<span class="number">1</span>)*(r-l));</span><br><span class="line">        anss[que[i].pos].fz=(ans-(r-l+<span class="number">1</span>))/g;</span><br><span class="line">        anss[que[i].pos].fm=((r-l+<span class="number">1</span>)*(r-l))/g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%lld/%lld\n"</span>,anss[i].fz,anss[i].fm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 国家集训队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SCOI2009 迷路</title>
      <link href="/2018/08/20/scoi2009-ml/"/>
      <url>/2018/08/20/scoi2009-ml/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4159" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>$ZHX\; TQL$ Orz</p><hr><p>我们先考虑边权都是$1$的情况，此时只需要一个很简单的DP就可求出答案。</p><p>$dp[i][j]$表示从i到j的方案总数，则$dp[i][j]=\sum_{k=1}^n dp[i][k]\cdot dp[k][j]$，虽然我们的方程是正确的，但它会$\tt{TLE}$。我们稍加思索，可以发现这个东西和矩阵乘法几乎一模一样，所以我们就可以用矩阵加速$dp$。</p><p>但那是边权都为$1$的情况，原问题边权可是$1$~$9$，我们该怎么处理呢？<br>很简单，暴力拆边就可以了。我们可以把一条边权为$x$的边拆成$x+1$个点之间连着边权为$1$的边。</p><p>比如原来的图是这样的：<br><img src="https://s1.ax2x.com/2018/08/20/59vcGd.png" alt=""></p><p>我们可以把它拆成这样：<br><img src="https://s1.ax2x.com/2018/08/20/59vrER.png" alt=""></p><p>然后跑矩阵快速幂就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//底下的注释是我用来调试的，懒得删了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 2009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">if</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line">&#125;mapp;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat x,mat y)</span></span>&#123;</span><br><span class="line">mat ans;</span><br><span class="line"><span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>*n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>*n;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">9</span>*n;k++)</span><br><span class="line">      ans.a[i][k]=(ans.a[i][k]+(x.a[i][j]*y.a[j][k])%mod)%mod;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mat <span class="title">poww</span><span class="params">(mat x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">mat ans; <span class="built_in">memset</span>(ans.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.a));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>*n;i++)</span><br><span class="line">  ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;k&gt;<span class="number">0</span>;k&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>) ans=mul(ans,x);</span><br><span class="line">x=mul(x,x);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=9*n;i++)&#123;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">for(int j=1;j&lt;=9*n;j++)</span></span><br><span class="line"><span class="comment">  cout&lt;&lt;x.a[i][j]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("out","w",stdout);</span></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">8</span>;j++)</span><br><span class="line">    mapp.a[<span class="number">9</span>*i+j][<span class="number">9</span>*i+j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">  <span class="keyword">int</span> k=read();</span><br><span class="line">  <span class="keyword">if</span>(k) mapp.a[<span class="number">9</span>*i+k][<span class="number">9</span>*j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=9*n;i++)&#123;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">for(int j=1;j&lt;=9*n;j++)</span></span><br><span class="line"><span class="comment">  cout&lt;&lt;mapp.a[i][j];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mapp=poww(mapp,t);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;mapp.a[<span class="number">1</span>][n*<span class="number">9</span><span class="number">-8</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树维护区间最大子段和</title>
      <link href="/2018/08/20/xdswhqjzdzdh/"/>
      <url>/2018/08/20/xdswhqjzdzdh/</url>
      <content type="html"><![CDATA[<p>线段树：我还是很强的</p><hr><h3 id="简略讲解"><a href="#简略讲解" class="headerlink" title="简略讲解"></a>简略讲解</h3><p>要用线段树维护区间，我们要明确：</p><ul><li>线段树存什么东西</li><li>怎么合并</li><li>如果有区间修改，怎么打标记</li></ul><p>对于区间最大子段和，我们可以记录四个值：以维护的区间左端点为起点的最大子段和，以维护的区间右端点为终点的最大子段和，在维护区间内的最大子段和 和维护区间所有元素的和</p><p>合并的话稍微麻烦一些，看代码吧：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p].sum=tree[ls].sum+tree[rs].sum; <span class="comment">//维护区间总和</span></span><br><span class="line">tree[p].ll=max(tree[ls].ll,tree[ls].sum+tree[rs].ll);</span><br><span class="line"><span class="comment">//左端点的最大子段和可能为左儿子的左端点最大子段和,也可能为左儿子区间和 和右儿子左端点最大子段和拼起来的最大子段和</span></span><br><span class="line">tree[p].lr=max(tree[rs].lr,tree[rs].sum+tree[ls].lr);</span><br><span class="line"><span class="comment">//右端点最大子段和同理</span></span><br><span class="line">tree[p].lm=max(tree[ls].lr+tree[rs].ll,max(tree[ls].lm,tree[rs].lm));</span><br><span class="line"><span class="comment">//中间的最大子段和可能为左/右儿子中间的的最大子段和,也可能为左右儿子拼起来的和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们的线段树那就可以维护最大子段和了。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例-1-：-SPOJ-1043"><a href="#例-1-：-SPOJ-1043" class="headerlink" title="例$1$： SPOJ 1043"></a>例$1$： SPOJ 1043</h4><p><a href="https://www.spoj.com/problems/GSS1/" target="_blank" rel="noopener">GSS1 - Can you answer these queries I</a></p><p>裸题，不解释，直接上代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7ffffffffLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">LL ll,lr,lm,sum;</span><br><span class="line">&#125;tree[<span class="number">200010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">tree[p].ll=max(tree[ls].ll,tree[ls].sum+tree[rs].ll);</span><br><span class="line">tree[p].lr=max(tree[rs].lr,tree[rs].sum+tree[ls].lr);</span><br><span class="line">tree[p].lm=max(tree[ls].lr+tree[rs].ll,max(tree[ls].lm,tree[rs].lm));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].sum=tree[p].ll=tree[p].lr=tree[p].lm=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">zzz <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">zzz a=&#123;-inf,-inf,-inf,-inf&#125;,b=&#123;-inf,-inf,-inf,-inf&#125;,ans=&#123;-inf,-inf,-inf,-inf&#125;;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) a=query(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) b=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">ans.sum=a.sum+b.sum;</span><br><span class="line">ans.ll=max(a.ll,a.sum+b.ll);</span><br><span class="line">ans.lr=max(b.lr,b.sum+a.lr);</span><br><span class="line">ans.lm=max(a.lr+b.ll,max(a.lm,b.lm));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">int</span> m=read(); build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">zzz k=query(<span class="number">1</span>,n,<span class="number">1</span>,x,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(k.ll,max(k.lm,k.lr)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="例-2-：SPOJ-1716"><a href="#例-2-：SPOJ-1716" class="headerlink" title="例$2$：SPOJ 1716"></a>例$2$：SPOJ 1716</h4><p><a href="https://www.spoj.com/problems/GSS3/" target="_blank" rel="noopener">GSS3 - Can you answer these queries III</a></p><p>这题和上题相比，就多了一个单点修改，加一个修改函数就可以了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7ffffffffLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">LL ll,lr,lm,sum;</span><br><span class="line">&#125;tree[<span class="number">200010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">tree[p].sum=tree[ls].sum+tree[rs].sum;</span><br><span class="line">tree[p].ll=max(tree[ls].ll,tree[ls].sum+tree[rs].ll);</span><br><span class="line">tree[p].lr=max(tree[rs].lr,tree[rs].sum+tree[ls].lr);</span><br><span class="line">tree[p].lm=max(tree[ls].lr+tree[rs].ll,max(tree[ls].lm,tree[rs].lm));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].sum=tree[p].ll=tree[p].lr=tree[p].lm=a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">zzz <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">zzz a=&#123;-inf,-inf,-inf,-inf&#125;,b=&#123;-inf,-inf,-inf,-inf&#125;,ans=&#123;-inf,-inf,-inf,-inf&#125;;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) a=query(l,mid,ls,nl,nr);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) b=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">ans.sum=a.sum+b.sum;</span><br><span class="line">ans.ll=max(a.ll,a.sum+b.ll);</span><br><span class="line">ans.lr=max(b.lr,b.sum+a.lr);</span><br><span class="line">ans.lm=max(a.lr+b.ll,max(a.lm,b.lm));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nn,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[p].ll=tree[p].lm=tree[p].lr=tree[p].sum=k;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nn&lt;=mid) update(l,mid,ls,nn,k);</span><br><span class="line"><span class="keyword">if</span>(nn&gt;mid) update(mid+<span class="number">1</span>,r,rs,nn,k);</span><br><span class="line">up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">int</span> m=read(); build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> f=read(),x=read(),y=read();</span><br><span class="line"><span class="keyword">if</span>(f==<span class="number">1</span>)&#123;</span><br><span class="line">zzz k=query(<span class="number">1</span>,n,<span class="number">1</span>,x,y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max(k.ll,max(k.lm,k.lr)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  update(<span class="number">1</span>,n,<span class="number">1</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\;Round\;504\;(Div.1+Div.2)$</title>
      <link href="/2018/08/18/cf-r504-12/"/>
      <url>/2018/08/18/cf-r504-12/</url>
      <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1023" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><p>宾馆的$\rm{wifi}$也太不好了，蹭的$ZZC$的热点才打的比赛（感谢$ZZC$）</p><p>日常掉rating…… 我现在是个$\color{green}{pupil}$……  </p><p>因为我菜，所以还是只写了前三道题</p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="mathcal-A-Single-Wildcard-Pattern-Matching"><a href="#mathcal-A-Single-Wildcard-Pattern-Matching" class="headerlink" title="$\mathcal{A.Single\; Wildcard\; Pattern\; Matching}$"></a>$\mathcal{A.Single\; Wildcard\; Pattern\; Matching}$</h3><p><strong>题目大意</strong>：有点长，不想翻译了qwq</p><p>我能说第一题是前三道题中最难的么……各种特判，各种被卡，最后交了<strong>4遍</strong>也没做出来（我太蒟了 QAQ）</p><p>反复修改后的冗杂的AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; n-=<span class="number">1</span>,m-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">200010</span>],s2[<span class="number">200010</span>]; <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        pos=i;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]==<span class="string">'*'</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pos;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pos;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i]!=s2[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos==n+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n!=m)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> hhh;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n-j==pos) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[n-j]!=s2[m-j])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos;i&lt;m-j;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2[i]&lt;<span class="string">'a'</span>||s2[i]&gt;<span class="string">'z'</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hhh:</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="mathfrak-B-Pair-of-Toys"><a href="#mathfrak-B-Pair-of-Toys" class="headerlink" title="$\mathfrak{B.Pair\; of\; Toys}$"></a>$\mathfrak{B.Pair\; of\; Toys}$</h3><p><strong>题目大意</strong>：输入两个数$n,k$，问从$1\text{~}n$中取出$2$个数使得它们的和为$k$的方案数（$(a,b)$和$(b,a)$算同一种方案）</p><p>这题算是数论吧……挺简单的</p><p>如果$a+b==k$，那么$(a+1)+(b-1),(a+2)+(b-2)$……也等于$k$。所以我们可以找到最接近的两个数$k/2,k/2+1$，然后$1\text{~}k/2$和$(k/2+1)\text{~}(k{-}1)$就是所有的方案。接下来我们只需要找出合法的方案数就可以了</p><p>首先我们可以确定如果$k/2{&gt;=}n$，肯定无解，当$k/2{&lt;}n$的时候，因为$n$可能小于$k$，所以合法的方案数应为$\min(k/2,(k-1)-k/2,n-k/2)$</p><p>P.S. 不要忘了开$long\; long$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,k; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mid=k/<span class="number">2</span>,ans;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;n) ans=min(mid,min(k<span class="number">-1</span>-mid,n-mid));</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sf-C-Bracket-Subsequence"><a href="#sf-C-Bracket-Subsequence" class="headerlink" title="$\sf{C.Bracket\; Subsequence}$"></a>$\sf{C.Bracket\; Subsequence}$</h3><p><strong>题目大意</strong>：给你一个长度为$n$括号序列$a$，找出一段长度为$m$合法的括号序列$b$，使得$b$是$a$的子串</p><p>$b$为答案，我们枚举$a$的每一个括号，每扫到一个括号，就把它加入$b$里，如果为左括号，$cnt{+}{=}1$，如果$cnt==m/2$就跳出循环，然后从后面补右括号就行了</p><p>没初始化$ans$数组，FST了…… QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m; m/=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">200010</span>],b[<span class="number">200010</span>]; <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(a)<span class="number">-1</span>,tot=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">b[tot++]=<span class="string">'('</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt==m) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">b[tot++]=<span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=tot;i&lt;m*<span class="number">2</span>;i++) b[i]=<span class="string">')'</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次比赛暴露了我以下几个问题：</p><ol><li>不够认真、仔细，对特殊情况考虑不全</li><li>代码中总存在一些小问题</li><li>太浮躁，认为第一遍测试过了就万事大吉了，没有检查代码的隐藏$bug$</li><li>太过依赖于样例和测试数据</li></ol>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流24题 飞行员配对方案问题</title>
      <link href="/2018/08/08/wll24t-fxypdwt/"/>
      <url>/2018/08/08/wll24t-fxypdwt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2756" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>虽然这题是“网络流24题”，但我匈牙利<del>Van♂</del>完全不虚，还比$dinic$好写不少（不过就是慢一些）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>t,nex;</span><br><span class="line">&#125;e[<span class="number">10001</span>*<span class="number">2</span>]; <span class="keyword">int</span> head[<span class="number">101</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">101</span>];<span class="keyword">int</span> lin[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nex)</span><br><span class="line">      <span class="keyword">if</span>(!vis[e[i].t])&#123;</span><br><span class="line">          vis[e[i].t]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(!lin[e[i].t]||find(lin[e[i].t]))&#123;</span><br><span class="line">              lin[e[i].t]=x; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m; m=read(),n=read();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>&amp;&amp;y==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        add(x,y); add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(find(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No Solution!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lin[i]&gt;<span class="number">0</span>&amp;&amp;lin[i]&lt;=m&amp;&amp;ans)&#123;</span><br><span class="line">            ans--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,lin[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图匹配 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流24题 魔术球问题</title>
      <link href="/2018/08/08/wll24t-msqwt/"/>
      <url>/2018/08/08/wll24t-msqwt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2765" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>又是一个神奇的建图题，建图$Van$♂全不会啊</p><p>大体就是我们一个一个的把球放进来，每放进来一个，我们就求出当前的最小路径覆盖数(当前顶点数-最大流)，直到最小路径覆盖数${&gt;}$柱子数。此时的球的编号$-1$就是第一问的答案。第二问就是求每一条路径，顺着推下来就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">20010</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">e[++tot].t=y;</span><br><span class="line">e[tot].len=z;</span><br><span class="line">e[tot].nex=head[x];</span><br><span class="line">head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,t=<span class="number">20000</span>,vis[<span class="number">20010</span>],pre[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(s); vis[s]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> k=q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(vis[to]||!e[i].len) <span class="keyword">continue</span>;</span><br><span class="line">q.push(to); vis[to]=vis[k]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> rest=<span class="number">0</span>,fl;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(vis[to]==vis[now]+<span class="number">1</span>&amp;&amp;(fl=dfs(to,min(flow,e[i].len))))&#123;</span><br><span class="line">e[i].len-=fl, e[i^<span class="number">1</span>].len+=fl, rest+=fl;</span><br><span class="line"><span class="keyword">if</span>(rest==flow) <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rest&lt;flow) vis[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(bfs()) ans+=dfs(s,<span class="number">2147483647</span>);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> jl[<span class="number">20010</span>]; <span class="keyword">int</span> next[<span class="number">20010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),cnt=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt&lt;=n)&#123;</span><br><span class="line">num++; cnt++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">sqrt</span>(i+num)==(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(i+num))</span><br><span class="line">add(i,num+<span class="number">10000</span>,<span class="number">1</span>),add(num+<span class="number">10000</span>,i,<span class="number">0</span>);</span><br><span class="line">add(s,num,<span class="number">1</span>); add(num,s,<span class="number">0</span>);</span><br><span class="line">add(num+<span class="number">10000</span>,t,<span class="number">1</span>); add(t,num+<span class="number">10000</span>,<span class="number">0</span>);</span><br><span class="line">cnt-=dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,--num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j;j=e[j].nex)&#123;</span><br><span class="line"><span class="keyword">if</span>(!e[j].len)&#123;</span><br><span class="line">next[i]=e[j].t<span class="number">-10000</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(jl[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> x=i;</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">-10000</span>)&#123;</span><br><span class="line">jl[x]=<span class="number">1</span>; <span class="built_in">printf</span>(<span class="string">"%d "</span>,x);</span><br><span class="line">x=next[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流24题 最长不下降子序列问题</title>
      <link href="/2018/08/08/wll24t-zcbxjzxywt/"/>
      <url>/2018/08/08/wll24t-zcbxjzxywt/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2766" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>这个建图啊，十分巧妙，我是真没看出来（我太蒟了）</p><p>首先要先跑一遍最长不下降子序列的$O(n^2)$解法，预处理出以$i$结尾的最长不下降子序列的长度$dp[i]$，然后找出最大的$dp[i]$，记为$cnt$，输出$cnt$，第一问就结束了。</p><p>从源点向长度为$1$的点连一条容量为$1$的边，长度为$cnt$的点向汇点连一条容量为$1$的边。因为每个点只能用一次，所以我们还要把一个点拆成两个，在它们之间连一条容量为$1$的边。之后$n^2$枚举每两个点，若两个点$i,j$满足$j{&lt;}i$且$dp[i]=dp[j]+1$，则在$i,j$之间连一条容量为$1$的边。建好图后跑一边最大流，就是第二问的答案。</p><p>第三问就好办了，将源点向$1$连的边的容量改为$\rm{INF}$，$1$和$1$被拆之后的点$1’$之间的容量也改为$\rm{INF}$。同理，$n$和$n’$之间的边、$n’$和汇点之间的边（如果存在的话）容量也要改为$\rm{INF}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> t,len,nex;</span><br><span class="line">&#125;e[<span class="number">20010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">10010</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">e[++tot].t=y;</span><br><span class="line">e[tot].len=z;</span><br><span class="line">e[tot].nex=head[x];</span><br><span class="line">head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">10010</span>],s,t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; q.push(s);</span><br><span class="line">    dis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> k=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[k];i;i=e[i].nex)&#123;</span><br><span class="line">            <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">            <span class="keyword">if</span>(dis[to]||!e[i].len) <span class="keyword">continue</span>;</span><br><span class="line">            dis[to]=dis[k]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> flow)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(now==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rest=<span class="number">0</span>,fl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(dis[to]==dis[now]+<span class="number">1</span>&amp;&amp;(fl=dfs(to,min(e[i].len,flow))))&#123;</span><br><span class="line">            e[i].len-=fl, e[i^<span class="number">1</span>].len+=fl, rest+=fl;</span><br><span class="line">            <span class="keyword">if</span>(rest==flow) <span class="keyword">return</span> rest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rest&lt;flow) dis[now]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(bfs()) ans+=dfs(s,INF);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">510</span>],dp[<span class="number">510</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(); t=(n&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read(),dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">  <span class="keyword">if</span>(a[j]&gt;=a[i]) dp[j]=max(dp[j],dp[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt=max(cnt,dp[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n%d"</span>,n,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">add(i,i+n,<span class="number">1</span>); add(i+n,i,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[i]==cnt) add(i+n,t,<span class="number">1</span>),add(t,i+n,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[i]==<span class="number">1</span>) add(s,i,<span class="number">1</span>),add(i,s,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]&lt;=a[i]&amp;&amp;dp[j]+<span class="number">1</span>==dp[i])</span><br><span class="line">  add(j+n,i,<span class="number">1</span>),add(i,n+j,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dinic());</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>+n,INF),add(n+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">add(n,n&lt;&lt;<span class="number">1</span>,INF),add(n&lt;&lt;<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>]==<span class="number">1</span>) add(s,<span class="number">1</span>,INF), add(<span class="number">1</span>,s,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(dp[n]==cnt) add(n&lt;&lt;<span class="number">1</span>,t,INF), add(t,n&lt;&lt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dinic());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 网络流24题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDOI2009 HH的项链</title>
      <link href="/2018/08/08/sdoi2009%20hhdxl/"/>
      <url>/2018/08/08/sdoi2009%20hhdxl/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1972" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fu2e66jzukg308c04okh0.gif" alt=""></p><p>这题是一道很好的<del>莫队</del>树状数组题目。</p><p>首先，我们需要离线操作，把询问全存下来，然后按询问的右端点排序</p><p>排好序后，我们可以更改树状数组维护的区间，同时记录每一个元素最后出现的位置，因为我们是从左向右来回答每个询问，所以在右面的元素肯定比在左面的相同元素作用更大一些，所以我们在相同元素中只保存在我们当前维护的区间内且最靠右的一个就好了。</p><p>之后就可以用前缀和来处理答案了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb i&amp;-i</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1000010</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=lb)</span><br><span class="line">  tree[i]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> anss=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=lb)</span><br><span class="line">  anss+=tree[i];</span><br><span class="line"><span class="keyword">return</span> anss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,pos;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(zzz x,zzz y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.r!=y.r) <span class="keyword">return</span> x.r&lt;y.r;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.l&lt;y.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=k*<span class="number">10</span>+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500010</span>],last[<span class="number">1000010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line"><span class="keyword">int</span> m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">  q[i].l=read(),q[i].r=read(),q[i].pos=i;</span><br><span class="line">sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;q[j].r)&#123;  <span class="comment">//i相当于一个指针，表示我们当前处理到哪</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(last[a[i]])&#123;</span><br><span class="line">add(last[a[i]],<span class="number">-1</span>); add(i,<span class="number">1</span>); <span class="comment">//及时更改</span></span><br><span class="line">last[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">add(i,<span class="number">1</span>); last[a[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[q[j].pos]=sum(q[j].r)-sum(q[j].l<span class="number">-1</span>); <span class="comment">//处理询问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HNOI2008 玩具装箱TOY</title>
      <link href="/2018/08/05/hnoi2008-wjzx/"/>
      <url>/2018/08/05/hnoi2008-wjzx/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3195" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>$rqy\; tql$ （日常%$rqy$）</p><hr><p>若果我们在输入时将所有的$C_i$和$L+1$，原公式可以化为$(S-L)^2$</p><p>用$f_i$表示前$i$个数的最小花费<br>$f_i=min(f_j+(S_i-S_j-L)^2)\;\; 1 {&lt;=}j{&lt;=}i-1$<br>$f_i=min(f_j+(S_i-L)^2-2(S_i-L)S_j+S_j^2)$<br>$\;\;\;\;=(S_i-L)^2+min(y_j-k_ix_j)$<br>$y_j=f_j+S_j^2,k_i=2(S_i-L),x_j=S_j$</p><p>所以我们就可用斜率优化来$A$掉这道题了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll dp[<span class="number">50010</span>],sum[<span class="number">50010</span>],l;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">x</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> sum[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">y</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> dp[i]+sum[i]*sum[i]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">k</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> <span class="number">2L</span>L*(sum[i]-l); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (y(a)-y(c))*(x(b)-x(c))-(y(b)-y(c))*(x(a)-x(c))&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll q[<span class="number">100010</span>],h=<span class="number">1</span>,t=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),l=read()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+read()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;y(q[h])-k(i)*x(q[h])&gt;=y(q[h+<span class="number">1</span>])-k(i)*x(q[h+<span class="number">1</span>])) h++;</span><br><span class="line">        dp[i]=(sum[i]-l)*(sum[i]-l)+y(q[h])-k(i)*x(q[h]);</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;check(q[t<span class="number">-1</span>],q[t],i)) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> 各省省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOI2005 瑰丽华尔兹</title>
      <link href="/2018/08/04/noi2005-glhez/"/>
      <url>/2018/08/04/noi2005-glhez/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2254" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>在这先膜一波$\mathcal{rqy}$，$rqy\; tql$！</p><hr><p>首先应该能想到正解是$DP$。我们可以枚举每个时间点来列出转移方程。<br>用$f[i][x][y]$表示在$i$这个时间点走到$(x,y)$这个位置的最长路径，我们以向下走为例，则：<br>$dp[i][x][y]=\max(dp[i-1][x][y],dp[i-1][x-1][y]+1)$<br>期望得分$50$分</p><p>但不要忘了，题目中的时间是按段给你的，所以我们没有必要去枚举每个时间点，直接枚举时间段就好了。<br>$dp[i][x][y]$表示在第$i$个时间点结束时走到了$(x,y)$这个位置的最长路径，我们还是以向下走为例：<br>$dp[i][x][y]=\max(dp[i-1][t][y]+x-t)=\max(dp[i][t][y]-t)+x$，$len$表示这次时间段的长度,$t\in [x-len,x]$。<br>这时，我们就可以用单调队列来优化$max(dp[i][t][y]-t)$，时间复杂度$O(nmk)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> mapp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">210</span>][<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,pos;</span><br><span class="line">&#125;q[<span class="number">100010</span>]; <span class="keyword">int</span> h,t;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, <span class="comment">//控制向哪个方向滑动</span></span><br><span class="line">    dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans=-inf,n,m;</span><br><span class="line"><span class="comment">// ==================算法主体==============</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> tim,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="keyword">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;y&lt;=m)&#123;  <span class="comment">//判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(mapp[x][y]) h=<span class="number">1</span>,t=<span class="number">0</span>; <span class="comment">//如果有障碍,则从之前的状态无法到达 ,清空队列,重新开始</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 入队,成为候选答案</span></span><br><span class="line">            <span class="keyword">if</span>(dp[tim<span class="number">-1</span>][x][y]!=-inf)&#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;dp[tim<span class="number">-1</span>][x][y]-now&gt;=q[t].st) t--;</span><br><span class="line">                q[++t].st=dp[tim<span class="number">-1</span>][x][y]-now;</span><br><span class="line">                q[t].pos=now; <span class="comment">//记录下标,判断是否超出长度限制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;now-q[h].pos&gt;len) h++; <span class="comment">//如果当前的队头超出长度限制 ,则出队</span></span><br><span class="line">        <span class="keyword">if</span>(h&lt;=t) dp[tim][x][y]=q[h].st+now; <span class="comment">// 单调队列,队头即为最大值,直接加上即可</span></span><br><span class="line">        <span class="keyword">else</span> dp[tim][x][y]=-inf; <span class="comment">//无法到达则置为 -inf</span></span><br><span class="line">        ans=max(ans,dp[tim][x][y]); <span class="comment">//ans记录最大值</span></span><br><span class="line">        x+=dx[d], y+=dy[d]; ++now;  <span class="comment">//继续滑动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(),m=read(); <span class="keyword">int</span> sx=read(),sy=read(),num=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(getchar()==<span class="string">'x'</span>) mapp[i][j]=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">128</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[<span class="number">0</span>][i][j]=-inf;</span><br><span class="line">    dp[<span class="number">0</span>][sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> si=read(),ti=read(),dic=read();</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">1</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) f(i,n,j,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) f(i,<span class="number">1</span>,j,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">3</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f(i,j,m,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dic==<span class="number">4</span>)</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f(i,j,<span class="number">1</span>,dic,ti-si+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以如果遇到类似的$DP$方程，可以考虑单调队列优化</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NOI2015 软件包管理器</title>
      <link href="/2018/08/03/noi2015-rjbglq/"/>
      <url>/2018/08/03/noi2015-rjbglq/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2146" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>树剖裸题……就是把区间修改变为了区间覆盖。</p><p>不过，我在处理询问的时候相当暴力，每次询问我都查了三遍……有几个点是卡过去的……它要卡卡常我说不定就$\tt{T}$了……</p><p>Luogo此题最优解倒数第12……BZOJ直接$T$飞……</p><p>具体看代码吧……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zzz</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,nex;</span><br><span class="line">&#125;e[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>]; <span class="keyword">int</span> head[<span class="number">100010</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++tot].t=y;</span><br><span class="line">    e[tot].nex=head[x];</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100010</span>],son[<span class="number">100010</span>],size[<span class="number">100010</span>],deth[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    f[now]=fa, deth[now]=deth[fa]+<span class="number">1</span>, size[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(to,now);</span><br><span class="line">        size[now]+=size[to];</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;size[son[now]]) son[now]=to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn,top[<span class="number">100010</span>],pos[<span class="number">100010</span>],rank[<span class="number">100010</span>],a[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">    top[now]=topp, pos[now]=++dfn, rank[dfn]=a[now];</span><br><span class="line">    <span class="keyword">if</span>(!son[now]) <span class="keyword">return</span> ;</span><br><span class="line">    dfs2(son[now],topp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].t;</span><br><span class="line">        <span class="keyword">if</span>(to!=f[now]&amp;&amp;to!=son[now]) dfs2(to,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>],tag[<span class="number">100010</span>&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=rank[l]; <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123; <span class="comment">//下传懒标记也要注意</span></span><br><span class="line">    <span class="keyword">if</span>(tag[p]==<span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    tag[ls]=tag[p], tag[rs]=tag[p];</span><br><span class="line">    tree[ls]=(mid-l+<span class="number">1</span>)*tag[p];</span><br><span class="line">    tree[rs]=(r-mid)*tag[p];</span><br><span class="line">    tag[p]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tree[p]=(r-l+<span class="number">1</span>)*k; tag[p]=k; <span class="comment">//线段树区间覆盖</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=nl&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        update(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x],k);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x]);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=read(); <span class="built_in">memset</span>(tag,<span class="number">-1</span>,<span class="keyword">sizeof</span>(tag)); <span class="comment">//因为有"0"和"1"两种操作,初值赋为"-1"</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read();</span><br><span class="line">        add(x+<span class="number">1</span>,i), add(i,x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>); dfs2(<span class="number">1</span>,<span class="number">1</span>); build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123; <span class="comment">//这是最暴力的部分……</span></span><br><span class="line">        <span class="built_in">string</span> s; <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'i'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k1=sum(<span class="number">1</span>,x); upd(<span class="number">1</span>,x,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> k2=sum(<span class="number">1</span>,x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k2-k1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=read()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k1=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">            update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> k2=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k1-k2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 树剖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树链剖分不详细讲解</title>
      <link href="/2018/08/02/slpf/"/>
      <url>/2018/08/02/slpf/</url>
      <content type="html"><![CDATA[<p>前置技能：线段树、DFS</p><p>当我第一次听到<strong>“树链剖分”</strong>这个算法的时候，感觉它一定很高大上。现在看来，它确实很高大上，不过也十分的<strong>暴力</strong>(个人认为，不喜勿喷)</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>　树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。<br>　————某度百科　</p></blockquote><p>百度百科对什么是树剖已经说的很明白了，接下来我们再了解一下其他的概念。</p><ul><li>重儿子：对于每一个非叶子节点，它的儿子中子树节点最多的儿子</li><li>轻儿子：对于每一个非叶子节点，它的除重儿子以外的儿子</li><li>重边：父亲节点连向重儿子的边</li><li>轻边：父亲节点连向轻儿子的边</li><li>重链：由多条重边连成的一条树链</li><li>轻链：由多条轻边连成的一条树链</li></ul><p><img src="http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_c83d70cf3bc79f3d3adc2d8cb9a1cd11728b2949.jpg" alt=""></p><p>在这张图片中，带红点的就是轻儿子，其余为重儿子；加粗的边为重边，其余的为轻边；$1-&gt;14,\;2-&gt;11,\;3-&gt;7 $的路径为重链，其余的为轻链。</p><p>前面某度已经说了，树链剖分要通过轻重边剖分将树分为多条链，那么它是怎么找出轻重边，又是怎么剖分的的呢？不要着急，我们接着讲</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>先来说一说我们需要求哪些东西</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">$f[i]$</td><td style="text-align:center">结点$i$的父亲</td></tr><tr><td style="text-align:center">$son[i]$</td><td style="text-align:center">结点$i$的重儿子(如果有$i$有两个及以上的重儿子，则随便指定一个)</td></tr><tr><td style="text-align:center">$size[i]$</td><td style="text-align:center">结点$i$的子树大小</td></tr><tr><td style="text-align:center">$deth[i]$</td><td style="text-align:center">结点$i$的深度</td></tr><tr><td style="text-align:center">$top[i]$</td><td style="text-align:center">结点$i$所在的重链的顶端(若$i$为轻儿子,则$top[i]$等于它本身)</td></tr><tr><td style="text-align:center">$pos[i]$</td><td style="text-align:center">结点$i$的新编号(可以理解为点$i$对应的$rank$数组的下标)</td></tr><tr><td style="text-align:center">$rank[i]$</td><td style="text-align:center">编号$i$对应的树上的结点的点权</td></tr></tbody></table></div><p>其中，前四个变量可以通过一次$DFS$求出，其余三个可以在第一次$DFS$的基础上再通过一次$DFS$求出</p><p>代码是这样滴：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">f[now]=fa, deth[now]=deth[fa]+<span class="number">1</span>, size[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(to==fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs1(to,now);</span><br><span class="line">size[now]+=size[to];</span><br><span class="line"><span class="keyword">if</span>(size[to]&gt;size[son[now]]) son[now]=to;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> topp)</span></span>&#123;</span><br><span class="line">top[now]=topp, pos[now]=++dfn, rank[dfn]=a[now];</span><br><span class="line"><span class="comment">//a[i]表示结点i的点权</span></span><br><span class="line"><span class="keyword">if</span>(!son[now]) <span class="keyword">return</span> ;</span><br><span class="line">dfs2(son[now],topp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(to!=son[now]&amp;&amp;to!=f[now]) dfs2(to,to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们进行第二次$DFS$的时候，我们是优先搜索重儿子，这是为了保证重链在$rank$数组里的连续性，除了重链，一颗子树的编号在$rank$数组里也是连续的。</p><p>为什么要这么做？接下来你就知道了。</p><p>到此，我们的树链剖分就讲完了。可是，现在我们求出了这么多东西，它们能干什么呢？</p><p>还记得一开始某度百科上说过可以“<em>通过数据结构(树状数组、SBT、SPLAY、线段树等)来维护每一条链</em>”吗？没错，在求出了这么多东西后，我们就可以用我们所熟悉的数据结构来瞎搞这颗树了（大雾</p><p>为了方便理解+应用广泛，我们以线段树为例来讲一下树链的维护(<del>其实是因为博主太蒟，只会线段树</del>)</p><p>假设题目让我们进行以下操作：</p><ol><li>将树从x到y结点最短路径上所有节点的值都加上z</li><li>求树从x到y结点最短路径上所有节点的值之和</li><li>将以x为根节点的子树内所有节点值都加上z</li><li>求以x为根节点的子树内所有节点值之和</li></ol><p>上文我们说过：重链在$rank$数组里是连续的，一颗子树在$rank$数组里也是连续的。所以我们可以用线段树通过多次区间修改和多次区间查询来搞定这四个操作。</p><p>首先是线段树：</p><p>其实线段树的一切都没什么变化，该怎么打还是怎么打，只不过要维护的数组变成我们剖出来的$rank$数组</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=rank[l]; <span class="keyword">return</span> ; <span class="comment">//要注意这里的数组是rank</span></span><br><span class="line">    &#125;</span><br><span class="line">    build(l,mid,ls); build(mid+<span class="number">1</span>,r,rs);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p)</span></span>&#123;  <span class="comment">//下传懒标记(我太蒟了,不会标记永久化)</span></span><br><span class="line">    tag[ls]+=tag[p]; tag[rs]+=tag[p];</span><br><span class="line">    tree[ls]+=(mid-l+<span class="number">1</span>)*tag[p];</span><br><span class="line">    tree[rs]+=(r-mid)*tag[p];</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,ll k)</span></span>&#123; <span class="comment">//区间修改</span></span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r)&#123;</span><br><span class="line">        tag[p]+=k; tree[p]+=(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) update(l,mid,ls,nl,nr,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) update(mid+<span class="number">1</span>,r,rs,nl,nr,k);</span><br><span class="line">    tree[p]=tree[ls]+tree[rs];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> p,<span class="keyword">int</span> nl,<span class="keyword">int</span> nr)</span></span>&#123; <span class="comment">//区间查询</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;nr&gt;=r) <span class="keyword">return</span> tree[p];</span><br><span class="line">    down(l,r,p);</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) ans+=query(l,mid,ls,nl,nr);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) ans+=query(mid+<span class="number">1</span>,r,rs,nl,nr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这棵线段树该怎么用呢？</p><p>如果点$x$和$y$不在一条重链上，就让它们一直跳，直到跳到一条重链上。为了防止越跳越远，我们让深度更深的先跳到另一条链上。在跳的时候，因为重链在数组中是<strong>连续</strong>的，我们就可以用线段树进行<strong>区间更改/查询</strong>来处理这一部分，通过多次区间操作，就能够实现这操作1、2。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,ll k)</span></span>&#123;  <span class="comment">//将树从x到y结点最短路径上所有节点的值都加上z</span></span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123; <span class="comment">//如果不在一条重链上</span></span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        update(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x],k);</span><br><span class="line">        x=f[top[x]]; <span class="comment">//让更深的跳上来，跳到另一条链上，顺便加上区间修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在一条链上</span></span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y],k); <span class="comment">//则处理一下两节点之间的区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//查询操作和修改是一样的……</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(deth[top[x]]&lt;deth[top[y]]) swap(x,y);</span><br><span class="line">        ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[top[x]],pos[x]);</span><br><span class="line">        x=f[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(deth[x]&gt;deth[y]) swap(x,y);</span><br><span class="line">    ans+=query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于操作3、4，则更为简单。因为子树在数组中是连续的，我们又知道每棵子树的大小，所以直接一波线段树就可以了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>,y);  <span class="comment">//将以x为根节点的子树内所有节点值都加上z</span></span><br><span class="line">query(<span class="number">1</span>,n,<span class="number">1</span>,pos[x],pos[x]+size[x]<span class="number">-1</span>)； <span class="comment">//求以x为根节点的子树内所有节点值之和</span></span><br></pre></td></tr></table></figure></p><p>到此，树剖就真的讲完了，不知众看官看懂了多少……</p><h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><ul><li><a href="https://www.luogu.org/problemnew/show/P3384" target="_blank" rel="noopener">Luogu【模板】树链剖分</a> (也就是我们讲的例题)</li><li><a href="https://www.luogu.org/problemnew/show/P3178" target="_blank" rel="noopener">HAOI2015 树上操作</a></li><li><a href="https://www.luogu.org/problemnew/show/P2146" target="_blank" rel="noopener">NOI2015 软件包管理器</a></li></ul><p>以上这些都是一些裸题。树剖本身不难理解，但因为代码较长，比较容易写错……又全是递归，不好调试……所以要多练……</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.cnblogs.com/George1994/p/7821357.html" target="_blank" rel="noopener">树链剖分原理和实现</a> —— $banananana$<br><a href="http://www.cnblogs.com/chinhhh/p/7965433.html" target="_blank" rel="noopener">树链剖分详解</a>—— $ChinHhh$<br><a href="https://www.luogu.org/blog/communist/shu-lian-pou-fen-yang-xie" target="_blank" rel="noopener">树链剖分详解</a>—— $communist$</p>]]></content>
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树剖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>$Codeforces\;Round\;500\;(Div. 2)$</title>
      <link href="/2018/08/01/cf-r500-2/"/>
      <url>/2018/08/01/cf-r500-2/</url>
      <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1013" target="_blank" rel="noopener"><strong>比赛传送门</strong></a></p><h2 id="tt-A-Piles-With-Stones"><a href="#tt-A-Piles-With-Stones" class="headerlink" title="$\tt{A. Piles\;With\;Stones}$"></a>$\tt{A. Piles\;With\;Stones}$</h2><p>水题，直接输入两个数组，比较它们两个和的大小，然后输出”Yes”或”No”</p><h2 id="rm-B-And"><a href="#rm-B-And" class="headerlink" title="$\rm{B. And}$"></a>$\rm{B. And}$</h2><p>这题还算简单，因为当一个数$\And x$后，无论再怎么$\And x$结果都不会变了，所以这道题的答案就只有$-1/0/1/2$四种，暴力枚举每一个数判断就好<del>（结果我因为一个小错误，FST了）</del></p><h2 id="C-Photo-of-The-Sky"><a href="#C-Photo-of-The-Sky" class="headerlink" title="$C.\;Photo\;of\;The\;Sky$"></a>$C.\;Photo\;of\;The\;Sky$</h2><p>假设输入的数组为$a[2n]$，为了方便，我们把要分成的两个可重集叫做$X$和$Y$</p><p>首先肯定要$sort$一下，使得数组有序，方便操作（下文提到的数组都是有序的）</p><p>接下来就是分类讨论了：</p><ul><li><p>第一种情况：数组a的最大值和最小值都在$X$里。那么$X$的极差就是$a[2n]-a[1]$，接下来我们要使$Y$的极差尽量小，我们就需要枚举一下每个元素$a[i]$，因为集合里要有$n$个元素，所以对于每个$a[i]$，能使$Y$的极差最小的方式就是将$a[i]$~$a[i+n-1]$全部放到$Y$里，所以$Y$的极差就是$\min(a[i+n-1]-a[i])\;i\in [2,n+1]$</p><p>答案为 $\min((a[i+n-1]-a[i])\cdot(a[2n]-a[1]))\;i\in [2,n+1]$</p></li></ul><ul><li><p>第二种情况：最小值（$a[1]$）和最大值（$a[2n]$）分别在$X$和$Y$里。这样我们就要使$X$的最大值尽量小，$Y$的最小值尽量大，那么$X$的极差最小就为$a[n]-a[1]$，$Y$的极差最小为$a[2n]-a[n+1]$</p><p>答案为 $(a[n]-a[1])\cdot (a[2n]-a[n+1])$</p></li></ul><p>最终的答案从这两种情况中取一个最小值就好了。</p><p>时间复杂度$O(nlogn)$（也就是排序的复杂度）</p><p>最后提醒一句：<strong>别忘了开$\mathfrak{long\;long}$</strong></p><p>上一份代码吧……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">ll a[<span class="number">100010</span>&lt;&lt;<span class="number">1</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&lt;&lt;<span class="number">1</span>;i++) a[i]=read();</span><br><span class="line">sort(a+<span class="number">1</span>,a+(n&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">ans=(a[n]-a[<span class="number">1</span>])*(a[n&lt;&lt;<span class="number">1</span>]-a[n+<span class="number">1</span>]); <span class="comment">//第二种情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)  <span class="comment">//第一种情况</span></span><br><span class="line">ans=min((a[n&lt;&lt;<span class="number">1</span>]-a[<span class="number">1</span>])*(a[i+n<span class="number">-1</span>]-a[i]),ans);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>然后后面的题就都不会了，$CF$止步于此……</p><p>我果然还是太菜了……</p>]]></content>
      
      <categories>
          
          <category> 比赛 </category>
          
          <category> Codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 比赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2016 蚯蚓</title>
      <link href="/2018/07/31/noip2016-qy/"/>
      <url>/2018/07/31/noip2016-qy/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2827" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>刚看到这道题：这题直接用堆+模拟不就可以了(并没有认真算时间复杂度)</p><p>于是用priority_queue水到了85分…… (STL大法好)</p><p>天真的我还以为是常数问题，于是疯狂卡常……<del>(我是ZZ)</del></p><p>直到我下了组数据，结果它跑了……跑了……<strong>10s</strong> <del>(这叫我怎么卡常)</del></p><p>OK，闲聊到次结束，接下来说正解</p><hr><p>其实这道题并不需要用堆，因为我们可以蚯蚓其实是满足单调性的，因为后切的蚯蚓一定要比先切的短，所以堆是不必要的，我们只用三个队列，分别记录没被切的蚯蚓、被切了的短的蚯蚓、被切了的长的蚯蚓，每次把三个队列的队头取出来比较，切掉最长的，再分别入队。</p><p>时间复杂度：$O(n+m)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>,f=<span class="number">1</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      <span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">      k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">return</span> k*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"><span class="keyword">int</span> qy[<span class="number">100010</span>],cut1[<span class="number">10000010</span>],cut2[<span class="number">10000010</span>];</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">1</span>,ta,h1=<span class="number">1</span>,t1,h2=<span class="number">1</span>,t2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("hhh.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("hhh.out","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read(),q=read(),u=read(),v=read(),t=read();</span><br><span class="line">    <span class="built_in">memset</span>(cut1,<span class="number">-127</span>,<span class="keyword">sizeof</span>(cut1));</span><br><span class="line">    <span class="built_in">memset</span>(cut2,<span class="number">-127</span>,<span class="keyword">sizeof</span>(cut2));</span><br><span class="line">    <span class="built_in">memset</span>(qy,<span class="number">-127</span>,<span class="keyword">sizeof</span>(qy));</span><br><span class="line">    p=(<span class="keyword">double</span>)u/(<span class="keyword">double</span>)v; ta=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) qy[i]=read();</span><br><span class="line">    sort(qy+<span class="number">1</span>,qy+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">-2147483647</span>; <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qy[h]&gt;=cut1[h1]&amp;&amp;qy[h]&gt;=cut2[h2]&amp;&amp;h&lt;=ta)&#123;</span><br><span class="line">    maxn=qy[h]+(i<span class="number">-1</span>)*q; h++; flag=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//printf("%d %d\n",h,ta);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut1[h1]&gt;=cut2[h2]&amp;&amp;cut1[h1]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h1&lt;=t1)&#123;</span><br><span class="line">            maxn=cut1[h1]+(i<span class="number">-1</span>)*q; h1++; flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",h1,t1);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut2[h2]&gt;=cut1[h1]&amp;&amp;cut2[h2]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h2&lt;=t2)&#123;</span><br><span class="line">            maxn=cut2[h2]+(i<span class="number">-1</span>)*q; h2++; flag=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//printf("%d %d\n",h2,t2);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf("%d %d %d\n",qy[h],cut1[h1],cut2[h2]);</span></span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>,maxn);</span><br><span class="line">        <span class="keyword">int</span> k=maxn*p;</span><br><span class="line">        cut1[++t1]=k-i*q; cut2[++t2]=maxn-k-i*q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn=<span class="number">-2147483647</span>; <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qy[h]&gt;=cut1[h1]&amp;&amp;qy[h]&gt;=cut2[h2]&amp;&amp;h&lt;=ta)&#123;</span><br><span class="line">    maxn=qy[h]+m*q; h++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut1[h1]&gt;=cut2[h2]&amp;&amp;cut1[h1]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h1&lt;=t1)&#123;</span><br><span class="line">            maxn=cut1[h1]+m*q; h1++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cut2[h2]&gt;=cut1[h1]&amp;&amp;cut2[h2]&gt;=qy[h]&amp;&amp;!flag&amp;&amp;h2&lt;=t2)&#123;</span><br><span class="line">            maxn=cut2[h2]+m*q; h2++; flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%d "</span>,maxn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Noip2011 聪明的质监员</title>
      <link href="/2018/07/30/noip2011-cmdzjy/"/>
      <url>/2018/07/30/noip2011-cmdzjy/</url>
      <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P1314" target="_blank" rel="noopener"><strong>题目传送门</strong></a></p><p>讲真，既然质监员这么聪明，为什么要让我们帮他设计程序？</p><p><del>所以还是叫ZZ的质检员吧</del></p><p>其实，我最想说的，不是这个题，而是这个$\Sigma$<del>(一见 $\Sigma$ 就懵逼系列)</del></p><p>这个题的式子是这样的：<br><img src="https://cdn.luogu.org/upload/pic/105.png" alt=""></p><p>嗯，它的意思是：在$L_i$到$R_i$这段区间里，合法的矿石的数量$\times$合法矿石的总价值</p><p>接下来就是这道题的思路了，知道这道题是二分后，这道题还是挺简单的，注意一下$\tt{long\;long}$的细节就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll k=<span class="number">0</span>; <span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>;) c=getchar();</span><br><span class="line"><span class="keyword">for</span>(;c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>;c=getchar())</span><br><span class="line">  k=(k&lt;&lt;<span class="number">3</span>)+(k&lt;&lt;<span class="number">1</span>)+c<span class="number">-48</span>;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line">ll sum[<span class="number">200010</span>],ans=<span class="number">999999999999999999L</span>L;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">200010</span>],v[<span class="number">200010</span>],w[<span class="number">200010</span>],l[<span class="number">200010</span>],r[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">100000000</span>,t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=read(),m=read(); ll s=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">w[i]=read(),v[i]=read(),h=min(w[i],h),t=max(w[i],t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">l[i]=read(), r[i]=read();</span><br><span class="line">h--, t++;</span><br><span class="line"><span class="keyword">while</span>(h&lt;t)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(h+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cnt[i]=cnt[i<span class="number">-1</span>]; sum[i]=sum[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(w[i]&gt;=mid) cnt[i]++,sum[i]+=v[i];</span><br><span class="line">&#125;</span><br><span class="line">ll y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">y+=(cnt[r[i]]-cnt[l[i]<span class="number">-1</span>])*(sum[r[i]]-sum[l[i]<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">y=s-y;</span><br><span class="line"><span class="keyword">if</span>(llabs(y)&lt;ans) ans=llabs(y);</span><br><span class="line"><span class="keyword">if</span>(y&lt;=<span class="number">0</span>) h=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
          <category> Noip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清北学堂2018DP-图论精讲班-图论学习笔记</title>
      <link href="/2018/07/22/qbxt2018-tl/"/>
      <url>/2018/07/22/qbxt2018-tl/</url>
      <content type="html"><![CDATA[<p>因为图论有好多东西比较基础，所以这篇笔记可能比较简略（<del>主要原因:博主太懒</del>）<br>因为老师可能不喜欢讲题，所以例题几乎没有<br>因为这篇笔记是我后来才补上的，所以也懒得按天数分了……</p><hr><h1 id="图论基本概念"><a href="#图论基本概念" class="headerlink" title="图论基本概念"></a>图论基本概念</h1><p>在这只列出一些定义名称，不知道的请自行百度。</p><ul><li>图<ul><li>顶点和边</li><li>顶点的度</li><li>带权图/完全图</li><li>邻接/路径</li><li>连通/强连通</li><li>稀疏图/稠密图</li><li>欧拉路</li><li>二分图</li><li>图的存储</li></ul></li><li>树<ul><li>根结点/叶子结点</li><li>高度/深度</li><li>树的遍历</li><li>二叉树的性质</li><li>树的直径</li></ul></li></ul><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><ul><li>$Prim$</li><li>$Kruskal$</li></ul><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><ul><li>$Floyd$</li><li>$Bellman-Ford$（$SPFA$）</li><li>$Dijkstra$</li></ul><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="noopener">BZOJ1001 狼抓兔子</a></p><p>平面图转对偶图跑最短路（神奇的解法）</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ul><li><p>启发式合并<br>在合并集合S1、S2的时候，我们让较小的树成为较大的树的子树。这里可以是深度、节点个数等启发函数来比较树的大小。</p></li><li><p>路径压缩<br>我们在查找完u至根节点的路径之后，一般将这条路径上的 所有节点的父节点都设为根节点，这样可以大大减少之后的查找次数。</p></li></ul><p><a href="https://www.luogu.org/problemnew/show/P1196" target="_blank" rel="noopener">NOI2002 银河英雄传说</a><br>带权并查集</p><p>关于并查集还有好多好多骚操作，在这就不详细介绍了（<del>其实我也不会</del>）</p><h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><ul><li>$Tarjan$</li></ul><h1 id="割点、桥和双连通分量"><a href="#割点、桥和双连通分量" class="headerlink" title="割点、桥和双连通分量"></a>割点、桥和双连通分量</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>割点：删掉某点之后，G分裂成两个或两个以上子图<br>割点集合：删掉某点集之后，G分裂成两个或两个以上子图<br>点连通度：最小割点集合大小<br>割边：删掉某边之后，G分裂成两个或两个以上子图<br>割边集合：删掉某边集之后，G分裂成两个或两个以上子图<br>边连通度：最小割边集合大小<br>点双联通分量：点连通度大于1的极大子图<br>边双联通分量：边连通度大于1的极大子图<br>缩点：将点双联通分量缩为一个点的过程，即删除双联通分量内所有点，然后新建一个点，向所有双联通分量内的点有边相连的外部点连边</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="求割点和桥"><a href="#求割点和桥" class="headerlink" title="求割点和桥"></a>求割点和桥</h3><h4 id="判断一个点是否为割点："><a href="#判断一个点是否为割点：" class="headerlink" title="判断一个点是否为割点："></a>判断一个点是否为割点：</h4><ol><li>该点为根节点，且有多于1个子树</li><li>该点不是根节点，但存在$(u,v)$为树枝边使得$dfn[u]{&lt;=}low[u]$</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[<span class="number">100010</span>],low[<span class="number">100010</span>],deth,cut[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line">dfn[f]=low[f]=++deth;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i;i=e[i].nex)&#123;</span><br><span class="line"><span class="keyword">int</span> to=e[i].t;</span><br><span class="line"><span class="keyword">if</span>(!dfn[to])&#123;</span><br><span class="line">son++;</span><br><span class="line">tarjan(to,fa); low[f]=min(low[to],low[f]);</span><br><span class="line"><span class="keyword">if</span>((low[to]&gt;=dfn[f]&amp;&amp;f!=fa)||(f==fa&amp;&amp;son&gt;<span class="number">1</span>)) cut[f]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[f]=min(low[f],dfn[to]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断一条边是否为桥："><a href="#判断一条边是否为桥：" class="headerlink" title="判断一条边是否为桥："></a>判断一条边是否为桥：</h4><ol><li>$(u,v)$为树枝边，且满足$dfn[u]{&lt;}low[v]$(P.S. 注意重边)</li></ol><p>老师的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[MXN], low[MXN], num;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, edge *b)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++num;</span><br><span class="line"><span class="keyword">for</span> (edge *lk = e[u]; lk; lk=lk-&gt;next) <span class="keyword">if</span> (lk != b)</span><br><span class="line"><span class="keyword">if</span> (!dfn[lk-&gt;t])&#123;</span><br><span class="line">tarjan(lk-&gt;t, op(lk)), low[u] = min(low[u], low[lk-&gt;t]);</span><br><span class="line"><span class="keyword">if</span> (dfn[u] &lt; low[lk-&gt;t])&#123;</span><br><span class="line"><span class="comment">// (u, lk-&gt;t) is bridge</span></span><br><span class="line">&#125;</span><br><span class="line">sbri[u] += sbri[lk-&gt;t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  low[u] = min(low[u], dfn[lk-&gt;t]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h4><p>建立一个栈，存储DFS过程中访问的节点，初次访问一个点时把该点入栈。<br><strong>割点可能属于多个点双连通分量</strong>，其余点和每条边属于且仅属于一个点双连通分量。因此在从栈中取出节点时，要把u留在栈中。</p><h4 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h4><p>边双连通分量的求法非常简单，只需在求出所有的桥以后，把桥边删除。此时原图分成了若干个连通块，每个连通块就是一个边双连通分量。<br>桥不属于任何一个边双连通分量；其余的边和每个顶点都属于且仅属于一个边双连通分量。</p><h1 id="最近公共祖先-LCA"><a href="#最近公共祖先-LCA" class="headerlink" title="最近公共祖先$(LCA)$"></a>最近公共祖先$(LCA)$</h1><ul><li>倍增</li><li>Tarjan</li><li><del>树链剖分</del></li></ul><h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>讲真这一部分超级学术，听的超级懵逼……<br>把概念名称打出来，自行百度吧……</p><ul><li>点支配集、点覆盖集、点独立集</li><li>边覆盖集与匹配</li></ul><p>重要结论：</p><ul><li>点覆盖数$+$点独立数$=n$</li><li>边覆盖数$+$边独立数$=n$</li><li>二分图的最小点覆盖数$=$最大匹配数</li><li>二分图的最大点独立数$=$顶点个数$-$最大匹配数。(前提是该二分图没有孤立顶点，如果有孤立顶点，对这些孤立顶点要单独考虑)</li></ul>]]></content>
      
      <categories>
          
          <category> 培训 </category>
          
          <category> 清北学堂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清北学堂2018DP&amp;图论精讲班 DP部分学习笔记</title>
      <link href="/2018/07/15/qbxt2018-dp/"/>
      <url>/2018/07/15/qbxt2018-dp/</url>
      <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>讲的挺基础的……不过还是有些地方不太明白</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p> 给定一个数n，求将n划分成若干个正整数的方案数。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p> 数字三角形</p><h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p>最长不下降子序列</p><p><strong>以上太过于基础，不做深入讨论</strong></p><hr><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>给定一个数n，求将n划分成若干个正整数的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$表示用不超过$j$的数来组成$i$</p></li><li><p>状态转移<br>$i &lt; j \;\;\; dp[i][j]=dp[i][i]$<br>$i = j \;\;\; dp[i][j]=dp[i][j-1]+1$<br>$i &gt; j \;\;\; dp[i][j]=dp[i-j][j-1]+dp[i][j-1]$</p></li></ul><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>一个人站在楼梯的第一级上，每次他可以向上走1~m级。有某些级楼梯是坏的，不能走上去。而且连续走了$k$次$m$级之后你接下来的一步只能走1级。问走到第N级的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$在第$i$级台阶上，连续走了$j$次$m$级</p></li><li><p>状态转移<br>$ \sum_{j=1}^{m-1}dp[i+j][0]+= \sum_{l=0}^{k-1}dp[i][l]$(我自己按老师的意思写的方程我自己都看不懂……)<br>$dp[i+1][0]+=dp[i][k]$<br>$dp[i+m][l+1]+=f[i][l]\;(l\neq k)$</p></li></ul><h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><a href="http://codeforces.com/problemset/problem/467/C" target="_blank" rel="noopener">Codeforces 467C George and Job</a></p><p>给定一个长度为n的序列，从序列中选出k个不重叠且连续的m个数，要求和最大。<br>$1&lt;=m\times k&lt;=n&lt;=5000$</p><p>题解：</p><ul><li><p>定义状态<br>$sum[]$为前缀和，$dp[i][j]$选了$j$段，以$i$为结尾</p></li><li><p>状态转移<br>$dp[i][j]=max(dp[i-m][j-1]+sum[i]-sum[i-m],dp[i-1][j])$</p></li></ul><h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1354" target="_blank" rel="noopener">51nod 1354 选数字</a></p><p>当给定一个序列$a[0],a[1],a[2],…,a[n-1]$和一个整数$K$时，我们想找出有多少子序列里面的所有元素乘起来恰好等于$K$。<br>方案数对$10^9+7$取模。<br>$n &lt;= 1000,k &lt;= 10^8$</p><p><strong>不会，全程懵逼</strong></p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>考试，估计要爆零……</p><p>嗯，60分，还不错——至少比想象中的高</p><h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/problemset.pdf" target="_blank" rel="noopener">考试题目</a></h3><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/sol.pdf" target="_blank" rel="noopener">官方题解</a></h3><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul><li><p>T1<br>只能说我太菜了，根本不会DP，爆搜+数据特判，40分滚粗</p></li><li><p>T2<br>我会最短路，怎么才20分？好吧，那30%$k=1$的测试点我承认我删边删错了。题目是双向边，我也是按双向边存的，结果删的时候只删了一条边……</p></li><li><p>T3<br>不会，讲了也不会 (｀＾´)ノ</p></li></ul><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>上午先讲了昨天没讲完的几道题，好吧，我太菜了，一道也不会 QAQ</p><hr><p>接Day1 例7</p><h3 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1294" target="_blank" rel="noopener">51nod 1294 修改数组</a></p><p>给出一个整数数组A，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？<br>$ n &lt; = 100000$</p><p>题解：</p><p>这道题思路很妙。</p><ul><li>$a[\;]$表示原序列<br>首先，我们将每个数$a[i]$减去它们对应的下标$i$，然后将$&lt; 0$的$a[i]$删去。因为每一个数都要是正整数，所以如果$a[i] &lt; i$，那它肯定不符合要求。<br>然后我们再在更改后的序列上找最长不下降子序列。最后用n-最长不下降子序列的长度就OK了</li></ul><h3 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h3><p>OpenJudge 6047 (找不到这道题 $\rm{Orz}$)</p><p>有一块矩形大蛋糕，长和宽分别是整数$w ,h$。现要将其切成$m$块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的$m$块小蛋糕中，最大的那块蛋糕的面积下限。<br>$w,h,m &lt;= 20$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k]$表示长宽为$i,j$的蛋糕切$k$刀的答案</p></li><li><p>边界条件<br>$dp[i][j][0]=i\times j$</p></li><li><p>状态转移<br>$dp[i][j][k]=min(max(dp[i][o][p],dp[i][j-o][k-1-p],dp[o][j][p],dp[i-o][j][k-p-1]))$</p></li></ul><h3 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h3><p><a href="http://codeforces.com/problemset/problem/407/B" target="_blank" rel="noopener">Codeforces 407B Long Path</a></p><p>有$n+1$个房间，一个人在1号房间。如果这是他第奇数次到当前房间（$i$号），那么他会去$pi\; (pi { &lt;= }i)$号房间，否则他会去$i+1$号房间。不管他去了那个房间，他的移动次数+1。<br>到达n+1号房间停止移动。问这时他的移动次数。答案对$1000000007$取模。<br>$n &lt;= 1000$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][0]$表示奇数次到达$i$号房间，$dp[i][1]$表示偶数次到达$i$号房间</p></li><li><p>状态转移<br>方程不如代码好表达(不想再写一个自己都看不懂的$\Sigma$了)，所以我就把代码给搬上来了 qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a[i]是原序列,dp数组如上所说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;i;j++)</span><br><span class="line">        dp[i][<span class="number">1</span>]+=(dp[j][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n][<span class="number">1</span>]+dp[n][<span class="number">0</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><p>至此，基础(?)的DP就讲完了</p><hr><p>进入——<strong>区间DP</strong></p><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1541" target="_blank" rel="noopener">NOIp2010 乌龟棋</a></p><p>在一行$n$个格子上进行游戏，每个格子有一个分数$a[i]$。你在$1$号格子，每次可以向前走$1/2/3/4$个格子，每种走法限制最多走$b_1/b_2/b_3/b_4$次。一次走法的分数是走过的格子的分数和。问走到n号格子的最大分数。<br>保证$b_1+2\times b_2+3\times b_3+4\times b_4=n-1$（恰好走完所有的次数）<br>$n&lt;=350,a[i]&lt;=100,b_i&lt;=40$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k][l]$表示各种类别的卡片分别还剩多少</p></li><li><p>状态转移<br>算了，本来想打方程的，懒了，丢代码吧，感受一下四维DP的魅力吧！ 233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cards[<span class="number">1</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cards[<span class="number">2</span>];j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cards[<span class="number">3</span>];k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cards[<span class="number">4</span>];l++)&#123;</span><br><span class="line">          pos=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span>(i) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(j) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(k) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(l) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+mark[pos]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[cards[<span class="number">1</span>]][cards[<span class="number">2</span>]][cards[<span class="number">3</span>]][cards[<span class="number">4</span>]]+mark[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P2679" target="_blank" rel="noopener">NOIp2015 子串</a></p><p>有两个仅包含小写英文字母的字符串$A$和$B$。现在要从字符串$A$中取出$k$个互不重叠的非空子串,然后把这$k$个子串按照其在字符串$A$中出现的顺序依次连接起来得到一个新的字符串,请问有多少种方案可以使得这个新串与字符串$B$相等？注意：子串取出的位置不同也认为是不同的方案。输出方案数%1000000007<br>$length(A) &lt;= 1000,1 &lt;= k &lt;= length(B) &lt;= 200$</p><p>题解：</p><p>这道挺毒的，卡空间，必须用滚动数组优化</p><ul><li><p>定义状态<br>$dp[i][j][k][0/1]$表示字符串$A$到$i$，字符串$B$到$j$，取出了$k$个字符串，第$i$个字符选不选</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>状态转移<br>以后有代码就直接丢代码了，懒了懒了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++,pos^=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=k;o++)&#123;</span><br><span class="line">          dp[pos][j][o][<span class="number">0</span>]=dp[pos^<span class="number">1</span>][j][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j][o][<span class="number">0</span>]%mod;</span><br><span class="line">          <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            dp[pos][j][o][<span class="number">1</span>]=dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">0</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">1</span>]%mod;</span><br><span class="line">          <span class="keyword">else</span> dp[pos][j][o][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n&amp;<span class="number">1</span>][m][k][<span class="number">0</span>]+dp[n&amp;<span class="number">1</span>][m][k][<span class="number">1</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">NOI1995 石子合并</a></p><p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。<br>$n { &lt;= } 100$</p><p>题解：</p><p>这个题目要求最小代价，除了最小代价，Luogu还要求求出最大代价，不过实现的方法一模一样</p><p>很经典的一道题目，区间DP入门必刷题</p><p>首先要破环为链+前缀和处理</p><ul><li><p>定义状态<br>$dp[i][j]$表示合并区间$[i,j]$的最小代价</p></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+n;j++)&#123;</span><br><span class="line">  dp2[i][j]=<span class="number">214748364</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">  dp2[i][j]=min(dp2[i][j],dp2[i][k]+dp2[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1040" target="_blank" rel="noopener">NOIp2003 加分二叉树</a></p><p>设一个$n$个节点的二叉树$tree$的中序遍历为$(1,2,3,…,n)$，其中数字$1,2,3,…,n$为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为$di$,$tree$及它的每个子树都有一个加分，任一棵子树$subtree$（也包含$tree$）的加分计算方法如下：<br>$subtree$的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。<br>若某个子树为空，规定其加分为$1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>试求一棵符合中序遍历为$(1,2,3,…,n)$且加分最高的二叉树$tree$。要求输出$tree$的最高加分<br>$n {&lt;=} 30$</p><p>题解：</p><p>emmmm，第三次碰到这题了，到现在还记得当时爆零的屈辱</p><ul><li><p>定义状态<br>$dp[i][j]$表示区间$[i,j]$的最大得分</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=num[i]; <span class="comment">//num[ ]为原序列</span></span><br><span class="line">dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">  <span class="keyword">if</span>(dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k]&gt;dp[i][j])&#123;</span><br><span class="line">  dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k];</span><br><span class="line">  tree[i][j]=k; <span class="comment">//用于输出</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>输出<br>这道题输出也是个坑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tree[l][r]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">print(l,tree[l][r]<span class="number">-1</span>);</span><br><span class="line">print(tree[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例5-1"><a href="#例5-1" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">SCOI2003 字符串折叠</a></p><p>折叠的定义如下：</p><p>一个字符串可以看成它自身的折叠。记作$S = S$<br>$X(S)$是$X(X&gt;1)$个$S$连接在一起的串的折叠。记作$X(S) = SSSS…S(X$个$S)$。</p><p>如果$A = A’,B = B’$，则$AB = A’B’$例如，因为$3(A) = AAA, 2(B) = BB$，所以$3(A)C2(B) = AAACBB$，而$2(3(A)C)2(B) = AAACAAACBB$</p><p>给一个字符串，求它的最短折叠。例如$AAAAAAAAAABABABCCD$的最短折叠为：$9(A)3(AB)CCD$。</p><p><strong>日常懵逼，不会</strong></p><p>区间DP就这么结束了</p><hr><p>接下来是<strong>背包</strong>和<strong>数位DP</strong></p><p><strong>背包</strong></p><h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><p>因篇幅原因$+$过于基础，在这里我们<strong>跳过所有背包模板</strong></p><h3 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h3><p>有$n$个人参加拔河比赛，要把他们分为两组，每人的实力为$a_i$，一组的实力为这组人的实力之和。求两队实力差的最小值。（两队的人数没有限制）</p><p>题解：</p><p>以$\frac{\sum_{i=1}^{n}a[i]}{2}$为背包容量，跑一遍阉割版的01背包即可</p><h3 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1782" target="_blank" rel="noopener">Luogu P1782 旅行商的背包</a></p><p>你有一个背包容积为$V$，有$n$种不可分割的物品（每种$p_i$个），每件的体积为$v_i$和价值$c_i$，你还有$m$种神奇的物品，它们的价值$c_i=a<em>v^2+b</em>v+c$，$v$是你决定的这件物体体积（大于等于0）。求最优价值。<br>$V&lt;=1000,n&lt;=1000,p_i&lt;=1000,m&lt;=5$</p><p>题解：</p><p>两种背包分开跑，先跑神奇的物品，再用跑完的dp数组去跑多重背包</p><h3 id="例3-2"><a href="#例3-2" class="headerlink" title="例3"></a>例3</h3><p><a href="https://vijos.org/p/1240" target="_blank" rel="noopener">Vijos P1240 朴素的网络游戏</a></p><p>有一家旅馆，有$n$间房间，每间可以住$a_i$人，需要$b_i$元。<br>有$i$个男人，$j$个女人来住宿，其中有$k$对夫妻，要求每间房间住的全是同性或者是一对夫妻(单人间无法住夫妻)。<br>问最少的总租金。<br>$n,i,j&lt;=300$</p><p>题解：</p><p><del>一看到这道题，机房里就充满了快♂活的气息</del></p><p> 首先，你需要想到：存在一种最优方案使得之多有一对夫妻在一件房间内。因为如果有两对，使两个男性住一间，两个女性住一间。</p><p>所以这道题里，我们只要考虑有一对夫妻就可以了</p><ul><li><p>定义状态<br>$dp[i][j][k][0/1]$表示前$i$个房间里住了$j$个男性、$k$个女性、有没有夫妻</p></li><li><p>状态转移<br>$dp[i][j][k][0]=min(dp[i-1][j][k][0],dp[i-1][j-a[i]][k][0]+b[i],dp[i-1][j][k-a[i]][0]+b[i])$<br>$dp[i][j][k][1]=min(dp[i-1][j][k][1],dp[i-1][j-1][k-1][0]+b[i],$ $dp[i-1][j-a[i]][k][1]+b[i],dp[i-1][j][k-a[i]][1]+b[i])$</p></li></ul><h3 id="例4-2"><a href="#例4-2" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1877" target="_blank" rel="noopener">HAOI2012 音量调节</a></p><p>开始有一个数$begin$，给一个长为$n$的序列$c_i$，每次操作可以选择把开始的数加或减$c_i$，变为新的数，之后在上一次的数的基础上加或减。要求每次操作之后的数要大于等于0，小于等于$max$，求最后一次操作之后这个数的最大值。如果没有满足要求的解输出-1.<br>$0 {&lt;=} begin {&lt;=} max {&lt;=} 1000,1{&lt;=}n{&lt;=}50$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$表示$i$次操作后，数为$j$是否可行</p></li><li><p>状态转移<br>$if\;\;dp[i][j]{==}1$<br>$dp[i+1][j+c[i]]=1(j+c[i]&lt;=max)$<br>$dp[i+1][j-c[i]]=1(j-c[i]&gt;=0)$</p></li></ul><h3 id="例5-2"><a href="#例5-2" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2287" target="_blank" rel="noopener">Bzoj 2287 消失之物</a></p><p>有$n$件物品，每件物品有体积$v_i$，问装满体积$V$的方案数。答案对10取模。<br>但是你要输出：如果第i件物品消失了，装了体积为j的方案数。$i=1…n,j=1…V$<br>$n,V&lt;=1000$</p><p><strong>嗯，不会</strong></p><hr><p><strong>数位</strong></p><p>感觉数位DP有些迷，真心没怎么听懂</p><h3 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h3><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1009" target="_blank" rel="noopener">51nod 1009 数字1的数量</a></p><p>给定一个十进制正整数N，写下从1开始，到N的所有正数，计算出其中出现所有1的个数。<br>例如：n = 12，包含了5个1。1,10,12共包含3个1，11包含2个1，总共5个1。</p><p>题解：</p><ul><li><p>首先可以预处理出来如果后$i$位数字随便选，那么一共有多少个$1$，记为$f[i]$。$f[i]=i\times 10^{i-1}$<br>分别计算如果前$i$位和$n$的前$i$位恰好相同，那么有多少个$1$.</p></li><li><p>如：<br>$n=124056$ 第一位为0~1<br>考虑第一位为0时，那么之后的位可以随便选，对答案贡献$f[5]$，而这一位的0不贡献答案<br>第一位为1时，那么之后的为不能随便选，只有$24057$种选法。这一位对答案的贡献是$24057$，之后继续计算后五位对答案的贡献<br>此时第一位固定为$1$。第二位可以是$0/1/2$。<br>是0时，第2位不贡献答案，但是后面4位随便选。贡献$f[4]$<br>是1时，第2位贡献答案为$10^4$。后面4位随便选，贡献$f[4]$<br>是2时，第2位不贡献答案，后面4位不能随便选，答案不能直接计算，继续固定第二位，看第3位的数值<br>……<br>直到最后一位。</p></li></ul><h3 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3652" target="_blank" rel="noopener">Hdu 3652 B-number</a></p><p>找出1~n范围内含有13并且能被13整除的数字的个数<br>$n&lt;=10^{17}$</p><p><strong>我太菜了，van♂全不会</strong></p><p>背包和数位就到此结束了</p><hr><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>接下来让我们进入<strong>状压DP</strong></p><h2 id="上午-2"><a href="#上午-2" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-4"><a href="#例1-4" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P2622" target="_blank" rel="noopener">Luogu P2622 关灯问题II</a></p><p>现有$n$盏灯，以及$m$个按钮。每个按钮可以同时控制这$n$盏灯——按下了第$i$个按钮，对于所有的灯都有一个效果。按下$i$按钮对于第$j$盏灯，是下面3中效果之一：如果$a[i][j]$为$1$，那么当这盏灯开了的时候，把它关上；如果为$-1$的话，如果这盏灯是关的，那么把它打开；如果是$0$，则无效果。<br>现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。</p><p>题解：</p><ul><li><p>emmmmm，这题只状压，不DP</p></li><li><p>存状态的时候状压</p></li><li><p>然后将能互相到达的状态之间连边，然后广搜最短路就好了</p></li></ul><h3 id="例2-4"><a href="#例2-4" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P1896" target="_blank" rel="noopener">SCOI2005 互不侵犯</a></p><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上、下、左、右，以及左上、左下、右上、右下八个方向上附近的各一个格子，共8个格子。<br>$n&lt;=9,k&lt;=n^2$</p><p>题解：</p><ul><li><p>定义状态<br>肯定要状压<br>$dp[i][k][j]$表示前$i$行放了$k$个国王，j表示第$i$行的摆放方式</p></li><li><p>状态转移<br>我们要快速的判断摆放方式是否合法<br>用$i$表示某一行的状态</p><ul><li>同一行<br>$i\And (i { &gt; &gt; }1)$</li><li>相邻行的状态$k$<br>$i\And k$<br>$i\And (k{ &gt; &gt; }1)$<br>$i\And (k{ &lt; &lt; }1)$</li></ul><p>以上的式子中如果有一个结果为1，说明无法转移<br>$get[i]$表示数字$i$的二进制位中$1$的数量，也就是第$i$行的国王数量，$l$表示$i-1$行国王的状态<br>$dp[i][k][j]+=dp[i-1][k-get[i]][l]$</p></li></ul><p>状压完结散花</p><hr><p>欢迎来到<strong>DP优化</strong>！</p><h2 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h2><p>除了例1，别的啥都不会，只会暴力DP……什么矩阵加速、数据结构维护，不存在的。</p><h2 id="例1-5"><a href="#例1-5" class="headerlink" title="例1"></a>例1</h2><p>斐波那契数列<br>$f[1]=f[2]=1$<br>$f[n]=f[n-1]+f[n-2] (n {&gt;=} 3)$<br>求$f[n]\mod(10^9+7)$<br>$n&lt;=10^{18}$</p><p>题解：</p><p>矩阵快速幂加速，不解释</p><h2 id="例2-5"><a href="#例2-5" class="headerlink" title="例2"></a>例2</h2><p><a href="http://codeforces.com/problemset/problem/821/E" target="_blank" rel="noopener">Codeforces 821E Okabe and El Psy Kongroo</a></p><p>你在$(0,0)$。在$(x,y)$时，每次移动可以到达$(x+1,y+1),(x+1,y),(x+1,y-1)$，平面上有$n$条线段，平行于$x$轴，参数为$a_i,b_i,c_i$，表示在$(a_i,c_i)$到$(b_i,c_i)$的一条线段，保证$b[i]=a[i+1]$，要求你一直在线段的下方且在$x$轴上方，即$a_i {&lt;= } x { &lt;=} b_i$时，$0 { &lt;= }y{ &lt;= }c_i$。问到达$(k,0)$的方案数，对$10^9+7$取模。<br>$n&lt;=100,k&lt;=10^{18},ci&lt;=15$</p><p>题解：</p><p>实现不是很会，但明白了做法，思路确实很神奇</p><p>直接DP就是：$dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+dp[i+1][j-1]$</p><p>但是肯定会T，所以我们可以用矩阵来加速</p><p>$\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}$ $\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}$</p><p>这样应该就可以了吧？(超级不自信)</p><h2 id="例3-3"><a href="#例3-3" class="headerlink" title="例3"></a>例3</h2><p><a href="http://noi.openjudge.cn/ch0206/9277/" target="_blank" rel="noopener">Openjudge  Noi 9277 Logs Stacking</a></p><p>给出在最底层的木头的个数，问有多少种堆放木头的方式，当然你的堆放方式不能让木头掉下来.<br>在堆放的时候木头必须互相挨着在一起.<br>$n &lt;= 200000$</p><p>题解：</p><ul><li><p>正常解法<br>$dp[i]=dp[i]+s[i]$<br>其中s是dp的前缀和。</p></li><li><p>非正常解法<br>找规律 2333</p></li></ul><h2 id="例4-3"><a href="#例4-3" class="headerlink" title="例4"></a>例4</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 4362 Dragon Ball</a></p><p>在连续的$n$秒中，在$x$轴上每秒会出现$m$个龙珠，出现之后会立即消失，知道了第一秒所在的位置，每从一个位置移动到另一个位置的时候，消耗的价值为$abs(i-j)$, 拿到龙珠也要消耗一个价值（不同龙珠的价值不同），问$n$秒之后最少消耗多少价值。<br>$m &lt;= 500,n&lt;=1000$</p><p>题解：</p><p>虽然老师在上面讲+$\mathfrak{Lancelot}$ dalao给我私下讲，但我还是有些迷，我太蒟了怎么破QAQ</p><ul><li><p>暴力DP<br>$dp[i][j]$表示在$i$秒后，在第$j$个龙珠的位置上的最小代价。<br>$dp[i][j]=min(dp[i-1][k]+abs(pos[i-1][k]-pos[i][j]))(k=1..m)+cost[i][j]$<br>时间复杂度$O(m^2n)$</p></li><li><p>优化DP<br>把绝对值拆开，变成向左走和向右走两种。<br>把当前时间的龙珠按位置排序，从左到右扫描，维护一个最小的$s=dp[i-1][k]-pos[i-1][k]$，这样$dp[i][j]=s+pos[i][j]+cost[i][j]$<br>从右到左类似。<br>$O(mnlogm)$</p></li></ul><h2 id="例5-3"><a href="#例5-3" class="headerlink" title="例5"></a>例5</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4362" target="_blank" rel="noopener">Hdu 5009 Paint Pearls</a></p><p>给你一个数组，每个值代表一种颜色，每次选一个区间删去，代价是区间内颜色种类数的平方，删完所有数组，问你最小代价是多少。<br>$n&lt;=50000$</p><p>题解：</p><p>没怎么听<del>因为听了也听不懂</del></p><p>但是应该是双向链表+DP。DP转移时直接从上一个最后一次出现的颜色那转移过来就可以。另外，区间的长度最多为$\sqrt n$个，也可以剪枝<br>时间复杂度$O(n\sqrt{n})$</p><p>DP优化也就这样了</p><hr><p>嗯，树上DP了解一下</p><h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><h2 id="上午-3"><a href="#上午-3" class="headerlink" title="上午"></a>上午</h2><h3 id="例1-6"><a href="#例1-6" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1352" target="_blank" rel="noopener">Luogu P1352 没有上司的舞会</a></p><p>某大学有$N$个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数$R_i$，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。<br>$n&lt;=6000$</p><p>题解：</p><p>树上DP经典题目</p><ul><li><p>定义状态<br>$dp[i][0/1]$表示节点i不被选/被选所获得的最大快乐指数</p></li><li><p>边界条件<br>$dp[leaf][1]=a[i]$<br>$leaf$表示叶子结点，$a[i]$是原序列</p></li><li><p>状态转移<br>$dp[from][0]+=max(dp[to][1],dp[to][0])$<br>$dp[from][1]+=dp[to][0]+a[from]$</p></li></ul><h3 id="例2-6"><a href="#例2-6" class="headerlink" title="例2"></a>例2</h3><p>树的直径</p><p>给一棵树，求树上最长路径的长度。<br>$n&lt;=500000$</p><p>题解：</p><ul><li><p>解法一：</p><ul><li>DP<br>考虑树上dp，确定一个根，一条路径一定存在一个深度最浅的节点。枚举每个点成为lca，看向子树伸出去的两条路径的长度和最长是多少。<br>$dp[i][0/1]$表示从i号点向下的最长/次长路径长度。<br>$dp[i][0]=max(dp[son][0])+1$注意只能用每个子树的最长路径更新i的最长和次长路径。即使一个子树次长路径很大，也不能更新，否则lca不是i。<br>$O(n)$</li></ul></li><li><p>解法二：</p><ul><li>随便找一个点，用$\mathcal{dfs}$找到离这个点最远的点$i$，再用$\mathcal{dfs}$找离$i$最远的点$j$。$i$到$j$的路径是一条直径。<br>证明正确性吗？不存在的，我懒得打了（逃。<br>P.S. 法二不能用于负边权</li></ul></li></ul><h3 id="例3-4"><a href="#例3-4" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P2014" target="_blank" rel="noopener">Luogu P2014 选课</a></p><p>有$n$节课可以选，每节课有至多一个前置课程，和这节课的学分，问如果只能选$m$节课，最多有多少学分。<br>$n&lt;=300$</p><p>题解：</p><ul><li><p>我说这题是树上跑背包你信么？</p></li><li><p>算法主体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">310</span>][<span class="number">310</span>],a[<span class="number">310</span>],n,m; <span class="comment">//dp[i][j]表示a[ ]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    dp[f][<span class="number">1</span>]=a[f];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[f];i!=<span class="number">-1</span>;i=tree[i].nex)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=tree[i].t; dfs(to);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> o=j<span class="number">-1</span>;o&gt;=<span class="number">1</span>;o--)</span><br><span class="line">              dp[f][j]=max(dp[f][j],dp[f][j-o]+dp[to][o]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例4-4"><a href="#例4-4" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4679" target="_blank" rel="noopener">Hdu 4079 Terrorist’s destroy</a></p><p>给定一颗树，每条边有一个权值w,问切掉哪条边之后，分成的两颗树的较大的直径*切掉边的权值最小？如果存在多条边使得结果相同，输出边id最小的。<br>$n&lt;=100000$</p><p>题解：</p><p>我们要分类讨论一下：</p><ul><li><p>要切的边在不在直径上<br>我们直接用那条边的权值去乘直径就可以了</p></li><li><p>要切的边在直径上<br>这时就需要我们能够快速的算出切开后两部分的的直径<br>要解决这个问题，我们要先算出图的一条直径，记下起点$s$和终点$t$，然后分别以$s$和$t$为根，去找直径，处理出来的$dp[u]$就是$fa[u]-&gt;u$被切开后的直径</p></li></ul><h3 id="例4-5"><a href="#例4-5" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/CF219D" target="_blank" rel="noopener">Codeforces 219D Choosing Capital for Treeland</a></p><p>给一棵树，每条边有方向，改变一条边方向的代价是1.<br>对于一个点，如果选它为根，那么需要把方向不对的边改变方向（都变成深度小的点指向深度大的点）。<br>问选一个点为根的最小代价。和选哪些点的代价是这个数字。<br>$n&lt;=200000$</p><p>题解：</p><p>$dp[u]$表示以$u$为根要调整的次数，再记录下方向<br>一遍DFS，同向加，反向减</p><h3 id="例5-4"><a href="#例5-4" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P2607" target="_blank" rel="noopener">ZJOI2008 骑士</a></p><p>给一个环套树森林，求最大权独立集。（就是相邻的点不能同时选）<br>$n&lt;=1000000$</p><p>题解：</p><blockquote><p>先找到那个环。随便找两个点，暴力枚举这两个点选不选。之后变成森林。</p></blockquote><p>这是老师PPT上的题解，就一句话，十分简练。</p><p>嗯，然后我就懵逼了……</p><p>树型DP就这么在懵逼中结束了，接下来有更懵逼的……</p><hr><p>期望DP是什么？能吃吗？斜率优化又是什么？</p><p>讲真，下午彻底懵逼</p><h2 id="下午-3"><a href="#下午-3" class="headerlink" title="下午"></a>下午</h2><h3 id="例1-7"><a href="#例1-7" class="headerlink" title="例1"></a>例1</h3><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3551" target="_blank" rel="noopener">Zoj 3551 Bloodsucker</a></p><p>开始有一个吸血鬼，n-1个平民百姓。每天等概率选出两个人，如果是一个吸血鬼一个平民，平民以p的概率被转化为吸血鬼，否则什么也不发生。问每个人都变成吸血鬼的天数期望。<br>$n&lt;=100000$</p><p>题解：</p><p>设$dp[i]$为有$i$个吸血鬼的话还期望需要多少天完成。<br>设$p[i]$为此时转换了一个平民的概率。<br>$p[i]=\frac{2\times (n-i)\times i}{n\times(n-1)}\times p$<br>$dp[i]=p[i]\times dp[i+1]+(1-p[i])\times(dp[i])+1$</p><h3 id="例2-7"><a href="#例2-7" class="headerlink" title="例2"></a>例2</h3><p><a href="http://poj.org/problem?id=3744" target="_blank" rel="noopener">Poj 3744 Scout YYF I</a></p><p>在$x$轴上，你现在的起点在$1$处。在$N$个点处布有地雷，$1&lt;=N&lt;=10$。地雷点的坐标范围：$[1,100000000]$.<br>每次前进$p$的概率前进$1$步，$1-p$的概率前进$2$步。问顺利通过这条路的概率。就是不要走到有地雷的地方。</p><p>题解：</p><ul><li><p>设$dp[i]$表示一条路径经过i的概率。<br>$dp[1]=1,dp[i]=p\times dp[i-1]+(1-p)\times dp[i-2]$<br>快速幂算出$1-dp[x_1]$就是安全通过第一个地雷的概率，此时在$x_1+1$，你又要通过$x_2,…x_n$，就是把$(x_1+1)\text{~}x_2$再做一次，全都安全通过的概率乘起来。</p></li><li><p><em>嗯，以上全都是抄的老师的PPT</em></p></li></ul><h3 id="例3-5"><a href="#例3-5" class="headerlink" title="例3"></a>例3</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2262" target="_blank" rel="noopener">hdu 2262 Where is the canteen</a></p><p>现在在一个$n\times m$规模的区域上从$’@’$处出发,每次都随机向前后左右四个方向中选择可以走的方向进入（’#’不可走, 不能越过边界）。现在问到达终点 $ 的期望步数, 终点可能有多个, 输入保证一定有起点$n,m&lt;=15$, 如果无法到达任何一个终点输出$-1$</p><p>题解：</p><p>高斯消元，爱信不信。</p><h3 id="例4-6"><a href="#例4-6" class="headerlink" title="例4"></a>例4</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">hdu 3507 Print Article</a></p><p>给一个数列ai，要求划分成若干段，一段的代价是$\sum a_i^2+M$，总的代价是每段代价和。<br>求最小总代价。<br>$n&lt;=500000$</p><p>题解：</p><ul><li>嗯，真·斜率优化</li><li>嗯，真·不会</li><li>嗯，还是把老师的代码放上来吧</li></ul><p>膜拜一下老师 orz<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , sum[<span class="number">500010</span>] , q[<span class="number">500010</span>] , dp[<span class="number">500010</span>] , head , tail;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getup</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x] + sum[x]*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdown</span> <span class="params">( <span class="keyword">int</span> x )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*sum[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) <span class="built_in">scanf</span> ( <span class="string">"%d"</span> , &amp;sum[i] );</span><br><span class="line">    sum[<span class="number">0</span>] = dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) sum[i] += sum[i<span class="number">-1</span>];</span><br><span class="line">    q[<span class="number">1</span>] = <span class="number">0</span>; head = tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= n ; i++ ) &#123;</span><br><span class="line">        <span class="comment">//斜率优化</span></span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; getup(q[head+<span class="number">1</span>]) - getup(q[head]) &lt;= sum[i]*(getdown(q[head+<span class="number">1</span>])-getdown(q[head])) ) head++;</span><br><span class="line">        dp[i] = dp[q[head]] + ( sum[i] - sum[q[head]] ) * ( sum[i] - sum[q[head]] ) + m;</span><br><span class="line">        <span class="keyword">while</span> ( head &lt; tail &amp;&amp; ( getup(q[tail]) - getup(q[tail<span class="number">-1</span>])) * ( getdown(i) - getdown(q[tail]) ) &gt;=</span><br><span class="line">                                            ( getup(i) - getup(q[tail]) ) * ( getdown(q[tail]) - getdown(q[tail<span class="number">-1</span>]) ) ) tail--;</span><br><span class="line">        q[++tail] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">"%d\n"</span> , dp[n] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="built_in">scanf</span> ( <span class="string">"%d%d"</span> , &amp;n , &amp;m ) != EOF ) work ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，DP应该就告一段落了。</p><p>我DP掌握的还是不够好，以后也要多加锻炼。</p>]]></content>
      
      <categories>
          
          <category> 培训 </category>
          
          <category> 清北学堂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>启程</title>
      <link href="/2018/07/13/Goodbye/"/>
      <url>/2018/07/13/Goodbye/</url>
      <content type="html"><![CDATA[<p>嗯，我又双叒换了一个$\tt{Blog}$……</p><p><del>zzc说得对，Blog的美化是没有尽头的</del></p><p><strong>好好学习，天天向上！</strong></p>]]></content>
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
