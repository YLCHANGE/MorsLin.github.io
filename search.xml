<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>清北学堂2018DP&amp;图论精讲班 DP部分学习笔记</title>
      <link href="/2018/07/15/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/15/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%822018DP-%E5%9B%BE%E8%AE%BA%E7%B2%BE%E8%AE%B2%E7%8F%AD-DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><p>讲的挺基础的……不过还是有些地方不太明白</p><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p> 给定一个数n，求将n划分成若干个正整数的方案数。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p> 数字三角形</p><h3 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h3><p>最长不下降子序列</p><p><strong>以上太过于基础，不做深入讨论</strong></p><hr><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>给定一个数n，求将n划分成若干个正整数的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$表示用不超过$j$的数来组成$i$</p></li><li><p>状态转移<br>$i &lt; j \;\;\; dp[i][j]=dp[i][i]$<br>$i = j \;\;\; dp[i][j]=dp[i][j-1]+1$<br>$i &gt; j \;\;\; dp[i][j]=dp[i-j][j-1]+dp[i][j-1]$</p></li></ul><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>一个人站在楼梯的第一级上，每次他可以向上走1~m级。有某些级楼梯是坏的，不能走上去。而且连续走了$k$次$m$级之后你接下来的一步只能走1级。问走到第N级的方案数。</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j]$在第$i$级台阶上，连续走了$j$次$m$级</p></li><li><p>状态转移<br>$ \sum_{j=1}^{m-1}dp[i+j][0]+= \sum_{l=0}^{k-1}dp[i][l]$(我自己按老师的意思写的方程我自己都看不懂……)<br>$dp[i+1][0]+=dp[i][k]$<br>$dp[i+m][l+1]+=f[i][l]\;(l\neq k)$</p></li></ul><h3 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h3><p><a href="http://codeforces.com/problemset/problem/467/C" target="_blank" rel="noopener">Codeforces 467C George and Job</a></p><p>给定一个长度为n的序列，从序列中选出k个不重叠且连续的m个数，要求和最大。<br>$1&lt;=m\times k&lt;=n&lt;=5000$</p><p>题解：</p><ul><li><p>定义状态<br>$sum[]$为前缀和，$dp[i][j]$选了$j$段，以$i$为结尾</p></li><li><p>状态转移<br>$dp[i][j]=max(dp[i-m][j-1]+sum[i]-sum[i-m],dp[i-1][j])$</p></li></ul><h3 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1354" target="_blank" rel="noopener">51nod 1354 选数字</a></p><p>当给定一个序列$a[0],a[1],a[2],…,a[n-1]$和一个整数$K$时，我们想找出有多少子序列里面的所有元素乘起来恰好等于$K$。<br>方案数对$10^9+7$取模。<br>$n &lt;= 1000,k &lt;= 10^8$</p><p><strong>不会，全程懵逼</strong></p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>考试，估计要爆零……</p><p>嗯，60分，还不错——至少比想象中的高</p><h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/problemset.pdf" target="_blank" rel="noopener">考试题目</a></h3><h3 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><a href="https://files.cnblogs.com/files/wxl-Ezio/sol.pdf" target="_blank" rel="noopener">官方题解</a></h3><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><ul><li><p>T1<br>只能说我太菜了，根本不会DP，爆搜+数据特判，40分滚粗</p></li><li><p>T2<br>我会最短路，怎么才20分？好吧，那30%$k=1$的测试点我承认我删边删错了。题目是双向边，我也是按双向边存的，结果删的时候只删了一条边……</p></li><li><p>T3<br>不会，讲了也不会 (｀＾´)ノ</p></li></ul><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><p>上午先讲了昨天没讲完的几道题，好吧，我太菜了，一道也不会 QAQ</p><hr><p>接Day1 例7</p><h3 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1294" target="_blank" rel="noopener">51nod 1294 修改数组</a></p><p>给出一个整数数组A，你可以将任何一个数修改为任意一个正整数，最终使得整个数组是严格递增的且均为正整数。问最少需要修改几个数？<br>$ n &lt; = 100000$</p><p>题解：</p><p>这道题思路很妙。</p><ul><li>$a[\;]$表示原序列<br>首先，我们将每个数$a[i]$减去它们对应的下标$i$，然后将$&lt; 0$的$a[i]$删去。因为每一个数都要是正整数，所以如果$a[i] &lt; i$，那它肯定不符合要求。<br>然后我们再在更改后的序列上找最长不下降子序列。最后用n-最长不下降子序列的长度就OK了</li></ul><h3 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h3><p>OpenJudge 6047 (找不到这道题 $\rm{Orz}$)</p><p>有一块矩形大蛋糕，长和宽分别是整数$w ,h$。现要将其切成$m$块小蛋糕，每个小蛋糕都必须是矩形、且长和宽均为整数。切蛋糕时，每次切一块蛋糕，将其分成两个矩形蛋糕。请计算：最后得到的$m$块小蛋糕中，最大的那块蛋糕的面积下限。<br>$w,h,m &lt;= 20$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k]$表示长宽为$i,j$的蛋糕切$k$刀的答案</p></li><li><p>边界条件<br>$dp[i][j][0]=i\times j$</p></li><li><p>状态转移<br>$dp[i][j][k]=min(max(dp[i][o][p],dp[i][j-o][k-1-p],dp[o][j][p],dp[i-o][j][k-p-1]))$</p></li></ul><h3 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h3><p><a href="http://codeforces.com/problemset/problem/407/B" target="_blank" rel="noopener">Codeforces 407B Long Path</a></p><p>有$n+1$个房间，一个人在1号房间。如果这是他第奇数次到当前房间（$i$号），那么他会去$pi\; (pi { &lt;= }i)$号房间，否则他会去$i+1$号房间。不管他去了那个房间，他的移动次数+1。<br>到达n+1号房间停止移动。问这时他的移动次数。答案对$1000000007$取模。<br>$n &lt;= 1000$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][0]$表示奇数次到达$i$号房间，$dp[i][1]$表示偶数次到达$i$号房间</p></li><li><p>状态转移<br>方程不如代码好表达(不想再写一个自己都看不懂的$\Sigma$了)，所以我就把代码给搬上来了 qwq</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a[i]是原序列,dp数组如上所说</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;i;j++)</span><br><span class="line">        dp[i][<span class="number">1</span>]+=(dp[j][<span class="number">1</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">        dp[i][<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n][<span class="number">1</span>]+dp[n][<span class="number">0</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><p>至此，基础(?)的DP就讲完了</p><hr><p>进入——<strong>区间DP</strong></p><h3 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h3><p><a href="https://www.luogu.org/problemnew/show/P1541" target="_blank" rel="noopener">NOIp2010 乌龟棋</a></p><p>在一行n个格子上进行游戏，每个格子有一个分数a[i]。你在1号格子，每次可以向前走1/2/3/4个格子，每种走法限制最多走b1/b2/b3/b4次。一次走法的分数是走过的格子的分数和。问走到n号格子的最大分数。<br>保证$b_1+2\times b_2+3\times b_3+4\times b_4=n-1$（恰好走完所有的次数）<br>$n&lt;=350,a[i]&lt;=100,bi&lt;=40$</p><p>题解：</p><ul><li><p>定义状态<br>$dp[i][j][k][l]$表示各种类别的卡片分别还剩多少</p></li><li><p>状态转移<br>算了，本来想打方程的，懒了，丢代码吧，感受一下四维DP的魅力吧！ 233</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=cards[<span class="number">1</span>];i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=cards[<span class="number">2</span>];j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=cards[<span class="number">3</span>];k++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=cards[<span class="number">4</span>];l++)&#123;</span><br><span class="line">          pos=<span class="number">1</span>+i+j*<span class="number">2</span>+k*<span class="number">3</span>+l*<span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span>(i) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i<span class="number">-1</span>][j][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(j) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j<span class="number">-1</span>][k][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(k) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k<span class="number">-1</span>][l]+mark[pos]);</span><br><span class="line">          <span class="keyword">if</span>(l) dp[i][j][k][l]=max(dp[i][j][k][l],dp[i][j][k][l<span class="number">-1</span>]+mark[pos]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[cards[<span class="number">1</span>]][cards[<span class="number">2</span>]][cards[<span class="number">3</span>]][cards[<span class="number">4</span>]]+mark[<span class="number">1</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h3><p><a href="https://www.luogu.org/problemnew/show/P2679" target="_blank" rel="noopener">NOIp2015 子串</a></p><p>有两个仅包含小写英文字母的字符串$A$和$B$。现在要从字符串$A$中取出$k$个互不重叠的非空子串,然后把这$k$个子串按照其在字符串$A$中出现的顺序依次连接起来得到一个新的字符串,请问有多少种方案可以使得这个新串与字符串$B$相等？注意：子串取出的位置不同也认为是不同的方案。输出方案数%1000000007<br>$length(A) &lt;= 1000,1 &lt;= k &lt;= length(B) &lt;= 200$</p><p>题解：</p><p>这道挺毒的，卡空间，必须用滚动数组优化</p><ul><li><p>定义状态<br>$dp[i][j][k][0/1]$表示字符串$A$到$i$，字符串$B$到$j$，取出了$k$个字符串，第$i$个字符选不选</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>状态转移<br>以后有代码就直接丢代码了，懒了懒了</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++,pos^=<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=k;o++)&#123;</span><br><span class="line">          dp[pos][j][o][<span class="number">0</span>]=dp[pos^<span class="number">1</span>][j][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j][o][<span class="number">0</span>]%mod;</span><br><span class="line">          <span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">            dp[pos][j][o][<span class="number">1</span>]=dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">0</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o][<span class="number">1</span>]%mod+dp[pos^<span class="number">1</span>][j<span class="number">-1</span>][o<span class="number">-1</span>][<span class="number">1</span>]%mod;</span><br><span class="line">          <span class="keyword">else</span> dp[pos][j][o][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(dp[n&amp;<span class="number">1</span>][m][k][<span class="number">0</span>]+dp[n&amp;<span class="number">1</span>][m][k][<span class="number">1</span>])%mod;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h3><p><a href="https://www.luogu.org/problemnew/show/P1880" target="_blank" rel="noopener">NOI1995 石子合并</a></p><p>N堆石子摆成一条线。现要将石子有次序地合并成一堆。规定每次只能选相邻的2堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的代价。计算将N堆石子合并成一堆的最小代价。<br>$n { &lt;= } 100$</p><p>题解：</p><p>这个题目要求最小代价，除了最小代价，Luogu还要求求出最大代价，不过实现的方法一模一样</p><p>很经典的一道题目，区间DP入门必刷题</p><p>首先要破环为链+前缀和处理</p><ul><li><p>定义状态<br>$dp[i][j]$表示合并区间$[i,j]$的最小代价</p></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=i+n;j++)&#123;</span><br><span class="line">  dp2[i][j]=<span class="number">214748364</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">  dp2[i][j]=min(dp2[i][j],dp2[i][k]+dp2[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h3><p><a href="https://www.luogu.org/problemnew/show/P1040" target="_blank" rel="noopener">NOIp2003 加分二叉树</a></p><p>设一个$n$个节点的二叉树$tree$的中序遍历为$(1,2,3,…,n)$，其中数字$1,2,3,…,n$为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为$di$,$tree$及它的每个子树都有一个加分，任一棵子树$subtree$（也包含$tree$）的加分计算方法如下：<br>$subtree$的左子树的加分$\times subtree$ 的右子树的加分$+subtree$的根的分数。<br>若某个子树为空，规定其加分为$1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。<br>试求一棵符合中序遍历为$(1,2,3,…,n)$且加分最高的二叉树$tree$。要求输出$tree$的最高加分<br>$n {&lt;=} 30$</p><p>题解：</p><p>emmmm，第三次碰到这题了，到现在还记得当时爆零的屈辱</p><ul><li><p>定义状态<br>$dp[i][j]$表示区间$[i,j]$的最大得分</p></li><li><p>边界条件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i]=num[i]; <span class="comment">//num[ ]为原序列</span></span><br><span class="line">dp[i][i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态转移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">  <span class="keyword">if</span>(dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k]&gt;dp[i][j])&#123;</span><br><span class="line">  dp[i][j]=dp[i][k<span class="number">-1</span>]*dp[k+<span class="number">1</span>][j]+num[k];</span><br><span class="line">  tree[i][j]=k; <span class="comment">//用于输出</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>输出<br>这道题输出也是个坑</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tree[l][r]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">print(l,tree[l][r]<span class="number">-1</span>);</span><br><span class="line">print(tree[l][r]+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="例5-1"><a href="#例5-1" class="headerlink" title="例5"></a>例5</h3><p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">SCOI2003 字符串折叠</a></p><p>折叠的定义如下：</p><p>一个字符串可以看成它自身的折叠。记作$S = S$<br>$X(S)$是$X(X&gt;1)$个$S$连接在一起的串的折叠。记作$X(S) = SSSS…S(X$个$S)$。</p><p>如果$A = A’,B = B’$，则$AB = A’B’$例如，因为$3(A) = AAA, 2(B) = BB$，所以$3(A)C2(B) = AAACBB$，而$2(3(A)C)2(B) = AAACAAACBB$</p><p>给一个字符串，求它的最短折叠。例如$AAAAAAAAAABABABCCD$的最短折叠为：$9(A)3(AB)CCD$。</p><p><strong>日常懵逼，不会</strong></p><h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2>]]></content>
      
      <categories>
          
          <category> 培训 </category>
          
          <category> 清北学堂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Goodbye</title>
      <link href="/2018/07/13/Goodbye/"/>
      <url>/2018/07/13/Goodbye/</url>
      <content type="html"><![CDATA[<p>嗯，我又双叒换了一个$\tt{Blog}$……</p><p><del>zzc说得对，Blog的美化是没有尽头的</del></p><hr><p>既然又换了一个$\tt{Blog}$，那就要有一个新的开始，所以说：</p><p>再见了，以前的$\mathcal{Blog}$……</p><p>再见了，以前的时光……</p><p>最重要的是———</p><p>再见了，颓废……</p><hr><p>回首过去，我真的太菜了……</p><p>我到底干了些什么，干成了些什么，连我自己都不知道，</p><p>只知道，我太菜了……</p><p>我只能告诉自己：要加油啊……</p><hr><p>我希望能变成一个新的自己</p><p>不再软弱，不再无能，不再颓废……</p><p>再见了，以前的自己</p><p>我希望变成一个不一样的自己……</p><hr><p>这是我其他的$\tt{Blog}$，没事就去逛逛吧，内容可能和这个博客不太一样</p><p>虽说再见，但我还是不会抛弃他们的……<del>所以说看官没事去点个赞呗</del></p><ul><li><a href="https://www.luogu.org/blog/34188/" target="_blank" rel="noopener">Luogu Blog</a></li><li><a href="http://www.cnblogs.com/wxl-Ezio/" target="_blank" rel="noopener">Cnblog</a></li></ul><hr><p><strong>我期盼着一个新的开始……</strong></p>]]></content>
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
